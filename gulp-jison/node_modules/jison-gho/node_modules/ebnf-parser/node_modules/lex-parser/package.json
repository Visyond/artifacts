{
  "author": {
    "name": "Zach Carter",
    "email": "zach@carter.name",
    "url": "http://zaa.ch"
  },
  "name": "lex-parser",
  "version": "0.1.4-181",
  "description": "A parser for lexical grammars used by jison",
  "main": "lex-parser.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zaach/lex-parser.git"
  },
  "keywords": [
    "lexical",
    "grammar",
    "parser",
    "jison"
  ],
  "license": "MIT",
  "engines": {
    "node": ">=4.0"
  },
  "dependencies": {
    "xregexp": "github:gerhobbelt/xregexp#master"
  },
  "devDependencies": {
    "chai": "4.0.2",
    "jison-gho": "github:gerhobbelt/jison#master",
    "mocha": "3.4.2"
  },
  "gitHead": "61b8f1beec20bf415b99bda09b788a5504010cb5",
  "readme": "# lex-parser\n\n\n[![build status](https://secure.travis-ci.org/GerHobbelt/lex-parser.png)](http://travis-ci.org/GerHobbelt/lex-parser)\n\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n\n## install\n\n    npm install lex-parser\n\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make prep\n    \nto install required packages and then run:\n\n    make\n    \nto run the unit tests.\n\nThis will generate `lex-parser.js`.\n\n\n## usage\n\n    var lexParser = require(\"lex-parser\");\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n```\n\nASCII_LETTER                            [a-zA-z]\n// \\p{Alphabetic} already includes [a-zA-z], hence we don't need to merge \n// with {UNICODE_LETTER} (though jison has code to optimize if you *did* \n// include the `[a-zA-Z]` anyway):\nUNICODE_LETTER                          [\\p{Alphabetic}]\nALPHA                                   [{UNICODE_LETTER}_]\nDIGIT                                   [\\p{Number}]\nWHITESPACE                              [\\s\\r\\n\\p{Separator}]\nALNUM                                   [{ALPHA}{DIGIT}]\n\nNAME                                    [{ALPHA}](?:[{ALNUM}-]*{ALNUM})?\nID                                      [{ALPHA}]{ALNUM}*\nDECIMAL_NUMBER                          [1-9][0-9]*\nHEX_NUMBER                              \"0\"[xX][0-9a-fA-F]+\nBR                                      \\r\\n|\\n|\\r\n// WhiteSpace MUST NOT match CR/LF and the regex `\\s` DOES, so we cannot use\n// that one directly. Instead we define the {WS} macro here:\nWS                                      [^\\S\\r\\n]\n\n// Quoted string content: support *escaped* quotes inside strings:\nQUOTED_STRING_CONTENT                   (?:\\\\\\'|\\\\[^\\']|[^\\\\\\'])*\nDOUBLEQUOTED_STRING_CONTENT             (?:\\\\\\\"|\\\\[^\\\"]|[^\\\\\\\"])*\n\n// Accept any non-regex-special character as a direct literal without \n// the need to put quotes around it:\nANY_LITERAL_CHAR                        [^\\s\\r\\n<>\\[\\](){}.*+?:!=|%\\/\\\\^$,\\'\\\";]\n\n\n%s indented trail rules macro\n%x code start_condition options conditions action path set\n\n\n// Off Topic\n// ---------\n//\n// Do NOT specify the xregexp option as we want the XRegExp \\p{...} regex macros converted to \n// native regexes and used as such:\n//\n// %options xregexp\n\n%options easy_keyword_rules\n%options ranges\n%options xregexp\n\n\n\n%%\n\n<action>\"/*\"(.|\\n|\\r)*?\"*/\"             return 'ACTION_BODY';\n<action>\"//\".*                          return 'ACTION_BODY';\n// regexp with braces or quotes (and no spaces, so we don't mistake \n// a *division operator* `/` for a regex delimiter here in most circumstances):\n<action>\"/\"[^ /]*?['\"{}][^ ]*?\"/\"       return 'ACTION_BODY'; \n<action>\\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         return 'ACTION_BODY';\n<action>\"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       return 'ACTION_BODY';\n<action>[/\"'][^{}/\"']+                  return 'ACTION_BODY';\n<action>[^{}/\"']+                       return 'ACTION_BODY';\n<action>\"{\"                             yy.depth++; return '{';\n<action>\"}\"                             %{\n                                            if (yy.depth == 0) { \n                                                this.pushState('trail'); \n                                            } else { \n                                                yy.depth--; \n                                            } \n                                            return '}';\n                                        %}\n\n<conditions>{NAME}                      return 'NAME';\n<conditions>\">\"                         this.popState(); return '>';\n<conditions>\",\"                         return ',';\n<conditions>\"*\"                         return '*';\n\n<rules>{BR}+                            /* empty */\n<rules>{WS}+{BR}+                       /* empty */\n<rules>{WS}+                            this.pushState('indented');\n<rules>\"%%\"                             this.pushState('code'); return '%%';\n// Accept any non-regex-special character as a direct literal without \n// the need to put quotes around it:\n<rules>{ANY_LITERAL_CHAR}+\n                                        %{\n                                            // accept any non-regex, non-lex, non-string-delim,\n                                            // non-escape-starter, non-space character as-is\n                                            return 'CHARACTER_LIT';\n                                        %}\n<options>{NAME}                         return 'NAME';\n<options>\"=\"                            return '=';\n<options>\\\"{DOUBLEQUOTED_STRING_CONTENT}\\\"\n                                        yytext = yytext.substr(1, yyleng - 2); return 'OPTION_VALUE';\n<options>\\'{QUOTED_STRING_CONTENT}\\'\n                                        yytext = yytext.substr(1, yyleng - 2); return 'OPTION_VALUE';\n<options>[^\\s\\r\\n]+                     return 'OPTION_VALUE';\n<options>{BR}+                          this.popState(); return 'OPTIONS_END';\n<options>{WS}+                          /* skip whitespace */\n\n<start_condition>{ID}                   return 'START_COND';\n<start_condition>{BR}+                  this.popState();\n<start_condition>{WS}+                  /* empty */\n\n<trail>{WS}*{BR}+                       this.pushState('rules');\n\n<indented>\"{\"                           yy.depth = 0; this.pushState('action'); return '{';\n<indented>\"%{\"(.|{BR})*?\"%}\"            this.pushState('trail'); yytext = yytext.substr(2, yyleng - 4); return 'ACTION';\n\"%{\"(.|{BR})*?\"%}\"                      yytext = yytext.substr(2, yyleng - 4); return 'ACTION';\n<indented>\"%include\"                    %{\n                                            // This is an include instruction in place of an action:\n                                            // thanks to the `<indented>.+` rule immediately below we need to semi-duplicate\n                                            // the `%include` token recognition here vs. the almost-identical rule for the same\n                                            // further below.\n                                            // There's no real harm as we need to do something special in this case anyway:\n                                            // push 2 (two!) conditions.\n                                            //\n                                            // (Anecdotal: to find that we needed to place this almost-copy here to make the test grammar\n                                            // parse correctly took several hours as the debug facilities were - and are - too meager to\n                                            // quickly diagnose the problem while we hadn't. So the code got littered with debug prints\n                                            // and finally it hit me what the *F* went wrong, after which I saw I needed to add *this* rule!)\n\n                                            // first push the 'trail' condition which will be the follow-up after we're done parsing the path parameter...\n                                            this.pushState('trail');\n                                            // then push the immediate need: the 'path' condition.\n                                            this.pushState('path');\n                                            return 'INCLUDE';\n                                        %}\n<indented>.*                            this.popState(); return 'ACTION';\n\n\"/*\"(.|\\n|\\r)*?\"*/\"                     /* ignore */\n\"//\"[^\\r\\n]*                            /* ignore */\n\n<INITIAL>{ID}                           this.pushState('macro'); return 'NAME';\n<macro>{BR}+                            this.popState('macro');\n\n// Accept any non-regex-special character as a direct literal without \n// the need to put quotes around it:\n<macro>{ANY_LITERAL_CHAR}+\n                                        %{\n                                            // accept any non-regex, non-lex, non-string-delim,\n                                            // non-escape-starter, non-space character as-is\n                                            return 'CHARACTER_LIT';\n                                        %}\n\n{BR}+                                   /* empty */\n\\s+                                     /* empty */\n\n\\\"{DOUBLEQUOTED_STRING_CONTENT}\\\"\n                                        yytext = yytext.replace(/\\\\\"/g,'\"'); return 'STRING_LIT';\n\\'{QUOTED_STRING_CONTENT}\\'\n                                        yytext = yytext.replace(/\\\\'/g,\"'\"); return 'STRING_LIT';\n\"[\"                                     this.pushState('set'); return 'REGEX_SET_START';\n\"|\"                                     return '|';\n\"(?:\"                                   return 'SPECIAL_GROUP';\n\"(?=\"                                   return 'SPECIAL_GROUP';\n\"(?!\"                                   return 'SPECIAL_GROUP';\n\"(\"                                     return '(';\n\")\"                                     return ')';\n\"+\"                                     return '+';\n\"*\"                                     return '*';\n\"?\"                                     return '?';\n\"^\"                                     return '^';\n\",\"                                     return ',';\n\"<<EOF>>\"                               return '$';\n\"<\"                                     this.pushState('conditions'); return '<';\n\"/!\"                                    return '/!';                    // treated as `(?!atom)`\n\"/\"                                     return '/';                     // treated as `(?=atom)`\n\"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4})\n                                        return 'ESCAPE_CHAR';\n\"\\\\\".                                   yytext = yytext.replace(/^\\\\/g, ''); return 'ESCAPE_CHAR';\n\"$\"                                     return '$';\n\".\"                                     return '.';\n\"%options\"                              this.pushState('options'); return 'OPTIONS';\n\"%s\"                                    this.pushState('start_condition'); return 'START_INC';\n\"%x\"                                    this.pushState('start_condition'); return 'START_EXC';\n<INITIAL,trail,code>\"%include\"          this.pushState('path'); return 'INCLUDE';\n<INITIAL,rules,trail,code>\"%\"{NAME}([^\\r\\n]*)\n                                        %{\n                                            /* ignore unrecognized decl */\n                                            console.warn('LEX: ignoring unsupported lexer option: ', yytext + ' while lexing in ' + this.topState() + ' state:', this._input, ' /////// ', this.matched);\n                                            // this.pushState('options');\n                                            yytext = [\n                                                this.matches[1],            // {NAME}\n                                                this.matches[2].trim()      // optional value/parameters\n                                            ];\n                                            return 'UNKNOWN_DECL';\n                                        %}\n\"%%\"                                    this.pushState('rules'); return '%%';\n\"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"               return 'RANGE_REGEX';\n\"{\"{ID}\"}\"                              return 'NAME_BRACE';\n<set,options>\"{\"{ID}\"}\"                 return 'NAME_BRACE';\n\"{\"                                     return '{';\n\"}\"                                     return '}';\n\n\n<set>(?:\"\\\\\\\\\"|\"\\\\]\"|[^\\]{])+           return 'REGEX_SET';\n<set>\"{\"                                return 'REGEX_SET';\n<set>\"]\"                                this.popState('set'); return 'REGEX_SET_END';\n\n\n// in the trailing CODE block, only accept these `%include` macros when \n// they appear at the start of a line and make sure the rest of lexer \n// regexes account for this one so it'll match that way only:\n<code>[^\\r\\n]*(\\r|\\n)+                  return 'CODE';\n<code>[^\\r\\n]+                          return 'CODE';      // the bit of CODE just before EOF...\n\n\n<path>{BR}                              this.popState(); this.unput(yytext);\n<path>\\\"{DOUBLEQUOTED_STRING_CONTENT}\\\"\n                                        yytext = yytext.substr(1, yyleng - 2); this.popState(); return 'PATH';\n<path>\\'{QUOTED_STRING_CONTENT}\\'\n                                        yytext = yytext.substr(1, yyleng - 2); this.popState(); return 'PATH';\n<path>{WS}+                             // skip whitespace in the line\n<path>[^\\s\\r\\n]+                        this.popState(); return 'PATH';\n\n<*>.                                    %{\n                                            /* b0rk on bad characters */\n                                            var l0 = Math.max(0, yylloc.last_column - yylloc.first_column);\n                                            var l2 = 3;\n                                            var l1 = Math.min(79 - 4 - l0 - l2, yylloc.first_column, 0);\n                                            throw new Error('unsupported lexer input: ', yytext, ' @ ' + this.describeYYLLOC(yylloc) + ' while lexing in ' + this.topState() + ' state:\\n', indent(this.showPosition(l1, l2), 4));\n                                        %}\n\n<*><<EOF>>                              return 'EOF';\n\n%%\n\nfunction indent(s, i) {\n    var a = s.split('\\n');\n    var pf = (new Array(i + 1)).join(' ');\n    return pf + a.join('\\n' + pf);\n}\n```\n\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/zaach/lex-parser/issues"
  },
  "homepage": "https://github.com/zaach/lex-parser#readme",
  "_id": "lex-parser@0.1.4-181",
  "_shasum": "e8772a9087e33dc6df4b7d6dbb8c9223a49bf552",
  "_from": "gerhobbelt/lex-parser#master",
  "_resolved": "git://github.com/gerhobbelt/lex-parser.git#61b8f1beec20bf415b99bda09b788a5504010cb5"
}

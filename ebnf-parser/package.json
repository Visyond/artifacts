{
  "_args": [
    [
      "ebnf-parser@github:gerhobbelt/ebnf-parser#master",
      "/home/vagrant/visyond/server/v2/node_modules/jison"
    ]
  ],
  "_from": "gerhobbelt/ebnf-parser#master",
  "_id": "ebnf-parser@0.1.10-131",
  "_inCache": true,
  "_installable": true,
  "_location": "/ebnf-parser",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/gerhobbelt/ebnf-parser/master/package.json",
      "gitUrl": "git://github.com/gerhobbelt/ebnf-parser.git#master",
      "httpsUrl": "git+https://github.com/gerhobbelt/ebnf-parser.git#master",
      "shortcut": "github:gerhobbelt/ebnf-parser#master",
      "ssh": "git@github.com:gerhobbelt/ebnf-parser.git#master",
      "sshUrl": "git+ssh://git@github.com/gerhobbelt/ebnf-parser.git#master",
      "type": "github"
    },
    "name": "ebnf-parser",
    "raw": "ebnf-parser@github:gerhobbelt/ebnf-parser#master",
    "rawSpec": "github:gerhobbelt/ebnf-parser#master",
    "scope": null,
    "spec": "github:gerhobbelt/ebnf-parser#master",
    "type": "hosted"
  },
  "_requiredBy": [
    "/jison"
  ],
  "_resolved": "git://github.com/gerhobbelt/ebnf-parser.git#2e3c0bf66dafbec03190a396ba77d8d2004dc675",
  "_shasum": "7a3ba435d5846c481fca8e784c30fcd04fafed05",
  "_shrinkwrap": null,
  "_spec": "ebnf-parser@github:gerhobbelt/ebnf-parser#master",
  "_where": "/home/vagrant/visyond/server/v2/node_modules/jison",
  "author": {
    "email": "zach@carter.name",
    "name": "Zach Carter",
    "url": "http://zaa.ch"
  },
  "bugs": {
    "url": "https://github.com/zaach/ebnf-parser/issues"
  },
  "dependencies": {},
  "description": "A parser for BNF and EBNF grammars used by jison",
  "devDependencies": {
    "jison": "github:gerhobbelt/jison#master",
    "lex-parser": "github:gerhobbelt/lex-parser#master",
    "test": ">=0.6.0"
  },
  "engines": {
    "node": ">=0.9"
  },
  "gitHead": "2e3c0bf66dafbec03190a396ba77d8d2004dc675",
  "homepage": "https://github.com/zaach/ebnf-parser#readme",
  "keywords": [
    "bnf",
    "ebnf",
    "grammar",
    "jison",
    "parser"
  ],
  "license": "MIT",
  "main": "ebnf-parser.js",
  "name": "ebnf-parser",
  "optionalDependencies": {},
  "readme": "# ebnf-parser\n\nA parser for BNF and EBNF grammars used by jison.\n\n\n## install\n\n    npm install ebnf-parser\n\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make prep\n    \nto install required packages and then run:\n\n    make\n    \nto build the lib and run the unit tests.\n\nThis will generate `parser.js`, which is required by `ebnf-parser.js`.\n\n\n## usage\n\nThe parser translates a string grammar or JSON grammar into a JSON grammar that jison can use (ENBF is transformed into BNF).\n\n    var ebnfParser = require('ebnf-parser');\n\n    // parse a bnf or ebnf string grammar\n    ebnfParser.parse(\"%start ... %\");\n\n    // transform an ebnf JSON gramamr\n    ebnfParser.transform({\"ebnf\": ...});\n\n\n## example grammar\n\nThe parser can parse its own BNF grammar, shown below:\n\n```\n%start spec\n\n%parse-param options\n\n\n/* grammar for parsing jison grammar files */\n\n%{\nvar fs = require('fs');\nvar transform = require('./ebnf-transform').transform;\nvar ebnf = false;\n%}\n\n%%\n\nspec\n    : declaration_list '%%' grammar optional_end_block EOF\n        {\n            $$ = $declaration_list;\n            if ($optional_end_block && $optional_end_block.trim() !== '') {\n                yy.addDeclaration($$, { include: $optional_end_block });\n            }\n            return extend($$, $grammar);\n        }\n    ;\n\noptional_end_block\n    : %empty\n    | '%%' extra_parser_module_code\n        { $$ = $extra_parser_module_code; }\n    ;\n\noptional_action_header_block\n    : %empty\n        { $$ = {}; }\n    | optional_action_header_block ACTION\n        {\n            $$ = $optional_action_header_block;\n            yy.addDeclaration($$, { actionInclude: $ACTION });\n        }\n    | optional_action_header_block include_macro_code\n        {\n            $$ = $optional_action_header_block;\n            yy.addDeclaration($$, { actionInclude: $include_macro_code });\n        }\n    ;\n\ndeclaration_list\n    : declaration_list declaration\n        { $$ = $declaration_list; yy.addDeclaration($$, $declaration); }\n    | %epsilon\n        { $$ = {}; }\n    ;\n\ndeclaration\n    : START id\n        { $$ = {start: $id}; }\n    | LEX_BLOCK\n        { $$ = {lex: $LEX_BLOCK}; }\n    | operator\n        { $$ = {operator: $operator}; }\n    | TOKEN full_token_definitions\n        { $$ = {token_list: $full_token_definitions}; }\n    | ACTION\n        { $$ = {include: $ACTION}; }\n    | include_macro_code\n        { $$ = {include: $include_macro_code}; }\n    | parse_param\n        { $$ = {parseParam: $parse_param}; }\n    | parser_type\n        { $$ = {parserType: $parser_type}; }\n    | options\n        { $$ = {options: $options}; }\n    | DEBUG\n        { $$ = {options: [['debug', true]]}; }\n    | UNKNOWN_DECL\n        { $$ = {unknownDecl: $UNKNOWN_DECL}; }\n    | IMPORT import_name import_path\n        { $$ = {imports: {name: $import_name, path: $import_path}}; }\n    | INIT_CODE import_name action_ne\n        { $$ = {initCode: {qualifier: $import_name, include: $action_ne}}; }\n    ;\n\nimport_name\n    : ID\n    | STRING\n    ;\n\nimport_path\n    : ID\n    | STRING\n    ;\n\noptions\n    : OPTIONS option_list OPTIONS_END\n        { $$ = $option_list; }\n    ;\n\noption_list\n    : option_list option\n        { $$ = $option_list; $$.push($option); }\n    | option\n        { $$ = [$option]; }\n    ;\n\noption\n    : NAME[option]\n        { $$ = [$option, true]; }\n    | NAME[option] '=' OPTION_VALUE[value]\n        { $$ = [$option, $value]; }\n    | NAME[option] '=' NAME[value]\n        { $$ = [$option, $value]; }\n    ;\n\nparse_param\n    : PARSE_PARAM token_list\n        { $$ = $token_list; }\n    ;\n\nparser_type\n    : PARSER_TYPE symbol\n        { $$ = $symbol; }\n    ;\n\noperator\n    : associativity token_list\n        { $$ = [$associativity]; $$.push.apply($$, $token_list); }\n    ;\n\nassociativity\n    : LEFT\n        { $$ = 'left'; }\n    | RIGHT\n        { $$ = 'right'; }\n    | NONASSOC\n        { $$ = 'nonassoc'; }\n    ;\n\ntoken_list\n    : token_list symbol\n        { $$ = $token_list; $$.push($symbol); }\n    | symbol\n        { $$ = [$symbol]; }\n    ;\n\n// As per http://www.gnu.org/software/bison/manual/html_node/Token-Decl.html\nfull_token_definitions\n    : optional_token_type id_list\n        {\n            var rv = [];\n            var lst = $id_list;\n            for (var i = 0, len = lst.length; i < len; i++) {\n                var id = lst[i];\n                var m = {id: id};\n                if ($optional_token_type) {\n                    m.type = $optional_token_type;\n                }\n                rv.push(m);\n            }\n            $$ = rv;\n        }\n    | optional_token_type one_full_token\n        {\n            var m = $one_full_token;\n            if ($optional_token_type) {\n                m.type = $optional_token_type;\n            }\n            $$ = [m];\n        }\n    ;\n\none_full_token\n    : id token_value token_description\n        {\n            $$ = {\n                id: $id,\n                value: $token_value\n            };\n        }\n    | id token_description\n        {\n            $$ = {\n                id: $id,\n                description: $token_description\n            };\n        }\n    | id token_value\n        {\n            $$ = {\n                id: $id,\n                value: $token_value,\n                description: $token_description\n            };\n        }\n    ;\n\noptional_token_type\n    : %epsilon\n        { $$ = false; }\n    | TOKEN_TYPE\n    ;\n\ntoken_value\n    : INTEGER\n    ;\n\ntoken_description\n    : STRING\n    ;\n\nid_list\n    : id_list id\n        { $$ = $id_list; $$.push($id); }\n    | id\n        { $$ = [$id]; }\n    ;\n\n// token_id\n//     : TOKEN_TYPE id\n//         { $$ = $id; }\n//     | id\n//         { $$ = $id; }\n//     ;\n\ngrammar\n    : optional_action_header_block production_list\n        {\n            $$ = $optional_action_header_block;\n            $$.grammar = $production_list;\n        }\n    ;\n\nproduction_list\n    : production_list production\n        {\n            $$ = $production_list;\n            if ($production[0] in $$) {\n                $$[$production[0]] = $$[$production[0]].concat($production[1]);\n            } else {\n                $$[$production[0]] = $production[1];\n            }\n        }\n    | production\n        { $$ = {}; $$[$production[0]] = $production[1]; }\n    ;\n\nproduction\n    : id ':' handle_list ';'\n        {$$ = [$id, $handle_list];}\n    ;\n\nhandle_list\n    : handle_list '|' handle_action\n        {\n            $$ = $handle_list;\n            $$.push($handle_action);\n        }\n    | handle_action\n        {\n            $$ = [$handle_action];\n        }\n    ;\n\nhandle_action\n    : handle prec action\n        {\n            $$ = [($handle.length ? $handle.join(' ') : '')];\n            if ($action) {\n                $$.push($action);\n            }\n            if ($prec) {\n                $$.push($prec);\n            }\n            if ($$.length === 1) {\n                $$ = $$[0];\n            }\n        }\n    | EPSILON action\n        // %epsilon may only be used to signal this is an empty rule alt; \n        // hence it can only occur by itself \n        // (with an optional action block, but no alias what-so-ever).\n        {\n            $$ = [''];\n            if ($action) {\n                $$.push($action);\n            }\n            if ($$.length === 1) {\n                $$ = $$[0];\n            }\n        }\n    ;\n\nhandle\n    : handle expression_suffix\n        {\n            $$ = $handle;\n            $$.push($expression_suffix);\n        }\n    | %epsilon\n        {\n            $$ = [];\n        }\n    ;\n\nhandle_sublist\n    : handle_sublist '|' handle\n        {\n            $$ = $handle_sublist;\n            $$.push($handle.join(' '));\n        }\n    | handle\n        {\n            $$ = [$handle.join(' ')];\n        }\n    ;\n\nexpression_suffix\n    : expression suffix ALIAS\n        {\n            $$ = $expression + $suffix + \"[\" + $ALIAS + \"]\";\n        }\n    | expression suffix\n        {\n            $$ = $expression + $suffix;\n        }\n    ;\n\nexpression\n    : ID\n        {\n            $$ = $ID;\n        }\n    | STRING\n        {\n            // Re-encode the string *anyway* as it will\n            // be made part of the rule rhs a.k.a. production (type: *string*) again and we want\n            // to be able to handle all tokens, including *significant space*\n            // encoded as literal tokens in a grammar such as this: `rule: A ' ' B`.\n            if ($STRING.indexOf(\"'\") >= 0) {\n                $$ = '\"' + $STRING + '\"';\n            } else {\n                $$ = \"'\" + $STRING + \"'\";\n            }\n        }\n    | '(' handle_sublist ')'\n        {\n            $$ = '(' + $handle_sublist.join(' | ') + ')';\n        }\n    ;\n\nsuffix\n    : %epsilon\n        { $$ = ''; }\n    | '*'\n    | '?'\n    | '+'\n    ;\n\nprec\n    : PREC symbol\n        {\n            $$ = { prec: $symbol };\n        }\n    | %epsilon\n        {\n            $$ = null;\n        }\n    ;\n\nsymbol\n    : id\n        { $$ = $id; }\n    | STRING\n        { $$ = $STRING; }\n    ;\n\nid\n    : ID\n        { $$ = $ID; }\n    ;\n\naction_ne\n    : '{' action_body '}'\n        { $$ = $action_body; }\n    | ACTION\n        { $$ = $ACTION; }\n    | include_macro_code\n        { $$ = $include_macro_code; }\n    | ARROW_ACTION\n        { $$ = '$$ =' + $ARROW_ACTION + ';'; }\n    ;\n\naction\n    : action_ne\n        { $$ = $action_ne; }\n    | %epsilon\n        { $$ = ''; }\n    ;\n\naction_body\n    : %epsilon\n        { $$ = ''; }\n    | action_comments_body\n        { $$ = $action_comments_body; }\n    | action_body '{' action_body '}' action_comments_body\n        { $$ = $1 + $2 + $3 + $4 + $5; }\n    | action_body '{' action_body '}'\n        { $$ = $1 + $2 + $3 + $4; }\n    ;\n\naction_comments_body\n    : ACTION_BODY\n        { $$ = $ACTION_BODY; }\n    | action_comments_body ACTION_BODY\n        { $$ = $action_comments_body + $ACTION_BODY; }\n    ;\n\nextra_parser_module_code\n    : optional_module_code_chunk\n        { $$ = $optional_module_code_chunk; }\n    | optional_module_code_chunk include_macro_code extra_parser_module_code\n        { $$ = $optional_module_code_chunk + $include_macro_code + $extra_parser_module_code; }\n    ;\n\ninclude_macro_code\n    : INCLUDE PATH\n        {\n            var fileContent = fs.readFileSync($PATH, { encoding: 'utf-8' });\n            // And no, we don't support nested '%include':\n            $$ = '\\n// Included by Jison: ' + $PATH + ':\\n\\n' + fileContent + '\\n\\n// End Of Include by Jison: ' + $PATH + '\\n\\n';\n        }\n    | INCLUDE error\n        {\n            console.error(\"%include MUST be followed by a valid file path\");\n        }\n    ;\n\nmodule_code_chunk\n    : CODE\n        { $$ = $CODE; }\n    | module_code_chunk CODE\n        { $$ = $module_code_chunk + $CODE; }\n    ;\n\noptional_module_code_chunk\n    : module_code_chunk\n        { $$ = $module_code_chunk; }\n    | %epsilon\n        { $$ = ''; }\n    ;\n\n%%\n\n// transform ebnf to bnf if necessary\nfunction extend(json, grammar) {\n    json.bnf = ebnf ? transform(grammar.grammar) : grammar.grammar;\n    if (grammar.actionInclude) {\n        json.actionInclude = grammar.actionInclude;\n    }\n    return json;\n}\n```\n\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zaach/ebnf-parser.git"
  },
  "scripts": {
    "test": "make test"
  },
  "version": "0.1.10-131"
}

{
  "name": "xregexp",
  "version": "3.1.2-14",
  "description": "Extended regular expressions",
  "homepage": "http://xregexp.com/",
  "author": {
    "name": "Steven Levithan",
    "email": "steves_list@hotmail.com"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/GerHobbelt/xregexp.git"
  },
  "keywords": [
    "regex",
    "regexp",
    "regular expression",
    "unicode"
  ],
  "main": "xregexp-all.js",
  "files": [
    "LICENSE",
    "xregexp-all.js"
  ],
  "scripts": {
    "build": "bash ./tools/concatenate-source.sh",
    "test": "bash ./tests/run-tests.sh"
  },
  "devDependencies": {
    "jasmine": "2.5.3"
  },
  "gitHead": "7cb56f9a90a802ae34087ac5a257a992904a602c",
  "readme": "[XRegExp](http://xregexp.com/) 3.1.2-12\n=======================================\n\n\n[![build status](https://secure.travis-ci.org/GerHobbelt/xregexp.png)](https://travis-ci.org/search/xregexp)\n\n\nXRegExp provides augmented (and extensible) JavaScript regular expressions. You get new modern syntax and flags beyond what browsers support natively. XRegExp is also a regex utility belt with tools to make your client-side grepping and parsing easier, while freeing you from worrying about pesky aspects of JavaScript regexes like cross-browser inconsistencies or manually manipulating `lastIndex`.\n\nXRegExp supports all native ES6 regular expression syntax. It supports Internet Explorer 5.5+, Firefox 1.5+, Chrome, Safari 3+, and Opera 11+. You can also use it with Node.js or as a RequireJS module.\n\n## Performance\n\nXRegExp regexes compile to native `RegExp` objects, and therefore perform just as fast as native regular expressions. There is a tiny extra cost when compiling a pattern for the first time.\n\n## Usage examples\n\n```js\n// Using named capture and flag x (free-spacing and line comments)\nvar date = XRegExp('(?<year>  [0-9]{4} ) -?  # year  \\n\\\n                    (?<month> [0-9]{2} ) -?  # month \\n\\\n                    (?<day>   [0-9]{2} )     # day   ', 'x');\n\n// XRegExp.exec gives you named backreferences on the match result\nvar match = XRegExp.exec('2015-02-22', date);\nmatch.year; // -> '2015'\n\n// It also includes optional pos and sticky arguments\nvar pos = 3;\nvar result = [];\nwhile (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d+)>/, pos, 'sticky')) {\n    result.push(match[1]);\n    pos = match.index + match[0].length;\n}\n// result -> ['2', '3', '4']\n\n// XRegExp.replace allows named backreferences in replacements\nXRegExp.replace('2015-02-22', date, '${month}/${day}/${year}');\n// -> '02/22/2015'\nXRegExp.replace('2015-02-22', date, function(match) {\n    return match.month + '/' + match.day + '/' + match.year;\n});\n// -> '02/22/2015'\n\n// In fact, XRegExps compile to RegExps and work perfectly with native methods\ndate.test('2015-02-22');\n// -> true\n\n// The only caveat is that named captures must be referenced using numbered\n// backreferences if used with native methods\n'2015-02-22'.replace(date, '$2/$3/$1');\n// -> '02/22/2015'\n\n// Extract every other digit from a string using XRegExp.forEach\nvar evens = [];\nXRegExp.forEach('1a2345', /\\d/, function(match, i) {\n    if (i % 2) evens.push(+match[0]);\n});\n// evens -> [2, 4]\n\n// Get numbers within <b> tags using XRegExp.matchChain\nXRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n    XRegExp('(?is)<b>.*?</b>'),\n    /\\d+/\n]);\n// -> ['2', '4', '56']\n\n// You can also pass forward and return specific backreferences\nvar html = '<a href=\"http://xregexp.com/\">XRegExp</a>' +\n           '<a href=\"http://www.google.com/\">Google</a>';\nXRegExp.matchChain(html, [\n    {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n    {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n]);\n// -> ['xregexp.com', 'www.google.com']\n\n// Merge strings and regexes into a single pattern with updated backreferences\nXRegExp.union(['a+b*c', /(dog)\\1/, /(cat)\\1/], 'i');\n// -> /a\\+b\\*c|(dog)\\1|(cat)\\2/i\n```\n\nThese examples give the flavor of what's possible, but XRegExp has more syntax, flags, methods, options, and browser fixes that aren't shown here. You can even augment XRegExp's regular expression syntax with addons (see below) or write your own. See [xregexp.com](http://xregexp.com/) for details.\n\n## Addons\n\nYou can either load addons individually, or bundle all addons with XRegExp by loading `xregexp-all.js`.\n\n### Unicode\n\nIf not using `xregexp-all.js`, first include the Unicode Base script and then one or more of the addons for Unicode blocks, categories, properties, or scripts.\n\nThen you can do this:\n\n```js\n// Test the Unicode category L (Letter)\nvar unicodeWord = XRegExp('^\\\\pL+$');\nunicodeWord.test('Ð ÑƒÑÑÐºÐ¸Ð¹'); // -> true\nunicodeWord.test('æ—¥æœ¬èªž'); // -> true\nunicodeWord.test('Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©'); // -> true\n\n// Test some Unicode scripts\nXRegExp('^\\\\p{Hiragana}+$').test('ã²ã‚‰ãŒãª'); // -> true\nXRegExp('^[\\\\p{Latin}\\\\p{Common}]+$').test('Ãœber CafÃ©.'); // -> true\n```\n\nBy default, `\\p{â€¦}` and `\\P{â€¦}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. In XRegExp, this is called *astral mode*. You can automatically add flag `A` for all new regexes by running `XRegExp.install('astral')`. When in astral mode, `\\p{â€¦}` and `\\P{â€¦}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.\n\n```js\n// Using flag A to match astral code points\nXRegExp('^\\\\pS$').test('ðŸ’©'); // -> false\nXRegExp('^\\\\pS$', 'A').test('ðŸ’©'); // -> true\nXRegExp('(?A)^\\\\pS$').test('ðŸ’©'); // -> true\n// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)\nXRegExp('(?A)^\\\\pS$').test('\\uD83D\\uDCA9'); // -> true\n\n// Implicit flag A\nXRegExp.install('astral');\nXRegExp('^\\\\pS$').test('ðŸ’©'); // -> true\n```\n\nOpting in to astral mode disables the use of `\\p{â€¦}` and `\\P{â€¦}` within character classes. In astral mode, use e.g. `(\\pL|[0-9_])+` instead of `[\\pL0-9_]+`.\n\nXRegExp uses Unicode 8.0.0.\n\n### XRegExp.build\n\nBuild regular expressions using named subpatterns, for readability and pattern reuse:\n\n```js\nvar time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n    hours: XRegExp.build('{{h12}} : | {{h24}}', {\n        h12: /1[0-2]|0?[1-9]/,\n        h24: /2[0-3]|[01][0-9]/\n    }),\n    minutes: /^[0-5][0-9]$/\n});\n\ntime.test('10:59'); // -> true\nXRegExp.exec('10:59', time).minutes; // -> '59'\n```\n\nNamed subpatterns can be provided as strings or regex objects. A leading `^` and trailing unescaped `$` are stripped from subpatterns if both are present, which allows embedding independently-useful anchored patterns. `{{â€¦}}` tokens can be quantified as a single unit. Any backreferences in the outer pattern or provided subpatterns are automatically renumbered to work correctly within the larger combined pattern. The syntax `({{name}})` works as shorthand for named capture via `(?<name>{{name}})`. Named subpatterns cannot be embedded within character classes.\n\nSee also: *[Creating Grammatical Regexes Using XRegExp.build](http://blog.stevenlevithan.com/archives/grammatical-patterns-xregexp-build)*.\n\n### XRegExp.matchRecursive\n\nMatch recursive constructs using XRegExp pattern strings as left and right delimiters:\n\n```js\nvar str = '(t((e))s)t()(ing)';\nXRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n// -> ['t((e))s', '', 'ing']\n\n// Extended information mode with valueNames\nstr = 'Here is <div> <div>an</div></div> example';\nXRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n    valueNames: ['between', 'left', 'match', 'right']\n});\n/* -> [\n{name: 'between', value: 'Here is ',       start: 0,  end: 8},\n{name: 'left',    value: '<div>',          start: 8,  end: 13},\n{name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n{name: 'right',   value: '</div>',         start: 27, end: 33},\n{name: 'between', value: ' example',       start: 33, end: 41}\n] */\n\n// Omitting unneeded parts with null valueNames, and using escapeChar\nstr = '...{1}.\\\\{{function(x,y){return {y:x}}}';\nXRegExp.matchRecursive(str, '{', '}', 'g', {\n    valueNames: ['literal', null, 'value', null],\n    escapeChar: '\\\\'\n});\n/* -> [\n{name: 'literal', value: '...',  start: 0, end: 3},\n{name: 'value',   value: '1',    start: 4, end: 5},\n{name: 'literal', value: '.\\\\{', start: 6, end: 9},\n{name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n] */\n\n// Sticky mode via flag y\nstr = '<1><<<2>>><3>4<5>';\nXRegExp.matchRecursive(str, '<', '>', 'gy');\n// -> ['1', '<<2>>', '3']\n```\n\n`XRegExp.matchRecursive` throws an error if it scans past an unbalanced delimiter in the target string.\n\n## Installation and usage\n\nIn browsers (bundle XRegExp with all of its addons):\n\n```html\n<script src=\"xregexp-all.js\"></script>\n```\n\nUsing [npm](https://www.npmjs.com/):\n\n```bash\nnpm install xregexp\n```\n\nIn [Node.js](http://nodejs.org/):\n\n```js\nvar XRegExp = require('xregexp');\n```\n\nIn an AMD loader like [RequireJS](http://requirejs.org/):\n\n```js\nrequire({paths: {xregexp: 'xregexp-all'}}, ['xregexp'], function(XRegExp) {\n    console.log(XRegExp.version);\n});\n```\n\n## About\n\nXRegExp copyright 2007-2016 by [Steven Levithan](http://stevenlevithan.com/).\n\nUnicode range generators by [Mathias Bynens](http://mathiasbynens.be/), and adapted from his [unicode-data](https://github.com/mathiasbynens/unicode-data) project. Uses [Jasmine](http://jasmine.github.io/) for unit tests, and [Benchmark.js](http://benchmarkjs.com) for performance tests. `XRegExp.build` inspired by [RegExp.create](http://lea.verou.me/2011/03/create-complex-regexps-more-easily/) by [Lea Verou](http://lea.verou.me/). `XRegExp.union` inspired by [Ruby](http://www.ruby-lang.org/). XRegExp's syntax extensions and flags come from [Perl](http://www.perl.org/), [.NET](http://www.microsoft.com/net), etc.\n\nAll code, including addons, tools, and tests, is released under the terms of the [MIT License](http://mit-license.org/).\n\nFork me to show support, fix, and extend.\n\n\n\n\n\n## Native support detection / RegExp flags\n\nXRegExp internally detects if the JS engine supports any of these RegExp flags:\n\n- `u` (defined in ES6 standard)\n- `y` (defined in ES6 standard)\n- `g`\n- `i`\n- `m`\n\nThese (and other flags registered by XRegExp addons) can be queried via the\n`XRegExp._registeredFlags()` API, e.g. when you want to include this information in a system diagnostics report which accompanies a user or automated bug report.\n\n\n\n\n\n# APIs\n\n\n## XRegExp(pattern, flags) constructor\n\nCreates an extended regular expression object for matching text with a pattern. Differs from a\nnative regular expression in that additional syntax and flags are supported. The returned object\nis in fact a native `RegExp` and works with all native methods.\n\n`pattern`\n: {String|RegExp} Regex pattern string, or an existing regex object to copy.\n\n`flags`\n: {String} (optional) Any combination of flags.\n\n  Native flags:\n\n  - `g` - global\n  - `i` - ignore case\n  - `m` - multiline anchors\n  - `u` - unicode (ES6)\n  - `y` - sticky (Firefox 3+, ES6)\n\n  Additional XRegExp flags:\n\n  - `n` - explicit capture\n  - `s` - dot matches all (aka singleline)\n  - `x` - free-spacing and line comments (aka extended)\n  - `A` - astral (requires the Unicode Base addon)\n\n  Flags cannot be provided when constructing one `RegExp` from another.\n\nReturns {RegExp} Extended regular expression object.\n\n> `RegExp` is part of the XRegExp prototype chain (`XRegExp.prototype = new RegExp()`).\n\n### Example\n\n```\n// With named capture and flag x\nXRegExp('(?<year>  [0-9]{4} ) -?  # year  \\n\\\n         (?<month> [0-9]{2} ) -?  # month \\n\\\n         (?<day>   [0-9]{2} )     # day   ', 'x');\n\n// Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n// syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n// have fresh `lastIndex` properties (set to zero).\nXRegExp(/regex/);\n```\n\n\n\n## XRegExp.version\n\nThe XRegExp version number as a string containing three dot-separated parts. For example,\n'2.0.0-beta-3'.\n\n\n\n\n## XRegExp: Public methods\n\n\n\n\n## XRegExp.addToken(regex, handler, options)\n\nExtends XRegExp syntax and allows custom flags. This is used internally and can be used to\ncreate XRegExp addons. If more than one token can match the same string, the last added wins.\n\n`regex`\n: {RegExp} Regex object that matches the new token.\n\n`handler`\n: {Function} Function that returns a new pattern string (using native regex syntax)\n  to replace the matched token within all future XRegExp regexes. Has access to persistent\n  properties of the regex being built, through `this`. Invoked with three arguments:\n\n  - The match array, with named backreference properties.\n  - The regex scope where the match was found: 'default' or 'class'.\n  - The flags used by the regex, including any flags in a leading mode modifier.\n\n  The handler function becomes part of the XRegExp construction process, so be careful not to\n  construct XRegExps within the function or you will trigger infinite recursion.\n\n`options`\n: {Object} (optional) Options object with optional properties:\n\n  - `scope` {String} Scope where the token applies: 'default  'class  or 'all'.\n  - `flag` {String} Single-character flag that triggers the token. This also registers the\n    flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n  - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n    not required to trigger the token. This registers the flags, to prevent XRegExp from\n    throwing an 'unknown flag' error when any of the flags are used.\n  - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n    final, and instead be reparseable by other tokens (including the current token). Allows\n    token chaining or deferring.\n  - `leadChar` {String} Single character that occurs at the beginning of any successful match\n    of the token (not always applicable). This doesn't change the behavior of the token unless\n    you provide an erroneous value. However, providing it can increase the token's performance\n    since the token can be skipped at any positions where this character doesn't appear.\n\n### Examples\n\n```\n// Basic usage: Add \\a for the ALERT control code\nXRegExp.addToken(\n  /\\\\a/,\n  function() {return '\\\\x07';},\n  {scope: 'all'}\n);\nXRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n\n// Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n// Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n// character classes only)\nXRegExp.addToken(\n  /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n  function(match) {return match[1] + (match[2] ? '' : '?');},\n  {flag: 'U'}\n);\nXRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\nXRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n```\n\n\n\n\n## XRegExp.cache(pattern, flags)\n\nCaches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\nthe same pattern and flag combination, the cached copy of the regex is returned.\n\n`pattern`\n: {String} Regex pattern string.\n\n`flags`\n: {String} (optional) Any combination of XRegExp flags.\n\nReturns {RegExp} Cached XRegExp object.\n\n### Example\n\n```\nwhile (match = XRegExp.cache('.', 'gs').exec(str)) {\n  // The regex is compiled once only\n}\n```\n\n\n\n## XRegExp.cache.flush(cacheName)\n\n> Intentionally undocumented; used in tests\n\n\n\n## XRegExp.escape(str)\n\nEscapes any regular expression metacharacters, for use when matching literal strings. The result\ncan safely be used at any point within a regex that uses any flags.\n\n`str`\n: {String} String to escape.\n\nReturns {String} String with regex metacharacters escaped.\n\n### Example\n\n```js\nXRegExp.escape('Escaped? <.>');\n// -> 'Escaped\\?\\ <\\.>'\n```\n\n\n\n\n## XRegExp.exec(str, regex, pos, sticky) \n\nExecutes a regex search in a specified string. Returns a match array or `null`. If the provided\nregex uses named capture, named backreference properties are included on the match array.\nOptional `pos` and `sticky` arguments specify the search start position, and whether the match\nmust start at the specified position only. The `lastIndex` property of the provided regex is not\nused, but is updated for compatibility. Also fixes browser bugs compared to the native\n`RegExp.prototype.exec` and can be used reliably cross-browser.\n\n`str` \n: {String} String to search.\n\n`regex`\n: {RegExp} Regex to search with.\n\n`pos`\n: {Number} [default: `pos=0`] Zero-based index at which to start the search.\n\n`sticky`\n: {Boolean|String} [default: `sticky=false`] Whether the match must start at the specified position\n  only. The string `'sticky'` is accepted as an alternative to `true`.\n\nReturns the match array with named backreference properties, or `null`.\n\n```js\n// Basic use, with named backreference\nvar match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\nmatch.hex; // -> '2620'\n\n// With pos and sticky, in a loop\nvar pos = 2, result = [], match;\nwhile (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n  result.push(match[1]);\n  pos = match.index + match[0].length;\n}\n// result -> ['2', '3', '4']\n```\n\n\n\n## XRegExp.forEach(str, regex, callback) \n\nExecutes a provided function once per regex match. Searches always start at the beginning of the\nstring and continue until the end, regardless of the state of the regex's `global` property and\ninitial `lastIndex`.\n \n`str`\n: {String} String to search.\n\n`regex`\n: {RegExp} Regex to search with.\n\n`callback`\n: {Function} Function to execute for each match. Invoked with four arguments:\n\n  - The match array, with named backreference properties.\n  - The zero-based match index.\n  - The string being traversed.\n  - The regex object being used to traverse the string.\n\n### Example\n\n```js\n// Extracts every other digit from a string\nvar evens = [];\nXRegExp.forEach('1a2345', /\\d/, function(match, i) {\n  if (i % 2) evens.push(+match[0]);\n});\n// evens -> [2, 4]\n```\n\n\n\n\n## XRegExp.globalize(regex) \n\nCopies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n`XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\nregexes are not recompiled using XRegExp syntax.\n\n`regex`\n: {RegExp} Regex to globalize.\n\nReturns a copy of the provided regex with flag `g` added.\n\n```js\nvar globalCopy = XRegExp.globalize(/regex/);\nglobalCopy.global; // -> true\n```\n\n\n\n## XRegExp.install(options) \n\nInstalls optional features according to the specified options. Can be undone using\n`XRegExp.uninstall`.\n\n`options`\n: {Object|String} Feature options object or feature string.\n\n### feature: astral\n\nEnables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\nall new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\nthe Unicode Base addon is not available, since flag A is registered by that addon.\n\n`astral`\n: {Boolean} `true` to enable; `false` to disable.\n\n### feature: natives\n\nNative methods to use and restore ('native' is an ES3 reserved keyword).\n\nThese native methods are overridden:\n\n- `exec`: `RegExp.prototype.exec`\n\n- `test`: `RegExp.prototype.test`\n\n- `match`: `String.prototype.match`\n\n- `replace`: `String.prototype.replace`\n\n- `split`: `String.prototype.split`\n\n\n### Examples\n\n```js\n// With an options object\nXRegExp.install({\n  // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n  astral: true,\n\n  // DEPRECATED: Overrides native regex methods with fixed/extended versions\n  natives: true\n});\n\n// With an options string\nXRegExp.install('astral natives');\n```\n\n\n\n\n\n\n\n## XRegExp.isInstalled(feature) \n\nChecks whether an individual optional feature is installed.\n\n`feature`\n: {String} Name of the feature to check. One of:\n\n  - `astral`\n  - `natives`\n\nReturn a {Boolean} value indicating whether the feature is installed.\n\n```js\nXRegExp.isInstalled('astral');\n```\n\n\n\n## XRegExp.isRegExp(value)\n\nReturns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\ncreated in another frame, when `instanceof` and `constructor` checks would fail.\n\n`value`\n: {any type allowed} The object to check.\n\nReturns a {Boolean} value indicating whether the object is a `RegExp` object.\n\n```js\nXRegExp.isRegExp('string'); // -> false\nXRegExp.isRegExp(/regex/i); // -> true\nXRegExp.isRegExp(RegExp('^', 'm')); // -> true\nXRegExp.isRegExp(XRegExp('(?s).')); // -> true\n```\n\n\n\n\n## XRegExp.match(str, regex, scope)\n\nReturns the first matched string, or in global mode, an array containing all matched strings.\nThis is essentially a more convenient re-implementation of `String.prototype.match` that gives\nthe result types you actually want (string instead of `exec`-style array in match-first mode,\nand an empty array instead of `null` when no matches are found in match-all mode). It also lets\nyou override flag g and ignore `lastIndex`, and fixes browser bugs.\n\n`str`\n: {String} String to search.\n\n`regex`\n: {RegExp} Regex to search with.\n\n`scope`\n: {String} [default: `scope='one'`] Use `'one'` to return the first match as a string. Use `'all'` to\n  return an array of all matched strings. If not explicitly specified and `regex` uses flag `g`,\n  `scope` is `'all'`.\n\nReturns a {String} in match-first mode: First match as a string, or `null`. \n\nReturns an {Array} in match-all mode: Array of all matched strings, or an empty array.\n\n```js\n// Match first\nXRegExp.match('abc', /\\w/); // -> 'a'\nXRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\nXRegExp.match('abc', /x/g, 'one'); // -> null\n\n// Match all\nXRegExp.match('abc', /\\w/g); // -> ['a  'b  'c']\nXRegExp.match('abc', /\\w/, 'all'); // -> ['a  'b  'c']\nXRegExp.match('abc', /x/, 'all'); // -> []\n```\n\n\n\n\n## XRegExp.matchChain(str, chain)\n\nRetrieves the matches from searching a string using a chain of regexes that successively search\nwithin previous matches. The provided `chain` array can contain regexes and or objects with\n`regex` and `backref` properties. When a backreference is specified, the named or numbered\nbackreference is passed forward to the next regex or returned.\n\n`str`\n: {String} String to search.\n\n`chain`\n: {Array} Regexes that each search for matches within preceding results.\n\nReturns an {Array} of matches by the last regex in the chain, or an empty array.\n\n```js\n// Basic usage; matches numbers within <b> tags\nXRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n  XRegExp('(?is)<b>.*?</b>'),\n  /\\d+/\n]);\n// -> ['2', '4', '56']\n\n// Passing forward and returning specific backreferences\nhtml = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n        <a href=\"http://www.google.com/\">Google</a>';\nXRegExp.matchChain(html, [\n  {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n  {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n]);\n// -> ['xregexp.com', 'www.google.com']\n```\n\n\n\n\n## XRegExp.replace(str, search, replacement, scope)\n\nReturns a new string with one or all matches of a pattern replaced. The pattern can be a string\nor regex, and the replacement can be a string or a function to be called for each match. To\nperform a global search and replace, use the optional `scope` argument or include flag g if using\na regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement\nfunctions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared\nto the native `String.prototype.replace` and can be used reliably cross-browser.\n\n`str`\n: {String} String to search.\n\n`search`\n: {RegExp|String} Search pattern to be replaced.\n\n`replacement`\n: {String|Function} Replacement string or a function invoked to create it.\n  \n  Replacement strings can include special replacement syntax:\n\n  - `$$` - Inserts a literal `$` character.\n  - `$&`, `$0` - Inserts the matched substring.\n  - `$\\`` - Inserts the string that precedes the matched substring (left context).\n  - `$'` - Inserts the string that follows the matched substring (right context).\n  - `$n`, `$nn` - Where `n`/`nn` are digits referencing an existent capturing group, inserts\n    backreference `n`/`nn`.\n  - `${n}` - Where `n` is a name or any number of digits that reference an existent capturing\n    group, inserts backreference `n`.\n\n  Replacement functions are invoked with three or more arguments:\n\n  - The matched substring (corresponds to $& above). Named backreferences are accessible as\n    properties of this first argument.\n  - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n  - The zero-based index of the match within the total search string.\n  - The total string being searched.\n\n`scope`\n: {String} [default: `scope='one'`] Use `'one'` to replace the first match only, or `'all'`. If not\n  explicitly specified and using a regex with flag `g`, `scope` is `'all'`.\n\nReturns a new string with one or all matches replaced.\n\n```js\n// Regex search, using named backreferences in replacement string\nvar name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\nXRegExp.replace('John Smith', name, '${last}, ${first}');\n// -> 'Smith, John'\n\n// Regex search, using named backreferences in replacement function\nXRegExp.replace('John Smith', name, function(match) {\n  return match.last + ', ' + match.first;\n});\n// -> 'Smith, John'\n \n// String search, with replace-all\nXRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n// -> 'XRegExp builds XRegExps'\n```\n\n\n\n\n## XRegExp.replaceEach(str, replacements)\n\nPerforms batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\narray of replacement details. Later replacements operate on the output of earlier replacements.\nReplacement details are accepted as an array with a regex or string to search for, the\nreplacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\nreplacement text syntax, which supports named backreference properties via `${name}`.\n\n`str`\n: {String} String to search.\n\n`replacements`\n: {Array} Array of replacement detail arrays.\n\nReturn a new string with all replacements.\n\n```js\nstr = XRegExp.replaceEach(str, [\n  [XRegExp('(?<name>a)'), 'z${name}'],\n  [/b/gi, 'y'],\n  [/c/g, 'x', 'one'], // scope 'one' overrides /g\n  [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n  ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n  [/f/g, function($0) {\n    return $0.toUpperCase();\n  }]\n]);\n```\n\n\n\n\n## XRegExp.split(str, separator, limit)\n\nSplits a string into an array of strings using a regex or string separator. Matches of the\nseparator are not included in the result array. However, if `separator` is a regex that contains\ncapturing groups, backreferences are spliced into the result each time `separator` is matched.\nFixes browser bugs compared to the native `String.prototype.split` and can be used reliably\ncross-browser.\n\n`str`\n: {String} String to split.\n\n`separator`\n: {RegExp|String} Regex or string to use for separating the string.\n\n`limit`\n: {Number} (optional) Maximum number of items to include in the result array.\n\nReturns an array of substrings.\n\n```js\n// Basic use\nXRegExp.split('a b c', ' ');\n// -> ['a', 'b', 'c']\n \n// With limit\nXRegExp.split('a b c', ' ', 2);\n// -> ['a', 'b']\n \n// Backreferences in result array\nXRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n// -> ['..', 'word', '1', '..']\n```\n\n\n\n\n## XRegExp.test(str, regex, pos, sticky) \n\nExecutes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n`sticky` arguments specify the search start position, and whether the match must start at the\nspecified position only. The `lastIndex` property of the provided regex is not used, but is\nupdated for compatibility. Also fixes browser bugs compared to the native\n`RegExp.prototype.test` and can be used reliably cross-browser.\n\n`str`\n: {String} String to search.\n\n`regex`\n: {RegExp} Regex to search with.\n\n`pos`\n: {Number} [default: `pos=0`] Zero-based index at which to start the search.\n\n`sticky`\n: {Boolean|String} [default: `sticky=false`] Whether the match must start at the specified position\n  only. The string `'sticky'` is accepted as an alternative to `true`.\n\nReturns a {Boolean} value indicating whether the regex matched the provided value.\n\n```js\n// Basic use\nXRegExp.test('abc', /c/); // -> true\n \n// With pos and sticky\nXRegExp.test('abc', /c/, 0, 'sticky'); // -> false\nXRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n```\n\n\n\n\n## XRegExp.uninstall(options) \n\nUninstalls optional features according to the specified options. All optional features start out\nuninstalled, so this is used to undo the actions of `XRegExp.install`.\n \n`options`\n: {Object|String} Feature options object or features string. These features are supported:\n\n  - `astral`\n  - `natives`\n\n```js\n// With an options object\nXRegExp.uninstall({\n  // Disables support for astral code points in Unicode addons\n  astral: true,\n \n  // DEPRECATED: Restores native regex methods\n  natives: true\n});\n\n// With an options string\nXRegExp.uninstall('astral natives');\n```\n\n\n\n\n## XRegExp.join(patterns, separator, flags)\n\nReturns an XRegExp object that is the concatenation of the given patterns. Patterns can be provided as\nregex objects or strings. Metacharacters are escaped in patterns provided as strings.\nBackreferences in provided regex objects are automatically renumbered to work correctly within\nthe larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n`flags` argument.\n\n`patterns`\n: {Array} Regexes and strings to combine.\n\n`separator`\n: {String|RegExp} Regex or string to use as the joining separator.\n\n`flags`\n: {String} (optional) Any combination of XRegExp flags.\n\nReturns the union regexp of the provided regexes and strings.\n\n```js\nXRegExp.join(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n// -> /a\\+b\\*c(dogs)\\1(cats)\\2/i\n```\n\n\n\n\n## XRegExp.union(patterns, flags)\n\nReturns an XRegExp object that is the union of the given patterns. Patterns can be provided as\nregex objects or strings. Metacharacters are escaped in patterns provided as strings.\nBackreferences in provided regex objects are automatically renumbered to work correctly within\nthe larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n`flags` argument.\n\n`patterns`\n: {Array} Regexes and strings to combine.\n\n`flags`\n: {String} (optional) Any combination of XRegExp flags.\n\nReturns the union regexp of the provided regexes and strings.\n\n```js\nXRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n// -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n```\n\n\n\n\n## Fixed/extended native methods\n\nCalling `XRegExp.install('natives')` uses this to override the native methods.\n\n\n\n\n### RegExp.exec(str) \n\nAdds named capture support (with backreferences returned as `result.name`), and fixes browser\nbugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to\noverride the native method. Use via `XRegExp.exec` without overriding natives.\n\n`str`\n: {String} String to search.\n\nReturns the match array with named backreference properties, or `null`.\n\n\n\n\n### RegExp.test(str)\n\nFixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`\nuses this to override the native method.\n\n`str`\n: {String} String to search.\n\nReturns a {Boolean} value indicating whether the regex matched the provided value.\n\n\n\n\n### String.match(regex)\n\nAdds named capture support (with backreferences returned as `result.name`), and fixes browser\nbugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to\noverride the native method.\n\n`regex`\n: {RegExp|*} Regex to search with. If not a regex object, it is passed to the `RegExp` constructor.\n\nReturns an array of match strings or `null`, if `regex` uses flag `g`. \n\nReturns the result of calling `regex.exec(this)`, if `regex` was without flag `g`.\n\n\n\n\n### String.replace(search, replacement)\n\nAdds support for `${n}` tokens for named and numbered backreferences in replacement text, and\nprovides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser\nbugs in replacement text syntax when performing a replacement using a nonregex search value, and\nthe value of a replacement regex's `lastIndex` property during replacement iterations and upon\ncompletion. Calling `XRegExp.install('natives')` uses this to override the native method. Note\nthat this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via\n`XRegExp.replace` without overriding natives.\n\n`search`\n: {RegExp|String} Search pattern to be replaced.\n\n`replacement`\n: {String|Function} Replacement string or a function invoked to create it.\n\nReturns a new string with one or all matches replaced.\n\n\n\n### String.split(separator, limit) \n\nFixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`\nuses this to override the native method. Use via `XRegExp.split` without overriding natives.\n\n`separator`\n: {RegExp|String} Regex or string to use for separating the string.\n\n`limit`\n: {Number} (optional) Maximum number of items to include in the result array.\n\nReturns an array of substrings.\n\n\n\n## Enhanced regex support features\n\n\n### Letter Escapes are errors (unless...)\n\nLetter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\nSyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\nconsistency and to reserve their syntax, but lets them be superseded by addons.\n\n```js\nXRegExp.addToken(\n    /\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, ...\n```\n\n\n### Unicode code point escapes (with curly braces)\n\nUnicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\nhexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\nto support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\nsurrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\nif you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\nif you use the same in a character class.\n\n```js\nXRegExp.addToken(\n    /\\\\u{([\\dA-Fa-f]+)}/, ...\n```\n\n\n### Empty character class\n\nEmpty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\nUnless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\ncharacter class endings can't be determined.\n\n```js\nXRegExp.addToken(\n    /\\[(\\^?)\\]/, ...\n```\n\n### Regex comment pattern\n\nComment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\nfree-spacing mode (flag `x`).\n\n```js\nXRegExp.addToken(\n    /\\(\\?#[^)]*\\)/, ...\n```\n\n\n### Free-spacing mode a.k.a. extended mode regexes\n\nWhitespace and line comments, in free-spacing mode (aka extended mode, flag `x`) only.\n\n```js\nXRegExp.addToken(\n    /\\s+|#[^\\n]*\\n?/, ...\n```\n\n\n### Dotall mode a.k.a. singleline mode (`s` flag)\n\nDot, in dotall mode (aka singleline mode, flag `s`) only.\n\n```js\nXRegExp.addToken(\n    /\\./,\n    function() {\n        return '[\\\\s\\\\S]';\n    },\n    {\n        flag: 's',\n        leadChar: '.'\n    }\n);\n```\n\n\n### Named backreference\n\nNamed backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\nand $ only. Also allows numbered backreferences as `\\k<n>`.\n\n```js\nXRegExp.addToken(\n    /\\\\k<([\\w$]+)>/, ...\n```\n\n\n### Numbered backreference\n\nNumbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\nnot followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\nare returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n\n```js\nXRegExp.addToken(\n    /\\\\(\\d+)/, ...\n```\n\n\n\n### Named capture group\n\nNamed capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\ncharacters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n`(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\nsupported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\nPython-style named capture as octals.\n\n```js\nXRegExp.addToken(\n    /\\(\\?P?<([\\w$]+)>/, ...\n```\n\n\n\n### Capture group & explicit capture mode (`n` flag)\n\nCapturing group; match the opening parenthesis only. Required for support of named capturing\ngroups. Also adds explicit capture mode (flag `n`).\n\n```js\nXRegExp.addToken(\n    /\\((?!\\?)/,\n    {\n        optionalFlags: 'n',\n        leadChar: '('\n    }\n```\n\n\n\n\n## XRegExp.build(pattern, subs, flags) \n\nBuilds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\nthe outer pattern and provided subpatterns are automatically renumbered to work correctly.\nNative flags used by provided subpatterns are ignored in favor of the `flags` argument.\n\n`pattern`\n: {String} XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n  `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n  character classes.\n\n`subs`  \n: {Object} Lookup object for named subpatterns. Values can be strings or regexes. A\n  leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n\n`flags`\n: {String} (optional) Any combination of XRegExp flags.\n\nReturns a regexp with interpolated subpatterns.\n\n```js\nvar time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n  hours: XRegExp.build('{{h12}} : | {{h24}}', {\n    h12: /1[0-2]|0?[1-9]/,\n    h24: /2[0-3]|[01][0-9]/\n  }, 'x'),\n  minutes: /^[0-5][0-9]$/\n});\ntime.test('10:59'); // -> true\nXRegExp.exec('10:59', time).minutes; // -> '59'\n```\n\n\n\n\n\n\n## XRegExp.matchRecursive(str, left, right, flags, options) \n\nReturns an array of match strings between outermost left and right delimiters, or an array of\nobjects with detailed match parts and position data. An error is thrown if delimiters are\nunbalanced within the data.\n\n`str`\n: {String} String to search.\n\n`left`\n: {String} Left delimiter as an XRegExp pattern.\n\n`right`\n: {String} Right delimiter as an XRegExp pattern.\n\n`flags`\n: {String} (optional) Any native or XRegExp flags, used for the left and right delimiters.\n\n`options`\n: {Object} (optional) Lets you specify `valueNames` and `escapeChar` options.\n\nReturns an array of matches, or an empty array.\n\n```js\n// Basic usage\nvar str = '(t((e))s)t()(ing)';\nXRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n// -> ['t((e))s', ' ', 'ing']\n \n// Extended information mode with valueNames\nstr = 'Here is <div> <div>an</div></div> example';\nXRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n  valueNames: ['between', 'left', 'match', 'right']\n});\n// -> [\n// {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n// {name: 'left',    value: '<div>',          start: 8,  end: 13},\n// {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n// {name: 'right',   value: '</div>',         start: 27, end: 33},\n// {name: 'between', value: ' example',       start: 33, end: 41}\n// ]\n \n// Omitting unneeded parts with null valueNames, and using escapeChar\nstr = '...{1}.\\\\{{function(x,y){return {y:x}}}';\nXRegExp.matchRecursive(str, '{', '}', 'g', {\n  valueNames: ['literal', null, 'value', null],\n  escapeChar: '\\\\'\n});\n// -> [\n// {name: 'literal', value: '...',  start: 0, end: 3},\n// {name: 'value',   value: '1',    start: 4, end: 5},\n// {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n// {name: 'value',   value: 'function(x,y){return {y:x};}', start: 10, end: 37}\n// ]\n \n// Sticky mode via flag y\nstr = '<1><<<2>>><3>4<5>';\nXRegExp.matchRecursive(str, '<', '>', 'gy');\n// -> ['1', '<<2>>', '3']\n```\n\n\n\n\n\n## Unicode matching (`\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`) & astral mode (`A` flag)\n\nXRegExp adds base support for Unicode matching:\n\n- Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n  `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n  braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n\n- Adds flag `A` (astral), which enables 21-bit Unicode support.\n\n- Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n \nUnicode Base relies on externally provided Unicode character data. Official addons are\navailable to provide data for Unicode categories, scripts, blocks, and properties via \n`XRegExp.addToken()` API.\n\n\n\n## XRegExp.addUnicodeData(data)\n\nAdds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n\n`data`\n{Array} Objects with named character ranges. Each object may have properties\n  `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n  optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n  `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n  the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n  provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n  `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n  high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n  `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n  sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n  escaped, apart from range-creating hyphens. The `astral` data can additionally use\n  character classes and alternation, and should use surrogate pairs to represent astral code\n  points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n  defined as the exact inverse of another token.\n\n```js\n// Basic use\nXRegExp.addUnicodeData([{\n  name: 'XDigit',\n  alias: 'Hexadecimal',\n  bmp: '0-9A-Fa-f'\n}]);\nXRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n```\n\n\n\n\n\n## Private / Unofficial / Unsupported APIs\n\n\n### XRegExp._registeredFlags()\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nReturns a reference to the internal registered flags object, where each flag is a hash key:\n\n```js\nvar flags = XRegExp._registeredFlags();\nassert(flags['u'], 'expected native Unicode support');\n```\n\n\n### function setNatives(on)\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nEnables or disables native method overrides.\n\n`on`\n: {Boolean} `true` to enable; `false` to disable.\n\nUsed internally by the `XRegExp.install()` and `XRegExp.uninstall()` APIs; `setNatives()` is itself not accessibly externally (private function).\n\n\n### XRegExp._hasNativeFlag(flag)\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nCheck if the regex flag is supported natively in your environment.\n\nReturns {Boolean}.\n\n> Developer Note:\n>\n> Can't check based on the presence of properties/getters since browsers might support such\n> properties even when they don't support the corresponding flag in regex construction (tested\n> in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n> throws an error)\n\n\n### XRegExp._dec(hex)\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nConverts hexadecimal to decimal.\n\n`hex`\n: {String}\n\nReturns {Number}\n\n\n\n### XRegExp._hex(dec)\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nConverts decimal to hexadecimal.\n\n`dec`\n: {Number|String}\n\nReturns {String}\n\n\n\n### XRegExp._pad4(str)\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nAdds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n\n`str`\n: {String}\n\nReturns {String}\n\n\n\n\n\n### XRegExp._getUnicodeProperty(name)\n\n> 'Unofficial/Unsupported API': interface may be subject to change between any XRegExp releases; used in tests and addons; suitable for advanced users of the library only.\n\nReturn a reference to the internal Unicode definition structure for the given Unicode Property\nif the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex constructs.\n\n`name`\n: {String} Name by which the Unicode Property may be recognized (case-insensitive),\n  e.g. `'N'` or `'Number'`.\n\n  The given name is matched against all registered Unicode Properties and Property Aliases.\n\n  Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.\n\nReturns {Object} reference to definition structure when the name matches a Unicode Property;\n`false` when the name does not match *any* Unicode Property or Property Alias.\n\n\n#### Notes\n\nFor more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n\nThis method is *not* part of the officially documented and published API and is meant 'for\nadvanced use only' where userland code wishes to re-use the (large) internal Unicode\nstructures set up by XRegExp as a single point of Unicode 'knowledge' in the application.\n\nSee some example usage of this functionality, used as a boolean check if the given name\nis legal and to obtain internal structural data:\n- `function prepareMacros(...)` in https://github.com/GerHobbelt/jison-lex/blob/master/regexp-lexer.js#L885\n- `function generateRegexesInitTableCode(...)` in https://github.com/GerHobbelt/jison-lex/blob/master/regexp-lexer.js#L1999\n\nNote that the second function in the example (`function generateRegexesInitTableCode(...)`)\nuses a approach without using this API to obtain a Unicode range spanning regex for use in environments\nwhich do not support XRegExp by simply expanding the XRegExp instance to a String through\nthe `map()` mapping action and subsequent `join()`.\n\n\n\n\n\n\n\n## Unicode Blocks, Categories, Properties and Scripts\n\nXRegExp adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.\n`\\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and\nunderscores are ignored.\n\nCurrently XRegExp supports the Unicode 8.0.0 block names listed below:\n\n- `InAegean_Numbers`\n- `InAhom`\n- `InAlchemical_Symbols`\n- `InAlphabetic_Presentation_Forms`\n- `InAnatolian_Hieroglyphs`\n- `InAncient_Greek_Musical_Notation`\n- `InAncient_Greek_Numbers`\n- `InAncient_Symbols`\n- `InArabic`\n- `InArabic_Extended_A`\n- `InArabic_Mathematical_Alphabetic_Symbols`\n- `InArabic_Presentation_Forms_A`\n- `InArabic_Presentation_Forms_B`\n- `InArabic_Supplement`\n- `InArmenian`\n- `InArrows`\n- `InAvestan`\n- `InBalinese`\n- `InBamum`\n- `InBamum_Supplement`\n- `InBasic_Latin`\n- `InBassa_Vah`\n- `InBatak`\n- `InBengali`\n- `InBlock_Elements`\n- `InBopomofo`\n- `InBopomofo_Extended`\n- `InBox_Drawing`\n- `InBrahmi`\n- `InBraille_Patterns`\n- `InBuginese`\n- `InBuhid`\n- `InByzantine_Musical_Symbols`\n- `InCarian`\n- `InCaucasian_Albanian`\n- `InChakma`\n- `InCham`\n- `InCherokee`\n- `InCherokee_Supplement`\n- `InCJK_Compatibility`\n- `InCJK_Compatibility_Forms`\n- `InCJK_Compatibility_Ideographs`\n- `InCJK_Compatibility_Ideographs_Supplement`\n- `InCJK_Radicals_Supplement`\n- `InCJK_Strokes`\n- `InCJK_Symbols_and_Punctuation`\n- `InCJK_Unified_Ideographs`\n- `InCJK_Unified_Ideographs_Extension_A`\n- `InCJK_Unified_Ideographs_Extension_B`\n- `InCJK_Unified_Ideographs_Extension_C`\n- `InCJK_Unified_Ideographs_Extension_D`\n- `InCJK_Unified_Ideographs_Extension_E`\n- `InCombining_Diacritical_Marks`\n- `InCombining_Diacritical_Marks_Extended`\n- `InCombining_Diacritical_Marks_for_Symbols`\n- `InCombining_Diacritical_Marks_Supplement`\n- `InCombining_Half_Marks`\n- `InCommon_Indic_Number_Forms`\n- `InControl_Pictures`\n- `InCoptic`\n- `InCoptic_Epact_Numbers`\n- `InCounting_Rod_Numerals`\n- `InCuneiform`\n- `InCuneiform_Numbers_and_Punctuation`\n- `InCurrency_Symbols`\n- `InCypriot_Syllabary`\n- `InCyrillic`\n- `InCyrillic_Extended_A`\n- `InCyrillic_Extended_B`\n- `InCyrillic_Supplement`\n- `InDeseret`\n- `InDevanagari`\n- `InDevanagari_Extended`\n- `InDingbats`\n- `InDomino_Tiles`\n- `InDuployan`\n- `InEarly_Dynastic_Cuneiform`\n- `InEgyptian_Hieroglyphs`\n- `InElbasan`\n- `InEmoticons`\n- `InEnclosed_Alphanumeric_Supplement`\n- `InEnclosed_Alphanumerics`\n- `InEnclosed_CJK_Letters_and_Months`\n- `InEnclosed_Ideographic_Supplement`\n- `InEthiopic`\n- `InEthiopic_Extended`\n- `InEthiopic_Extended_A`\n- `InEthiopic_Supplement`\n- `InGeneral_Punctuation`\n- `InGeometric_Shapes`\n- `InGeometric_Shapes_Extended`\n- `InGeorgian`\n- `InGeorgian_Supplement`\n- `InGlagolitic`\n- `InGothic`\n- `InGrantha`\n- `InGreek_and_Coptic`\n- `InGreek_Extended`\n- `InGujarati`\n- `InGurmukhi`\n- `InHalfwidth_and_Fullwidth_Forms`\n- `InHangul_Compatibility_Jamo`\n- `InHangul_Jamo`\n- `InHangul_Jamo_Extended_A`\n- `InHangul_Jamo_Extended_B`\n- `InHangul_Syllables`\n- `InHanunoo`\n- `InHatran`\n- `InHebrew`\n- `InHigh_Private_Use_Surrogates`\n- `InHigh_Surrogates`\n- `InHiragana`\n- `InIdeographic_Description_Characters`\n- `InImperial_Aramaic`\n- `InInscriptional_Pahlavi`\n- `InInscriptional_Parthian`\n- `InIPA_Extensions`\n- `InJavanese`\n- `InKaithi`\n- `InKana_Supplement`\n- `InKanbun`\n- `InKangxi_Radicals`\n- `InKannada`\n- `InKatakana`\n- `InKatakana_Phonetic_Extensions`\n- `InKayah_Li`\n- `InKharoshthi`\n- `InKhmer`\n- `InKhmer_Symbols`\n- `InKhojki`\n- `InKhudawadi`\n- `InLao`\n- `InLatin_1_Supplement`\n- `InLatin_Extended_A`\n- `InLatin_Extended_Additional`\n- `InLatin_Extended_B`\n- `InLatin_Extended_C`\n- `InLatin_Extended_D`\n- `InLatin_Extended_E`\n- `InLepcha`\n- `InLetterlike_Symbols`\n- `InLimbu`\n- `InLinear_A`\n- `InLinear_B_Ideograms`\n- `InLinear_B_Syllabary`\n- `InLisu`\n- `InLow_Surrogates`\n- `InLycian`\n- `InLydian`\n- `InMahajani`\n- `InMahjong_Tiles`\n- `InMalayalam`\n- `InMandaic`\n- `InManichaean`\n- `InMathematical_Alphanumeric_Symbols`\n- `InMathematical_Operators`\n- `InMeetei_Mayek`\n- `InMeetei_Mayek_Extensions`\n- `InMende_Kikakui`\n- `InMeroitic_Cursive`\n- `InMeroitic_Hieroglyphs`\n- `InMiao`\n- `InMiscellaneous_Mathematical_Symbols_A`\n- `InMiscellaneous_Mathematical_Symbols_B`\n- `InMiscellaneous_Symbols`\n- `InMiscellaneous_Symbols_and_Arrows`\n- `InMiscellaneous_Symbols_and_Pictographs`\n- `InMiscellaneous_Technical`\n- `InModi`\n- `InModifier_Tone_Letters`\n- `InMongolian`\n- `InMro`\n- `InMultani`\n- `InMusical_Symbols`\n- `InMyanmar`\n- `InMyanmar_Extended_A`\n- `InMyanmar_Extended_B`\n- `InNabataean`\n- `InNew_Tai_Lue`\n- `InNKo`\n- `InNumber_Forms`\n- `InOgham`\n- `InOl_Chiki`\n- `InOld_Hungarian`\n- `InOld_Italic`\n- `InOld_North_Arabian`\n- `InOld_Permic`\n- `InOld_Persian`\n- `InOld_South_Arabian`\n- `InOld_Turkic`\n- `InOptical_Character_Recognition`\n- `InOriya`\n- `InOrnamental_Dingbats`\n- `InOsmanya`\n- `InPahawh_Hmong`\n- `InPalmyrene`\n- `InPau_Cin_Hau`\n- `InPhags_pa`\n- `InPhaistos_Disc`\n- `InPhoenician`\n- `InPhonetic_Extensions`\n- `InPhonetic_Extensions_Supplement`\n- `InPlaying_Cards`\n- `InPrivate_Use_Area`\n- `InPsalter_Pahlavi`\n- `InRejang`\n- `InRumi_Numeral_Symbols`\n- `InRunic`\n- `InSamaritan`\n- `InSaurashtra`\n- `InSharada`\n- `InShavian`\n- `InShorthand_Format_Controls`\n- `InSiddham`\n- `InSinhala`\n- `InSinhala_Archaic_Numbers`\n- `InSmall_Form_Variants`\n- `InSora_Sompeng`\n- `InSpacing_Modifier_Letters`\n- `InSpecials`\n- `InSundanese`\n- `InSundanese_Supplement`\n- `InSuperscripts_and_Subscripts`\n- `InSupplemental_Arrows_A`\n- `InSupplemental_Arrows_B`\n- `InSupplemental_Arrows_C`\n- `InSupplemental_Mathematical_Operators`\n- `InSupplemental_Punctuation`\n- `InSupplemental_Symbols_and_Pictographs`\n- `InSupplementary_Private_Use_Area_A`\n- `InSupplementary_Private_Use_Area_B`\n- `InSutton_SignWriting`\n- `InSyloti_Nagri`\n- `InSyriac`\n- `InTagalog`\n- `InTagbanwa`\n- `InTags`\n- `InTai_Le`\n- `InTai_Tham`\n- `InTai_Viet`\n- `InTai_Xuan_Jing_Symbols`\n- `InTakri`\n- `InTamil`\n- `InTelugu`\n- `InThaana`\n- `InThai`\n- `InTibetan`\n- `InTifinagh`\n- `InTirhuta`\n- `InTransport_and_Map_Symbols`\n- `InUgaritic`\n- `InUnified_Canadian_Aboriginal_Syllabics`\n- `InUnified_Canadian_Aboriginal_Syllabics_Extended`\n- `InVai`\n- `InVariation_Selectors`\n- `InVariation_Selectors_Supplement`\n- `InVedic_Extensions`\n- `InVertical_Forms`\n- `InWarang_Citi`\n- `InYi_Radicals`\n- `InYi_Syllables`\n- `InYijing_Hexagram_Symbols`\n\nXRegExp adds support for Unicode's general categories. E.g., `\\p{Lu}` or `\\p{Uppercase Letter}`. See\ncategory descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token\nnames are case insensitive, and any spaces, hyphens, and underscores are ignored.\n\nCurrently XRegExp supports the Unicode 8.0.0 category names listed below:\n\n- `Close_Punctuation`\n- `Connector_Punctuation`\n- `Control`\n- `Currency_Symbol`\n- `Dash_Punctuation`\n- `Decimal_Number`\n- `Enclosing_Mark`\n- `Final_Punctuation`\n- `Format`\n- `Initial_Punctuation`\n- `Letter`\n- `Letter_Number`\n- `Line_Separator`\n- `Lowercase_Letter`\n- `Mark`\n- `Math_Symbol`\n- `Modifier_Letter`\n- `Modifier_Symbol`\n- `Nonspacing_Mark`\n- `Number`\n- `Open_Punctuation`\n- `Other`\n- `Other_Letter`\n- `Other_Number`\n- `Other_Punctuation`\n- `Other_Symbol`\n- `Paragraph_Separator`\n- `Private_Use`\n- `Punctuation`\n- `Separator`\n- `Space_Separator`\n- `Spacing_Mark`\n- `Surrogate`\n- `Symbol`\n- `Titlecase_Letter`\n- `Unassigned`\n- `Uppercase_Letter`\n- `C`\n- `Cc`\n- `Cf`\n- `Cn`\n- `Co`\n- `Cs`\n- `L`\n- `Ll`\n- `Lm`\n- `Lo`\n- `Lt`\n- `Lu`\n- `M`\n- `Mc`\n- `Me`\n- `Mn`\n- `N`\n- `Nd`\n- `Nl`\n- `No`\n- `P`\n- `Pc`\n- `Pd`\n- `Pe`\n- `Pf`\n- `Pi`\n- `Po`\n- `Ps`\n- `S`\n- `Sc`\n- `Sk`\n- `Sm`\n- `So`\n- `Z`\n- `Zl`\n- `Zp`\n- `Zs`\n\nXRegExp adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See\n<http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from\nUAX #44 <http://unicode.org/reports/tr44/>:\n\n- `Alphabetic`\n\n  Characters with the Alphabetic property. Generated from: `Lowercase + Uppercase + Lt + Lm +\n  Lo + Nl + Other_Alphabetic`.\n\n- `Default_Ignorable_Code_Point`\n\n  For programmatic determination of default ignorable code points. New characters that should\n  be ignored in rendering (unless explicitly supported) will be assigned in these ranges,\n  permitting programs to correctly handle the default rendering of such characters when not\n  otherwise supported.\n \n- `Lowercase`\n\n  Characters with the Lowercase property. Generated from: `Ll + Other_Lowercase`.\n \n- `Noncharacter_Code_Point`\n\n  Code points permanently reserved for internal use.\n\n- `Uppercase`\n\n  Characters with the Uppercase property. Generated from: `Lu + Other_Uppercase`.\n\n- `White_Space`\n\n  Spaces, separator characters and other control characters which should be treated by\n  programming languages as \"white space\" for the purpose of parsing elements.\n \nThe properties `ASCII`, `Any`, and `Assigned` are also included but are not defined in UAX #44. \nUTS #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are\nincluded in XRegExp's Unicode Categories and Unicode Scripts addons.\n \nToken names are case insensitive, and any spaces, hyphens, and underscores are ignored.\n\nCurrently XRegExp supports the Unicode 8.0.0 property names listed below:\n\n- `Alphabetic`\n- `Any`\n- `ASCII`\n- `Default_Ignorable_Code_Point`\n- `Lowercase`\n- `Noncharacter_Code_Point`\n- `Uppercase`\n- `White_Space`\n\nNext to these, this property name is available as well:\n\n- `Assigned`\n\n  This is defined as the inverse of Unicode category `Cn` (`Unassigned`)\n\n\nXRegExp adds support for all Unicode scripts. E.g., `\\p{Latin}`. Token names are case insensitive,\nand any spaces, hyphens, and underscores are ignored.\n\nCurrently XRegExp supports the Unicode 8.0.0 script names listed below:\n\n- `Ahom`\n- `Anatolian_Hieroglyphs`\n- `Arabic`\n- `Armenian`\n- `Avestan`\n- `Balinese`\n- `Bamum`\n- `Bassa_Vah`\n- `Batak`\n- `Bengali`\n- `Bopomofo`\n- `Brahmi`\n- `Braille`\n- `Buginese`\n- `Buhid`\n- `Canadian_Aboriginal`\n- `Carian`\n- `Caucasian_Albanian`\n- `Chakma`\n- `Cham`\n- `Cherokee`\n- `Common`\n- `Coptic`\n- `Cuneiform`\n- `Cypriot`\n- `Cyrillic`\n- `Deseret`\n- `Devanagari`\n- `Duployan`\n- `Egyptian_Hieroglyphs`\n- `Elbasan`\n- `Ethiopic`\n- `Georgian`\n- `Glagolitic`\n- `Gothic`\n- `Grantha`\n- `Greek`\n- `Gujarati`\n- `Gurmukhi`\n- `Han`\n- `Hangul`\n- `Hanunoo`\n- `Hatran`\n- `Hebrew`\n- `Hiragana`\n- `Imperial_Aramaic`\n- `Inherited`\n- `Inscriptional_Pahlavi`\n- `Inscriptional_Parthian`\n- `Javanese`\n- `Kaithi`\n- `Kannada`\n- `Katakana`\n- `Kayah_Li`\n- `Kharoshthi`\n- `Khmer`\n- `Khojki`\n- `Khudawadi`\n- `Lao`\n- `Latin`\n- `Lepcha`\n- `Limbu`\n- `Linear_A`\n- `Linear_B`\n- `Lisu`\n- `Lycian`\n- `Lydian`\n- `Mahajani`\n- `Malayalam`\n- `Mandaic`\n- `Manichaean`\n- `Meetei_Mayek`\n- `Mende_Kikakui`\n- `Meroitic_Cursive`\n- `Meroitic_Hieroglyphs`\n- `Miao`\n- `Modi`\n- `Mongolian`\n- `Mro`\n- `Multani`\n- `Myanmar`\n- `Nabataean`\n- `New_Tai_Lue`\n- `Nko`\n- `Ogham`\n- `Ol_Chiki`\n- `Old_Hungarian`\n- `Old_Italic`\n- `Old_North_Arabian`\n- `Old_Permic`\n- `Old_Persian`\n- `Old_South_Arabian`\n- `Old_Turkic`\n- `Oriya`\n- `Osmanya`\n- `Pahawh_Hmong`\n- `Palmyrene`\n- `Pau_Cin_Hau`\n- `Phags_Pa`\n- `Phoenician`\n- `Psalter_Pahlavi`\n- `Rejang`\n- `Runic`\n- `Samaritan`\n- `Saurashtra`\n- `Sharada`\n- `Shavian`\n- `Siddham`\n- `SignWriting`\n- `Sinhala`\n- `Sora_Sompeng`\n- `Sundanese`\n- `Syloti_Nagri`\n- `Syriac`\n- `Tagalog`\n- `Tagbanwa`\n- `Tai_Le`\n- `Tai_Tham`\n- `Tai_Viet`\n- `Takri`\n- `Tamil`\n- `Telugu`\n- `Thaana`\n- `Thai`\n- `Tibetan`\n- `Tifinagh`\n- `Tirhuta`\n- `Ugaritic`\n- `Vai`\n- `Warang_Citi`\n- `Yi`\n\nAdditional token names may be defined via the `XRegExp.addUnicodeData(unicodeData)` API.\n\n \n\n\n\n## Info for XRegExp Developers\n\nTo regenerate the `xregexp-all.js` source file you can simply run the command\n\n```bash\nnpm run build\n```\n\nin the base directory of the repository.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/GerHobbelt/xregexp/issues"
  },
  "_id": "xregexp@3.1.2-14",
  "_shasum": "1b67d038fffe95a4886ebe3bd87c7aea3654ac52",
  "_from": "gerhobbelt/xregexp#master",
  "_resolved": "git://github.com/gerhobbelt/xregexp.git#7cb56f9a90a802ae34087ac5a257a992904a602c"
}

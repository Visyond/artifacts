/* parser generated by jison 0.4.18-171 */
/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack, ...),
 *               where `...` denotes the (optional) additional arguments the user passed to
 *               `parser.parse(str, ...)` and specified by way of `%parse-param ...` in the grammar file
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                             executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj);
 *
 *    originalParseError: function(str, hash),
 *               The basic parseError handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are passed verbatim to the grammar rules' action code.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The parseError function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy [, optional parse() args])
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval [, optional parse() args]) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *  
 *  yy: {
 *      pre_parse:  function(yy [, optional parse() args])
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval [, optional parse() args]) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another. 
 *                 When it does not return any value, the parser will return the original
 *                 `retval`. 
 *                 This function is invoked immediately before `Parser.post_parse()`.
 *
 *      parseError: function(str, hash)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */
var formulaVisyondActive = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) { // V8
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';




// helper: reconstruct the productions[] table
function bp(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
        rv.push([
            p[i],
            r[i]
        ]);
    }
    return rv;
}



// helper: reconstruct the defaultActions[] table
function bda(s) {
    var rv = {};
    var d = s.idx;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var j = d[i];
        rv[j] = g[i];
    }
    return rv;
}



// helper: reconstruct the 'goto' table
function bt(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var n = d[i];
        var q = {};
        for (var j = 0; j < n; j++) {
            var z = y.shift();
            switch (t.shift()) {
            case 2:
                q[z] = [
                    m.shift(),
                    g.shift()
                ];
                break;

            case 0:
                q[z] = a.shift();
                break;

            default:
                // type === 1: accept
                q[z] = [
                    3
                ];
            }
        }
        rv.push(q);
    }
    return rv;
}



// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
        this.push(c);
        c += a;
    }
}

// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
        this.push(this[i]);
    }
}

// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
        var e = a[i];
        // Is this entry a helper function?
        if (typeof e === 'function') {
            i++;
            e.apply(rv, a[i]);
        } else {
            rv.push(e);
        }
    }
    return rv;
}


var parser = {
trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "!": 12,
  "$": 21,
  "$accept": 0,
  "$end": 1,
  "(": 14,
  ")": 15,
  "*": 8,
  "+": 6,
  ",": 20,
  "-": 7,
  ".": 13,
  "/": 9,
  ":": 22,
  "<": 5,
  "=": 3,
  ">": 4,
  "?": 11,
  "@": 23,
  "ALMOST_EQUAL": 35,
  "ARRAY_CONCATENATION_OPERATOR": 50,
  "BOOLEAN_AND_OPERATOR": 31,
  "BOOLEAN_OR_OPERATOR": 32,
  "CELLREF": 49,
  "CELLREF_PARSE_MODE": 24,
  "CONSTANT": 56,
  "CUBE_OPERATOR": 43,
  "CURRENCY": 53,
  "DEGREES_OPERATOR": 52,
  "EOF": 1,
  "EXCEL_FORCED_STRING": 30,
  "FALSE": 58,
  "FUNCTION": 44,
  "GREATER_OR_EQUAL": 37,
  "INTEGER_NUMBER": 55,
  "IS_EQUAL": 39,
  "IS_IDENTICAL": 36,
  "Ill_be_boogered": 89,
  "JSON_FIELD_NAME": 45,
  "JSON_FILTER_FUNCTION": 46,
  "LESS_OR_EQUAL": 38,
  "MODULO_OPERATOR": 27,
  "NOT_EQUAL": 33,
  "NOT_IDENTICAL": 34,
  "NUMBER": 54,
  "PATH": 48,
  "PERCENTAGE_OPERATOR": 28,
  "PROMILAGE_OPERATOR": 29,
  "RANGEREF": 51,
  "RANGEREF_PARSE_MODE": 25,
  "SQRT_OPERATOR": 41,
  "SQUARE_OPERATOR": 42,
  "STRING": 59,
  "STRING_CONCATENATION_OPERATOR": 40,
  "TRUE": 57,
  "URI": 47,
  "VALUE_PARSE_MODE": 26,
  "[": 16,
  "]": 17,
  "^": 10,
  "accept_direct_boolean_value": 64,
  "accept_direct_numeric_value": 62,
  "accept_direct_string_value": 63,
  "ambiguous_any_range_reference": 78,
  "any_range_reference": 77,
  "arglist": 80,
  "boolean": 87,
  "boolean_expression": 66,
  "cell_reference": 72,
  "constant": 86,
  "data_source": 68,
  "do_the_work": 61,
  "error": 2,
  "fundamental_cell_reference": 76,
  "json_filter_expression": 70,
  "math_expression": 65,
  "multivalued_data_source": 69,
  "number": 85,
  "one_argument": 79,
  "one_json_filter_level": 71,
  "optional_remote_address_marker": 74,
  "percentage": 81,
  "price": 83,
  "radians": 82,
  "remote_address": 73,
  "remote_address_marker": 75,
  "start_parsing": 60,
  "string": 88,
  "unary_expression_rvalue": 67,
  "value": 84,
  "{": 18,
  "}": 19
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "=",
  4: ">",
  5: "<",
  6: "+",
  7: "-",
  8: "*",
  9: "/",
  10: "^",
  11: "?",
  12: "!",
  13: ".",
  14: "(",
  15: ")",
  16: "[",
  17: "]",
  18: "{",
  19: "}",
  20: ",",
  21: "$",
  22: ":",
  23: "@",
  24: "CELLREF_PARSE_MODE",
  25: "RANGEREF_PARSE_MODE",
  26: "VALUE_PARSE_MODE",
  27: "MODULO_OPERATOR",
  28: "PERCENTAGE_OPERATOR",
  29: "PROMILAGE_OPERATOR",
  30: "EXCEL_FORCED_STRING",
  31: "BOOLEAN_AND_OPERATOR",
  32: "BOOLEAN_OR_OPERATOR",
  33: "NOT_EQUAL",
  34: "NOT_IDENTICAL",
  35: "ALMOST_EQUAL",
  36: "IS_IDENTICAL",
  37: "GREATER_OR_EQUAL",
  38: "LESS_OR_EQUAL",
  39: "IS_EQUAL",
  40: "STRING_CONCATENATION_OPERATOR",
  41: "SQRT_OPERATOR",
  42: "SQUARE_OPERATOR",
  43: "CUBE_OPERATOR",
  44: "FUNCTION",
  45: "JSON_FIELD_NAME",
  46: "JSON_FILTER_FUNCTION",
  47: "URI",
  48: "PATH",
  49: "CELLREF",
  50: "ARRAY_CONCATENATION_OPERATOR",
  51: "RANGEREF",
  52: "DEGREES_OPERATOR",
  53: "CURRENCY",
  54: "NUMBER",
  55: "INTEGER_NUMBER",
  56: "CONSTANT",
  57: "TRUE",
  58: "FALSE",
  59: "STRING"
},
TERROR: 2,
EOF: 1,

// internals: defined here so the object *structure* doesn't get modified by parse() et al,
// thus helping JIT compilers like Chrome V8.
originalQuoteName: null,
originalParseError: null,
cleanupAfterParse: null,
constructParseErrorInfo: null,

__reentrant_call_depth: 0,      // INTERNAL USE ONLY
__error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

// APIs which will be set up depending on user action code analysis:
//yyErrOk: 0,
//yyClearIn: 0,

// Helper APIs
// -----------

// Helper function which can be overridden by user code later on: put suitable quotes around
// literal IDs in a description string.
quoteName: function parser_quoteName(id_str) {
    return '"' + id_str + '"';
},

// Return a more-or-less human-readable description of the given symbol, when available,
// or the symbol itself, serving as its own 'description' for lack of something better to serve up.
//
// Return NULL when the symbol is unknown to the parser.
describeSymbol: function parser_describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    }
    else if (symbol === this.EOF) {
        return 'end of input';
    }
    else if (this.terminals_[symbol]) {
        return this.quoteName(this.terminals_[symbol]);
    }
    // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
    //
    // An example of this may be where a rule's action code contains a call like this:
    //
    //      parser.describeSymbol(#$)
    //
    // to obtain a human-readable description or name of the current grammar rule. This comes handy in
    // error handling action code blocks, for example.
    var s = this.symbols_;
    for (var key in s) {
        if (s[key] === symbol) {
            return key;
        }
    }
    return null;
},

// Produce a (more or less) human-readable list of expected tokens at the point of failure.
//
// The produced list may contain token or token set descriptions instead of the tokens
// themselves to help turning this output into something that easier to read by humans
// unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
// expected terminals and nonterminals is produced.
//
// The returned list (array) will not contain any duplicate entries.
collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
    var TERROR = this.TERROR;
    var tokenset = [];
    var check = {};
    // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
    // If so, use that one instead of the less palatable token set.
    if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
        return [
            this.state_descriptions_[state]
        ];
    }
    for (var p in this.table[state]) {
        p = +p;
        if (p !== TERROR) {
            var d = do_not_describe ? p : this.describeSymbol(p);
            if (d && !check[d]) {
                tokenset.push(d);
                check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
            }
        }
    }
    return tokenset;
},
productions_: bp({
  pop: u([
  60,
  60,
  s,
  [61, 13],
  s,
  [62, 8],
  63,
  s,
  [63, 4, 1],
  s,
  [66, 34],
  67,
  67,
  68,
  68,
  s,
  [69, 3],
  70,
  70,
  s,
  [71, 4],
  72,
  72,
  s,
  [73, 7],
  74,
  s,
  [74, 4, 1],
  s,
  [77, 3],
  s,
  [78, 4],
  s,
  [79, 3],
  80,
  80,
  81,
  81,
  82,
  83,
  83,
  s,
  [84, 3],
  85,
  85,
  s,
  [86, 3],
  87,
  87,
  88,
  89
]),
  rule: u([
  s,
  [2, 3],
  s,
  [1, 4],
  s,
  [2, 8],
  s,
  [1, 5],
  c,
  [8, 7],
  s,
  [3, 19],
  c,
  [38, 12],
  s,
  [1, 7],
  3,
  4,
  3,
  c,
  [5, 3],
  1,
  4,
  4,
  c,
  [69, 6],
  s,
  [4, 4],
  0,
  c,
  [61, 5],
  c,
  [3, 4],
  s,
  [1, 4],
  0,
  1,
  c,
  [55, 12],
  c,
  [6, 5],
  25
])
}),
performAction: function parser__PerformAction(yytext, yyloc, yystate /* action[1] */, $0, yyvstack, yylstack, cfg, one, two) {
/* this == yyval */
var yy = this.yy;
/*
     * This chunk is included at the top of the actionHandler itself.
     */
    var rv, range;

    //console.log("parser exec rule: ", yystate, this, yy.lexer.options, arguments);

    var patch_tokenstream = yy.lexer.options.patch_tokenstream;
    assert(patch_tokenstream);
    var patch_resulttype = yy.lexer.options.patch_resulttype;
    assert(patch_resulttype);
switch (yystate) {
case 1:
    /*! Production::    start_parsing : do_the_work EOF */
    // Note: we MAY return values such as 'undefined' or 'null', which would otherwise be picked up
    // by the JISON parser rig itself and be converted to a *boolean* `TRUE` value (action code 3 inside
    // the jison LALR parser stack engine).
    //
    // To thwart this 'default return value' behaviour of JISON we always wrap the actual calculated
    // value in an object, where our wrapper code will then extract it once we get outside the jison
    // engine/driver.
    return {
        value: yyvstack[$0 - 1]
    };
    break;

case 2:
    /*! Production::    start_parsing : do_the_work error */
    rv = yy.parser.parseError("We do not expect anything following the valid expression.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    return {
        value: NaN
    };
    break;

case 3:
    /*! Production::    do_the_work : "=" math_expression */
    patch_resulttype(FT_FORMULA);
    this.$ = yyvstack[$0];
    
    // check this block in combination with outerErrorCheck in __support_functions.js
    if (this.$ instanceof ErrorSignal) {
        // do not change anything: $$ stays ErrorSignal
    } else if (this.$.__collection) {
        // if this is a range
        this.$ = Visyond.Functions.ERROR.na;
    } else if(typeof this.$ === 'string' || typeof this.$ ==='boolean') {
        // do not change anything
        // if ($$ === '') $$ = 0; // if final result is empty string we coerc to zero;
    } else if (this.$ instanceof CellRefRepresentation) {
        this.$ = this.$.valueOf();
    } else {
        if (isNaN(this.$) || !isFinite(this.$)) this.$ = Visyond.Functions.ERROR.na;
    }
    break;

case 4:
    /*! Production::    do_the_work : accept_direct_numeric_value */
    rv = yyvstack[$0];
    // A bit of a hack: when you enter a 'direct value EXPRESSION', e.g. `E1`, where the
    // referenced cell doesn't exist and therefor has no value (`undefined`), we *still*
    // want the resulting value right here to be one of string/boolean/number/date/whatever,
    // but we certainly DO NOT want it to produce the value `undefined`.
    //
    // Hence we coerce the result (as little as possible) before feeding it back to the caller.
    this.$ = coerceValueToNumeric(rv);
    break;

case 5:
    /*! Production::    do_the_work : accept_direct_string_value */
case 6:
    /*! Production::    do_the_work : accept_direct_boolean_value */
    rv = yyvstack[$0];
    break;

case 7:
    /*! Production::    do_the_work : error */
case 62:
    /*! Production::    boolean_expression : error */
    rv = yy.parser.parseError("Expected a value or formula expression.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 8:
    /*! Production::    do_the_work : CELLREF_PARSE_MODE cell_reference */
case 65:
    /*! Production::    data_source : multivalued_data_source */
case 69:
    /*! Production::    multivalued_data_source : cell_reference */
case 70:
    /*! Production::    json_filter_expression : one_json_filter_level */
case 72:
    /*! Production::    one_json_filter_level : JSON_FIELD_NAME */
case 100:
    /*! Production::    arglist : one_argument */
    this.$ = yyvstack[$0];
    break;

case 9:
    /*! Production::    do_the_work : CELLREF_PARSE_MODE error */
    rv = yy.parser.parseError("Expected a single cell reference.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 10:
    /*! Production::    do_the_work : RANGEREF_PARSE_MODE any_range_reference */
    /*
     * Check whether the AST is really a RANGEREF and not a CELLREF as the `any_range_reference` rule
     * can deliver a single CELLREF node due to LALR(1) grammar restrictions keeping us from
     * completely separating CELLREF and RANGEREF parsing.
     *
     * Anything apart from a RANGEREF should trigger an error report.
     */
    if (yyvstack[$0] instanceof BasicRangeRefRepresentation) {
        this.$ = yyvstack[$0];
    } else {
        rv = yy.parser.parseError("Expected a cell range reference.", {
            text: yyvstack[$0],
            token: yyvstack[$0],
            line: yylstack[$0],
            loc: yylstack[$0],
            outer_loc: this._$,
            expected: [],
            recoverable: false
        });
        assert(rv === null);
        this.$ = NaN;
    }
    break;

case 11:
    /*! Production::    do_the_work : RANGEREF_PARSE_MODE error */
    rv = yy.parser.parseError("Expected a cell range reference.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 12:
    /*! Production::    do_the_work : VALUE_PARSE_MODE accept_direct_numeric_value */
case 13:
    /*! Production::    do_the_work : VALUE_PARSE_MODE accept_direct_string_value */
    /*
     * TODO:
     *
     * Check whether the AST so far is 'basic' and suitable for 'folding' to a single value.
     *
     * Anything else should trigger an error report.
     */
    this.$ = yyvstack[$0];
    break;

case 14:
    /*! Production::    do_the_work : VALUE_PARSE_MODE accept_direct_boolean_value */
    /*
     * TODO:
     *
     * Check whether the AST so far is 'basic' and suitable for 'folding' to a single value.
     *
     * Anything else should trigger an error report.
     */
    this.$ = $accept_direct_string_value;
    break;

case 15:
    /*! Production::    do_the_work : VALUE_PARSE_MODE error */
    rv = yy.parser.parseError("Expected a value or value expression.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 21:
    /*! Production::    accept_direct_numeric_value : MODULO_OPERATOR value */
    // Excel supports percentage direct value entry as `%5` next to `5%`
    patch_tokenstream("PERCENTAGE_OPERATOR", null, 1, yylstack[$0 - 1]);
    this.$ = yyvstack[$0] / 100;
    break;

case 22:
    /*! Production::    accept_direct_numeric_value : PERCENTAGE_OPERATOR value */
    // Excel supports percentage direct value entry as `%5` next to `5%`
    this.$ = yyvstack[$0] / 100;
    break;

case 23:
    /*! Production::    accept_direct_numeric_value : PROMILAGE_OPERATOR value */
    this.$ = yyvstack[$0] / 1000;
    break;

case 25:
    /*! Production::    accept_direct_string_value : EXCEL_FORCED_STRING */
    patch_resulttype(FT_STRING);
    
    /* see the rule comment: this is to support Excel-compatible value data entry */
    assert(typeof yyvstack[$0] === "string");
    this.$ = yyvstack[$0];
    break;

case 28:
    /*! Production::    boolean_expression : boolean_expression BOOLEAN_AND_OPERATOR boolean_expression */
    // Excel: `=AND("T",1)` gives `#VALUE!`; we do not emulate that behaviour here!
    this.$ = !!(yyvstack[$0 - 2] && yyvstack[$0]);
    break;

case 29:
    /*! Production::    boolean_expression : boolean_expression BOOLEAN_OR_OPERATOR boolean_expression */
    // Excel: `=OR("T",1)` gives `#VALUE!`; we do not emulate that behaviour here!
    this.$ = !!(yyvstack[$0 - 2] || yyvstack[$0]);
    break;

case 30:
    /*! Production::    boolean_expression : boolean_expression NOT_EQUAL boolean_expression */
case 31:
    /*! Production::    boolean_expression : boolean_expression NOT_IDENTICAL boolean_expression */
    // WARNING: see the Excel note below at IS_EQUAL: we don't really have a type-agnostic compare available!
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = (yyvstack[$0 - 2] !== yyvstack[$0]);
    break;

case 32:
    /*! Production::    boolean_expression : boolean_expression ALMOST_EQUAL boolean_expression */
    var f = coerceValueToNumeric(yyvstack[$0 - 2]);
    var l = coerceValueToNumeric(yyvstack[$0]);
    if (!isNaN(f) && !isNaN(l)) {
        // TODO: constant values: move this outside so we don't need to calculate this every time!
        var ε = 1e-9;
        var ACCEPTED_NUMERIC_ACCURACY_LOG = Math.log(1 + ε);
    
        // NEARNESS is a *relative* thing: it's about accuracy. Here we hardcode an 'accepted accuracy' of 0.001ppm.
        // Since we use logarithms for this, we must ensure that both values being compared are non-zero *positive*
        // numbers, hence we offset them by the minimum of the two, plus 1.0:
        var lowest = Math.min(f, l);
        f += 1 + lowest;
        l += 1 + lowest;
        if (isFinite(f) && isFinite(l)) {
            var df = Math.log(f);
            var dl = Math.log(l);
            assert(isFinite(f));
            assert(isFinite(l));
            this.$ = (Math.abs(df - dl) <= ACCEPTED_NUMERIC_ACCURACY_LOG); /* ε */
        } else {
            // arguments may be nearly-out-of-range numeric values: in this case we cop out and turn this into
            // an identity check; if only one of them 'INF-ed out', we got a winner too.
            this.$ = (yyvstack[$0 - 2] === yyvstack[$0]);
        }
    } else {
        // arguments may be a non-numeric type: here we perform a type-agnostic comparison then.
        // Also make sure that NaN compares to NaN as TRUE (JavaScript gives FALSE for that particular comparison)
        this.$ = (yyvstack[$0 - 2] == yyvstack[$0]) || (isNaN(yyvstack[$0 - 2]) && isNaN(yyvstack[$0]));
    }
    break;

case 33:
    /*! Production::    boolean_expression : boolean_expression IS_IDENTICAL boolean_expression */
    // WARNING: see the Excel note below at IS_EQUAL: we don't really have a type-agnostic compare available!
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = (yyvstack[$0 - 2] === yyvstack[$0]);
    break;

case 34:
    /*! Production::    boolean_expression : boolean_expression GREATER_OR_EQUAL boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
    //
    // Excel treats TRUE and FALSE as being *outside* the numeric range.
    // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
    this.$ = (yyvstack[$0 - 2] >= yyvstack[$0]);
    break;

case 35:
    /*! Production::    boolean_expression : boolean_expression LESS_OR_EQUAL boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
    //
    // Excel treats TRUE and FALSE as being *outside* the numeric range.
    // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
    this.$ = (yyvstack[$0 - 2] <= yyvstack[$0]);
    break;

case 36:
    /*! Production::    boolean_expression : boolean_expression ">" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
    //
    // Excel treats TRUE and FALSE as being *outside* the numeric range.
    // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
    this.$ = (yyvstack[$0 - 2] > yyvstack[$0]);
    break;

case 37:
    /*! Production::    boolean_expression : boolean_expression "<" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
    //
    // Excel treats TRUE and FALSE as being *outside* the numeric range.
    // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
    this.$ = (yyvstack[$0 - 2] < yyvstack[$0]);
    break;

case 38:
    /*! Production::    boolean_expression : boolean_expression "=" boolean_expression */
    // Excel says `="1"=1` is FALSE so doesn't perform auto-type-coercion while JavaScript does.
    // Hence we have to use `===` instead of `==` here:
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = (yyvstack[$0 - 2] === yyvstack[$0]);
    break;

case 39:
    /*! Production::    boolean_expression : boolean_expression IS_EQUAL boolean_expression */
    /*
     * This is just another notation for `=`, but we don't allow `==`, etc. as start markers
     * of a formula, so we end up having to 'is equal' opcode tokens, alas.
     */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = (yyvstack[$0 - 2] === yyvstack[$0]);
    break;

case 40:
    /*! Production::    boolean_expression : boolean_expression STRING_CONCATENATION_OPERATOR boolean_expression */
    yyvstack[$0 - 2] = coerceValueToString(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToString(yyvstack[$0]);
    this.$ = '' + yyvstack[$0 - 2] + yyvstack[$0];
    break;

case 41:
    /*! Production::    boolean_expression : boolean_expression "+" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    
    // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
    //
    // Excel treats TRUE and FALSE as being *outside* the numeric range.
    // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
    this.$ = (yyvstack[$0 - 2] + yyvstack[$0]);
    break;

case 42:
    /*! Production::    boolean_expression : boolean_expression "-" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
    //
    // Excel treats TRUE and FALSE as being *outside* the numeric range.
    // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
    this.$ = (yyvstack[$0 - 2] - yyvstack[$0]);
    break;

case 43:
    /*! Production::    boolean_expression : boolean_expression "*" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    // Excel: `=TRUE*1` --> `1`: for multiplication, TRUE and FALSE are treated as numeric 1 and 0, respectively.
    // Of course, we *do* support that behaviour!
    this.$ = (yyvstack[$0 - 2] * yyvstack[$0]);
    break;

case 44:
    /*! Production::    boolean_expression : boolean_expression "/" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = (yyvstack[$0 - 2] / yyvstack[$0]);
    // TODO: detect division by zero for two non-error inputs and then report #DIV/0
    break;

case 45:
    /*! Production::    boolean_expression : boolean_expression MODULO_OPERATOR boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = (yyvstack[$0 - 2] % yyvstack[$0]);
    break;

case 46:
    /*! Production::    boolean_expression : boolean_expression "^" boolean_expression */
    yyvstack[$0 - 2] = coerceValueToNumeric(yyvstack[$0 - 2]);
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = Math.pow(yyvstack[$0 - 2], yyvstack[$0]);
    break;

case 47:
    /*! Production::    boolean_expression : SQRT_OPERATOR boolean_expression */
    yyvstack[$0] = coerceValueToNumeric(yyvstack[$0]);
    this.$ = Math.sqrt(yyvstack[$0]);
    break;

case 48:
    /*! Production::    boolean_expression : boolean_expression SQUARE_OPERATOR */
    yyvstack[$0 - 1] = coerceValueToNumeric(yyvstack[$0 - 1]);
    this.$ = Math.pow(yyvstack[$0 - 1], 2);
    break;

case 49:
    /*! Production::    boolean_expression : boolean_expression CUBE_OPERATOR */
    yyvstack[$0 - 1] = coerceValueToNumeric(yyvstack[$0 - 1]);
    this.$ = Math.pow(yyvstack[$0 - 1], 3);
    break;

case 50:
    /*! Production::    boolean_expression : boolean_expression "?" */
    rv = yy.parser.parseError("TODO: provide inline/online help for this expression.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 51:
    /*! Production::    boolean_expression : "-" unary_expression_rvalue */
    this.$ = -coerceValueToNumeric(yyvstack[$0]);
    break;

case 52:
    /*! Production::    boolean_expression : "+" unary_expression_rvalue */
    this.$ = +coerceValueToNumeric(yyvstack[$0]);
    break;

case 53:
    /*! Production::    boolean_expression : "!" unary_expression_rvalue */
    if (!isNaN(yyvstack[$0])) {
        this.$ = !(yyvstack[$0]);   // No need to coerce the operand to numeric value before we apply boolean NOT
    } else {
        // propagate errors (NaN)
        this.$ = yyvstack[$0];
    }
    break;

case 64:
    /*! Production::    unary_expression_rvalue : error */
    rv = yy.parser.parseError("Expected a numeric value or bracketed formula expression.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 66:
    /*! Production::    data_source : multivalued_data_source "." json_filter_expression */
case 71:
    /*! Production::    json_filter_expression : one_json_filter_level "." json_filter_expression */
    rv = yy.parser.parseError("Dotted references into cell values are currently not support yet.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 67:
    /*! Production::    multivalued_data_source : FUNCTION "(" arglist ")" */
    /*
     * get the function name and attributes from the token argument:
     */
    var f_tok_locinfo = yylstack[$0 - 3];
    var f_tok_spec = yyvstack[$0 - 3];
    var a = yyvstack[$0 - 1];
    var chk;
    
    var precedentsFromFunction;
    
    //console.log("exec function: ", f_tok_locinfo, f_tok_spec, a);
    assert(vUserPreferences.quality >= VQ_PRODUCTION_READY ? f_tok_spec.opcode ? (f_tok_spec.opcode.implementation || f_tok_spec.opcode.value !== undefined) : false /* only entries with good implementation are allowed */ : true);
    
    if (f_tok_spec.opcode && f_tok_spec.opcode.implementation) {
        // TODO: call generic validation function which picks up .opcode.parameters_set_definition[]
        // WARNING: that def array is not the bees' knees as it is flaky concerning functions
        // which accept arbitrary number and/or type of arguments: e.g. SUM, MAX, MIN: it TRIES to
        // encode that knowledge in the array, but you WILL hit snags as the idea has been coded but
        // never tested as is: THIS is testing time... :-(
    
        chk = yy.parser.passingArgumentSetValidation(f_tok_spec.opcode, a);
        if (chk) {
            //console.log("Function " + f_tok_spec.text + ": ", chk);
    
            // Implementation Notes
            // --------------------
            //
            // You MUST invoke the custom parseError() coming from parserinput.js@134 by using the 'yy'
            // variable as that one is the only one pointing at your 'live' Parser instance.
            // ('this' points to the current yyval without the parser actions, which contrasts with the lexer actions...)
            if (chk.is_user_failure) {
                // When the error is a user formula entry mistake, it will abort and flag the formula as an error.
                rv = yy.parser.parseError("Function " + f_tok_spec.text + ": " + chk.message, {
                    text: yyvstack[$0 - 3],
                    token: yyvstack[$0 - 3],
                    line: yylstack[$0 - 3],
                    loc: yylstack[$0 - 3],
                    expected: [],
                    recoverable: false,
                    failure_info: chk
                });
                assert(rv === null);
                this.$ = NaN;
            } else {
                // Otherwise, the validation code discover a data input ('sourcing') error, which doesn't invalidate
                // the function used, it merely will make it *fail* at run-time, producing an error (NaN) value.
                //
                // This type of error has no further impact: it only should be reported to help the user while she is
                // entering the formula, thus serving as a notification that "you shouldn't expect anything sane from this
                // formula given these inputs you're feeding it!"
                //
                // Ergo we DO report this issue, but DO NOT push an ERROR token into the tokenstream or otherwise abort
                // the formula parsing process right now.
                vGraph._dispatchEvent(vGraph.EVENT.onParseError, {
                    message: "Function " + f_tok_spec.text + ": " + chk.message,
                    dataErrorInfo: chk
                });
                // continue as if nothing untoward happened:
                chk = false;
            }
        }
    
        if (!chk) {
            //console.log("a: ", a); // this is an array of values: one value per function argument.
            if (f_tok_spec.opcode.subject_category_references === FCT_CATEGORY_QA) {
                // provide our QA UDFs with location info for better reporting:
                a.push({
                    command_token: f_tok_spec,
                    command_locinfo: yylstack[$0 - 3],
                    args_start_locinfo: yylstack[$0 - 2],
                    args_locinfo: yylstack[$0 - 1],
                    args_end_locinfo: yylstack[$0]
                });
            }
            //WAS: $$ = f_tok_spec.opcode.implementation.apply(this, a);
            this.$ = Visyond.Functions.__exec_wrapper(f_tok_spec, a);        // 'flatten' and 'coerce' the argument list where needed.
    
            // console.log("processing function in parser: ", f_tok_spec.opcode);
    
            // don't bother collecting precedents when we're recalculating:
            if (!recalcValueOnly) {
                var kk;
                if(f_tok_spec.opcode.precedents) {
                    precedentsFromFunction = Visyond.Functions.__exec_wrapper(f_tok_spec, a, "precedents");
                    for(kk = 0; kk < precedentsFromFunction.length; kk++) {
                        // we signal that this is a precedent created by function (e.g., OFFSET) manipulation
    
                        //  commented the  el.precedentsFromFunction: we do not distinguish for now between function generated and node generated precedents; we brute force a recommit when we find a cell with a dynamicFunction
                        // precedentsFromFunction[kk].fromFunction = true;
    
                        addCellNameToPrecedents(precedentsFromFunction[kk]);
                    }
                }
            }
    
        }
    } else if (f_tok_spec.opcode && f_tok_spec.opcode.value != null) {
        // We are invoking an Excel-like 'function constant'.
        // Make sure didn't pass any parameters, as passing any would be illegal.
        //
        // Note that the 'epsilon' argument (of which we expect exactly ONE), itself is
        // encoded as NULL!
        assert(a.length >= 1);
        if (a.length !== 1 && a[0] !== null) {
            //console.log("Functional CONSTANT " + f_tok_spec.text + ": ", a);
            // Implementation Notes
            // --------------------
            //
            // You MUST invoke the custom parseError() coming from parserinput.js@134 by using the 'yy'
            // variable as that one is the only one pointing at your 'live' Parser instance.
            // ('this' points to the current yyval without the parser actions, which contrasts with the lexer actions...)
            rv = yy.parser.parseError("Functional CONSTANT " + f_tok_spec.text + ": does not accept any arguments", {
                text: yyvstack[$0 - 3],
                token: yyvstack[$0 - 3],
                line: yylstack[$0 - 3],
                loc: yylstack[$0 - 3],
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN;
        } else {
            this.$ = f_tok_spec.opcode.value;
        }
    } else {
        // we are trying to invoke a function which does NOT have any implementation!
        // This is an error - of the kind of 'not implemented yet?'
        rv = yy.parser.parseError("Function " + f_tok_spec.text + " has not been implemented yet.", {
            text: yyvstack[$0 - 3],
            token: yyvstack[$0 - 3],
            line: yylstack[$0 - 3],
            loc: yylstack[$0 - 3],
            expected: [],
            recoverable: false
        });
        assert(rv === null);
        this.$ = NaN;
    }
    break;

case 68:
    /*! Production::    multivalued_data_source : "(" math_expression ")" */
case 106:
    /*! Production::    price : value CURRENCY */
    this.$ = yyvstack[$0 - 1];
    break;

case 73:
    /*! Production::    one_json_filter_level : JSON_FILTER_FUNCTION "(" arglist ")" */
case 74:
    /*! Production::    one_json_filter_level : one_json_filter_level "[" math_expression "]" */
    this.$ = yyvstack[$0 - 3];
    break;

case 75:
    /*! Production::    one_json_filter_level : error */
    rv = yy.parser.parseError("Sub-level filters into cell values are currently not support yet.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 77:
    /*! Production::    cell_reference : remote_address fundamental_cell_reference */
    rv = yy.parser.parseError("Remote / Cross-project cell references are currently not support yet.", {
        text: yyvstack[$0 - 1],
        token: yyvstack[$0 - 1],
        line: yylstack[$0 - 1],
        loc: yylstack[$0 - 1],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    this.$ = NaN;
    break;

case 78:
    /*! Production::    remote_address : string "!" */
    // classic Excel mode: the 'remote' bit is stored in a string
    this.$ = yyvstack[$0 - 1];
    break;

case 79:
    /*! Production::    remote_address : URI optional_remote_address_marker */
    // we accept an OPTIONAL 'remote address marker' as '/' (which is part of the uri path) at the end is good enough as a separator too
    this.$ = yyvstack[$0 - 1];
    break;

case 80:
    /*! Production::    remote_address : PATH optional_remote_address_marker */
    // we accept an OPTIONAL 'remote address marker' as '/' (which is part of the path) at the end is good enough as a separator too
    this.$ = yyvstack[$0 - 1];
    break;

case 81:
    /*! Production::    remote_address : "(" URI ")" optional_remote_address_marker */
case 82:
    /*! Production::    remote_address : "(" PATH ")" optional_remote_address_marker */
case 84:
    /*! Production::    remote_address : "[" PATH "]" optional_remote_address_marker */
    this.$ = yyvstack[$0 - 2];
    break;

case 83:
    /*! Production::    remote_address : "[" URI "]" optional_remote_address_marker */
    // Excel way of referencing another workbook file...
    //
    // http://www.officetooltips.com/excel/tips/referencing_cells_outside_the_worksheet.html
    this.$ = yyvstack[$0 - 2];
    break;

case 88:
    /*! Production::    fundamental_cell_reference : CELLREF */
    this.$ = yyvstack[$0];
    parser.updateRangeLocationInfo(this.$, yylstack[$0], +1);
    break;

case 89:
    /*! Production::    any_range_reference : any_range_reference ARRAY_CONCATENATION_OPERATOR any_range_reference */
    /* a fragmented range, using alternative notation, i.e. this is equivalent to `{ any_range_reference , any_range_reference }` */
    //console.log("any_range_reference rule 1 :", @$);
    if (!(yyvstack[$0 - 2] instanceof parser.RangeRefRepresentation)) {
        range = new parser.RangeRefRepresentation(yyvstack[$0 - 2], yyvstack[$0]);
    } else {
        range = yyvstack[$0 - 2];
        range.addRef(yyvstack[$0]);
    }
    parser.updateRangeLocationInfo(range, yyvstack[$0 - 2].locInfo, yyvstack[$0 - 2].consumeCount);
    parser.updateRangeLocationInfo(range, yyvstack[$0].locInfo, yyvstack[$0].consumeCount);
    parser.updateRangeLocationInfo(range, this._$, +1);
    this.$ = range;
    break;

case 90:
    /*! Production::    any_range_reference : any_range_reference ARRAY_CONCATENATION_OPERATOR error */
    rv = yy.parser.parseError("Expected a cell or range reference to complete the range.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    //console.log("any_range_reference rule 2 : error: ", @$);
    this.$ = yyvstack[$0 - 2];
    break;

case 91:
    /*! Production::    any_range_reference : RANGEREF */
    /*
     * > ### Note on cell reference order in a range
     * >
     * > we don't mind if 'first' is below or to the right of 'last'.
     * > The area is calculated in the action function where the range is used
     * > and there the row / col min and max values will be determined, so
     * > that we can use a simple and effective storage method here.
     * >
     * > Besides, the user might have a good reason to specify the range
     * > that way, so we better keep the first->last order as specified by
     * > the user to insure we can deliver expected behaviour (and not loose
     * > context information in the parse).
     */
    //$$ = $RANGEREF;
    parser.updateRangeLocationInfo(this.$, yylstack[$0], +1);
    //        }
    //        {
    /* a regular range reference: */
    //console.log("range_reference rule 1 : range: ", @$);
    if (!(yyvstack[$0] instanceof parser.RangeRefRepresentation)) {
        range = new parser.RangeRefRepresentation(yyvstack[$0]);
    } else {
        range = yyvstack[$0];
    }
    this.$ = range;
    break;

case 92:
    /*! Production::    any_range_reference : "{" ambiguous_any_range_reference "}" */
    /*
     * A single range reference hiding in fragmented range notation or a fragmented range references with multiple curly braces surrounding it.
     *
     * We call the inner rule `**ambiguous_**any_range_reference` as it allows a cell range to be constructed
     * using ',' comma separated cell references, which as a notation is *ambiguous* when used in a function parameter list:
     * neither man nor machine will be able to identify which bits constitute a bundled range of cells and which items
     * are separate function arguments then if we do not use a bit of 'assistive' notation: the '{' '}' curly braces
     * which 'wrap' such an *ambiguous* range notation, e.g. `SUMPRODUCT({A1,A2,B1,B2},{C1,C2})`
     */
    range = yyvstack[$0 - 1];
    parser.updateRangeLocationInfo(range, this._$, +2);
    this.$ = range;
    break;

case 93:
    /*! Production::    ambiguous_any_range_reference : ambiguous_any_range_reference "," ambiguous_any_range_reference */
    /* a fragmented range: */
    //console.log("ambiguous_any_range_reference rule 1 :", @$);
    if (!(yyvstack[$0 - 2] instanceof parser.RangeRefRepresentation)) {
        range = new parser.RangeRefRepresentation(yyvstack[$0 - 2], yyvstack[$0]);
    } else {
        range = yyvstack[$0 - 2];
        range.addRef(yyvstack[$0]);
    }
    parser.updateRangeLocationInfo(range, yyvstack[$0 - 2].locInfo, yyvstack[$0 - 2].consumeCount);
    parser.updateRangeLocationInfo(range, yyvstack[$0].locInfo, yyvstack[$0].consumeCount);
    parser.updateRangeLocationInfo(range, this._$, +1);
    this.$ = range;
    break;

case 94:
    /*! Production::    ambiguous_any_range_reference : any_range_reference */
    /* a fragmented range, a cell reference or a regular range reference */
    this.$ = yyvstack[$0];
    break;

case 95:
    /*! Production::    ambiguous_any_range_reference : cell_reference */
    /* a single cell reference, possibly acting as a range-of-one, depending on where this is used: */
    // console.log("ambiguous_any_range_reference rule 3 : cell: ", @$);
    range = new parser.RangeRefRepresentation(yyvstack[$0]);
    parser.updateRangeLocationInfo(range, yyvstack[$0].locInfo, yyvstack[$0].consumeCount);
    this.$ = range;
    break;

case 96:
    /*! Production::    ambiguous_any_range_reference : error */
    rv = yy.parser.parseError("Expected a (possibly fragmented) range reference.", {
        text: yyvstack[$0],
        token: yyvstack[$0],
        line: yylstack[$0],
        loc: yylstack[$0],
        outer_loc: this._$,
        expected: [],
        recoverable: false
    });
    assert(rv === null);
    //console.log("ambiguous_any_range_reference rule 4 : error: ", @$);
    range = {
        rangeRef: null,
        locInfo: null,
        consumeCount: 0
    };
    parser.updateRangeLocationInfo(range, this._$, 0);
    this.$ = range;
    break;

case 97:
    /*! Production::    one_argument : math_expression */
    this.$ = [yyvstack[$0]];
    break;

case 98:
    /*! Production::    one_argument : any_range_reference */
    // this still is a single function argument and should be identifiable as such:
    // hence the range specified as argument is stored into a single outer array entry here.
    //
    // Example to see the 'trouble': =MATCH(7,A1:A6,0): to properly feed MATCH() it should
    // receive 3 arguments: [1, [...], 0], where [...] is an ARRAY value listing the values
    // obtained from the range A1:A6, e.g. [3,4,5,6,7,8]
    //
    // WARNING: the current parser (the non-AST one!) always converts cell (and range) references
    // to values extremely quickly; this implies that functions such as ADDRESS() or INDEX() are
    // not supported as those require access to the actual cell references themselves.
    //
    // (Aside: of course we can be nasty and hack a cellref on top of a value as a JavaScript object attribute
    // but I'd rather not go there and do it properly with AST objects instead using the new parser...)
    //
    // Now for the slightly less positive news: =SUM(A1:A6) vs. =SUM(A1,A2,A3,A4,A5,A6) vs. =SUM(A1:A4,A5,A6):
    // all MUST deliver the same value due to the way SUM is meant to work, but these three will 'invoke'
    // the SUM() operator very differently: here are their arglist arrays: (assume A1=1, A2=2, ...)
    //
    //   =SUM(A1:A6)             : A1:A6             -> one_array_entry                           -> arglist = [[1,2,3,4,5,6]]
    //   =SUM(A1,A2,A3,A4,A5,A6) : A1,A2,A3,A4,A5,A6 -> one_element, one_element, ... (6x)        -> arglist = [1,2,3,4,5,6]
    //   =SUM(A1:A4,A5,A6)       : A1:A4,A5,A6       -> one_array_entry, one_element, one_element -> arglist = [[1,2,3,4],5,6]
    //
    // Now for the REAL trouble:
    //   =MATCH(7,A1:A6,0) (or any other Excel function that expects at least one other function parameter next to an array)
    //   -> do some projection or row insert/delete op in the grid: Visyond will 'service' you by rewriting the array TOKEN
    //      into an ARRAY of tokens. Great idea but you just lost everything as now the parameter list is ambiguous and cannot
    //      be resolved any more for such functions:
    //   -> drag/drop / insert row / other action that rewrites arrays in tokenarray
    //   -> =MATCH(7,A1,A2,A3,A4,A5,A6,0)
    //   -> OUCH! Nobody can tell us later on whether this is a user mistake feeding the function too many arguments or
    //      this being an expanded array in there. (Yes, there do exist Excel functions (Matrix ops!) which expect 2(!) or more
    //      array references as function arguments: when both are expanded (and they will), there is no telling where one
    //      ends and the next starts.)
    //   => Support for these functions (including SUMA(), SUMIF(), ...) is only possible when 'token stream rewriting' is heavily
    //      augmented and the parser is taught some additional notation as well (this is partly available in the AST grammar as
    //      it supports a superset of the Excel formula notation), e.g.
    //   =MATCH(7,A1:A6,0) -> tokenstream rewrite -> =MATCH(7,{A1,A2,A3,A4,A5,A6},0)
    //      or when expansion is done partially:
    //   =MATCH(7,A1:A6,0) -> tokenstream rewrite -> =MATCH(7,{A1,A2:A5,A6},0)
    //      With this 'extended' notation re-using the '{}' curly braces (also used by Excel for array formulas but we do not support those (yet))
    //      anything inside the curly braces is treated as part of a single array element:
    //   {A1,A2,A3,A4,A5,A6} is equivalent to {A1,A2:A5,A6} is equivalent to {A1:A6} is equivalent to A1:A6
    //
    // Anyhow, the above is NOT supported by this parser; only the AST parser provides for these constructs. The above explanation
    // is included here so y'all know what goes wrong and why...
    range = yyvstack[$0];
    
    //patch_tokenstream("RANGEREF", range, 1 /* range.consumeCount */, @any_range_reference);
    
    this.$ = [range];
    break;

case 99:
    /*! Production::    one_argument : ε */
    /*
     * No argument specified at all: some functions accept this kind of behaviour.
     * It also serves as a way to specify a function with zero arguments, e.g.
     * `RANDOM()`.
     *
     * An empty argument is also legal as part of a larger argument set where *optional*
     * argument entries are accepted, e.g. `IF(A1,B1,)` or `LINEST(A1:A3,B1:B3,,1)`
     * hence we must push a special `nil` AST node for every empty argument.
     */
    
    // empty argument must take up a slot in the args array, hence we push NULL:
    this.$ = [null];
    break;

case 101:
    /*! Production::    arglist : arglist "," one_argument */
    this.$ = yyvstack[$0 - 2].concat(yyvstack[$0]);
    break;

case 102:
    /*! Production::    percentage : value PERCENTAGE_OPERATOR */
    this.$ = yyvstack[$0 - 1] / 100;
    break;

case 103:
    /*! Production::    percentage : value PROMILAGE_OPERATOR */
    this.$ = yyvstack[$0 - 1] / 1000;
    break;

case 104:
    /*! Production::    radians : value DEGREES_OPERATOR */
    // convert value to radians!
    this.$ = yyvstack[$0 - 1] * 2 * Math.PI / 360;
    break;

case 105:
    /*! Production::    price : CURRENCY value */
    /* The `CURRENCY` AST opcode has the notation attributes we need: */
    this.$ = yyvstack[$0];
    break;

case 107:
    /*! Production::    value : "-" number */
case 113:
    /*! Production::    constant : "-" CONSTANT */
    this.$ = -(yyvstack[$0]);
    break;

case 108:
    /*! Production::    value : "+" number */
case 114:
    /*! Production::    constant : "+" CONSTANT */
    this.$ = +(yyvstack[$0]);
    break;

case 110:
    /*! Production::    number : NUMBER */
    assert(Number(yyvstack[$0]) === yytext);
    this.$ = yyvstack[$0];
    break;

case 111:
    /*! Production::    number : INTEGER_NUMBER */
    assert(Number(yyvstack[$0]) === yytext);
    //console.log("Integer Number: value = ", $INTEGER_NUMBER, @INTEGER_NUMBER, yytext);
    this.$ = yyvstack[$0];
    break;

}
},
table: bt({
  len: u([
  31,
  1,
  2,
  33,
  s,
  [2, 4],
  11,
  4,
  25,
  6,
  s,
  [2, 4],
  s,
  [6, 3],
  s,
  [2, 3],
  4,
  4,
  31,
  27,
  6,
  28,
  27,
  27,
  31,
  31,
  1,
  1,
  2,
  27,
  32,
  19,
  19,
  15,
  27,
  31,
  s,
  [27, 5],
  28,
  27,
  28,
  1,
  33,
  28,
  29,
  2,
  29,
  3,
  3,
  s,
  [2, 3],
  1,
  2,
  3,
  2,
  6,
  15,
  s,
  [2, 4],
  s,
  [27, 4],
  2,
  c,
  [20, 4],
  31,
  c,
  [41, 4],
  s,
  [32, 19],
  s,
  [27, 9],
  1,
  5,
  40,
  1,
  4,
  4,
  29,
  s,
  [1, 7],
  4,
  c,
  [66, 3],
  c,
  [61, 5],
  22,
  27,
  s,
  [22, 4],
  s,
  [27, 10],
  29,
  29,
  1,
  29,
  s,
  [2, 3],
  3,
  28,
  s,
  [3, 4],
  s,
  [6, 3],
  15,
  5,
  33,
  40,
  28,
  39,
  s,
  [1, 4],
  2,
  27,
  1,
  2,
  2,
  29,
  29
]),
  symbol: u([
  2,
  3,
  6,
  7,
  s,
  [24, 7, 1],
  s,
  [53, 12, 1],
  s,
  [81, 8, 1],
  1,
  1,
  2,
  2,
  6,
  7,
  12,
  14,
  16,
  41,
  44,
  47,
  48,
  49,
  c,
  [34, 7],
  65,
  66,
  68,
  69,
  72,
  73,
  76,
  c,
  [36, 9],
  2,
  1,
  2,
  c,
  [4, 4],
  2,
  14,
  16,
  c,
  [36, 3],
  59,
  c,
  [26, 3],
  88,
  2,
  18,
  51,
  77,
  c,
  [56, 3],
  c,
  [86, 11],
  c,
  [84, 12],
  2,
  28,
  29,
  52,
  53,
  c,
  [54, 8],
  6,
  7,
  54,
  55,
  84,
  85,
  c,
  [6, 12],
  c,
  [24, 6],
  c,
  [55, 3],
  85,
  c,
  [4, 4],
  s,
  [1, 11, 1],
  15,
  17,
  20,
  c,
  [82, 3],
  s,
  [31, 10, 1],
  42,
  43,
  c,
  [71, 4],
  c,
  [31, 13],
  c,
  [29, 12],
  c,
  [78, 8],
  s,
  [3, 10, 1],
  c,
  [34, 16],
  c,
  [61, 27],
  c,
  [27, 42],
  c,
  [146, 31],
  c,
  [31, 17],
  c,
  [339, 3],
  c,
  [93, 27],
  c,
  [366, 18],
  c,
  [365, 14],
  c,
  [357, 3],
  c,
  [28, 4],
  c,
  [27, 3],
  59,
  67,
  c,
  [25, 5],
  85,
  c,
  [19, 27],
  c,
  [16, 7],
  c,
  [370, 3],
  c,
  [205, 71],
  c,
  [317, 81],
  c,
  [27, 50],
  c,
  [453, 55],
  13,
  c,
  [28, 16],
  14,
  c,
  [728, 35],
  c,
  [62, 26],
  c,
  [28, 14],
  19,
  c,
  [29, 14],
  49,
  76,
  c,
  [31, 29],
  12,
  49,
  74,
  c,
  [3, 3],
  47,
  48,
  c,
  [520, 4],
  12,
  c,
  [7, 4],
  50,
  c,
  [10, 4],
  15,
  19,
  20,
  50,
  c,
  [439, 3],
  18,
  c,
  [143, 3],
  51,
  c,
  [836, 4],
  77,
  78,
  c,
  [857, 9],
  c,
  [362, 110],
  54,
  55,
  c,
  [888, 3],
  c,
  [901, 7],
  c,
  [540, 71],
  c,
  [598, 70],
  c,
  [795, 33],
  c,
  [32, 575],
  c,
  [1260, 146],
  c,
  [27, 97],
  49,
  2,
  45,
  46,
  70,
  71,
  c,
  [281, 5],
  15,
  16,
  18,
  20,
  c,
  [284, 5],
  51,
  c,
  [1294, 14],
  77,
  s,
  [79, 10, 1],
  15,
  12,
  15,
  c,
  [1211, 3],
  c,
  [4, 3],
  c,
  [1278, 30],
  49,
  49,
  17,
  17,
  15,
  15,
  c,
  [2051, 4],
  19,
  20,
  c,
  [1237, 3],
  c,
  [5, 4],
  c,
  [239, 111],
  c,
  [25, 14],
  36,
  c,
  [49, 56],
  c,
  [22, 66],
  c,
  [592, 240],
  c,
  [1932, 40],
  16,
  c,
  [29, 44],
  14,
  c,
  [30, 29],
  15,
  20,
  15,
  20,
  c,
  [4, 4],
  c,
  [1861, 3],
  c,
  [1967, 26],
  c,
  [1907, 6],
  c,
  [3, 6],
  c,
  [1899, 6],
  c,
  [6, 12],
  c,
  [1911, 15],
  c,
  [788, 10],
  c,
  [2078, 28],
  c,
  [821, 40],
  c,
  [151, 28],
  c,
  [68, 31],
  c,
  [67, 8],
  s,
  [49, 4],
  c,
  [836, 29],
  17,
  c,
  [257, 4],
  c,
  [353, 58]
]),
  type: u([
  s,
  [2, 18],
  s,
  [0, 13],
  1,
  s,
  [2, 20],
  s,
  [0, 15],
  c,
  [30, 19],
  c,
  [7, 4],
  c,
  [52, 25],
  c,
  [81, 20],
  c,
  [6, 16],
  c,
  [23, 6],
  c,
  [71, 18],
  s,
  [2, 48],
  c,
  [110, 20],
  s,
  [2, 175],
  c,
  [365, 25],
  c,
  [19, 35],
  c,
  [370, 25],
  s,
  [2, 277],
  c,
  [728, 30],
  c,
  [73, 44],
  c,
  [32, 34],
  c,
  [35, 30],
  c,
  [439, 126],
  c,
  [159, 33],
  c,
  [795, 161],
  c,
  [32, 583],
  c,
  [1270, 231],
  c,
  [1294, 37],
  c,
  [289, 7],
  c,
  [1940, 44],
  c,
  [1656, 296],
  s,
  [2, 356],
  c,
  [1748, 6],
  c,
  [1754, 31],
  c,
  [743, 9],
  c,
  [1069, 34],
  c,
  [821, 45],
  c,
  [2183, 61],
  c,
  [1177, 98]
]),
  state: u([
  1,
  2,
  4,
  5,
  6,
  13,
  15,
  14,
  11,
  24,
  12,
  21,
  19,
  34,
  35,
  40,
  49,
  52,
  54,
  53,
  43,
  45,
  44,
  41,
  24,
  42,
  46,
  47,
  59,
  54,
  53,
  61,
  63,
  67,
  68,
  69,
  c,
  [31, 8],
  75,
  24,
  78,
  24,
  79,
  24,
  80,
  82,
  84,
  24,
  107,
  c,
  [40, 13],
  108,
  109,
  c,
  [14, 4],
  80,
  61,
  111,
  c,
  [8, 5],
  82,
  61,
  112,
  c,
  [8, 5],
  61,
  116,
  c,
  [78, 14],
  119,
  120,
  122,
  130,
  54,
  53,
  129,
  128,
  61,
  80,
  82,
  132,
  c,
  [25, 13],
  133,
  c,
  [14, 13],
  134,
  c,
  [14, 13],
  135,
  c,
  [14, 13],
  136,
  c,
  [14, 13],
  137,
  c,
  [14, 13],
  138,
  c,
  [14, 13],
  139,
  c,
  [14, 13],
  140,
  c,
  [14, 13],
  141,
  c,
  [14, 13],
  142,
  c,
  [14, 13],
  143,
  c,
  [14, 13],
  144,
  c,
  [14, 13],
  145,
  c,
  [14, 13],
  146,
  c,
  [14, 13],
  147,
  c,
  [14, 13],
  148,
  c,
  [14, 13],
  149,
  c,
  [14, 13],
  150,
  c,
  [14, 13],
  151,
  152,
  158,
  c,
  [294, 6],
  159,
  157,
  156,
  c,
  [20, 8],
  120,
  122,
  165,
  s,
  [174, 4, 1],
  c,
  [301, 4],
  178,
  61,
  179,
  152,
  180,
  c,
  [327, 14],
  c,
  [48, 9],
  181,
  c,
  [18, 16],
  182,
  c,
  [17, 8]
]),
  mode: u([
  s,
  [1, 38],
  s,
  [2, 8],
  c,
  [32, 26],
  c,
  [38, 24],
  c,
  [18, 12],
  s,
  [2, 58],
  c,
  [62, 62],
  s,
  [2, 92],
  c,
  [233, 12],
  s,
  [1, 61],
  c,
  [115, 44],
  c,
  [14, 26],
  c,
  [277, 135],
  c,
  [55, 71],
  c,
  [295, 61],
  c,
  [148, 45],
  1,
  c,
  [32, 3],
  c,
  [93, 6],
  c,
  [718, 6],
  c,
  [479, 20],
  c,
  [606, 119],
  c,
  [757, 156],
  s,
  [1, 333],
  s,
  [2, 244],
  c,
  [252, 9],
  c,
  [3, 5],
  c,
  [272, 15],
  c,
  [275, 35],
  c,
  [1666, 12],
  c,
  [82, 15],
  c,
  [1012, 6],
  c,
  [76, 12],
  c,
  [27, 27],
  c,
  [57, 8],
  c,
  [1066, 15],
  c,
  [27, 31],
  c,
  [79, 17],
  c,
  [49, 54],
  c,
  [22, 66],
  c,
  [191, 60],
  c,
  [1271, 9],
  c,
  [375, 17],
  c,
  [81, 25],
  c,
  [27, 29],
  c,
  [22, 7],
  c,
  [27, 81],
  c,
  [1780, 51],
  c,
  [1494, 4],
  c,
  [1571, 74],
  c,
  [609, 8],
  c,
  [1608, 33],
  c,
  [35, 21],
  c,
  [1025, 36],
  c,
  [773, 16],
  c,
  [762, 33],
  c,
  [50, 45],
  c,
  [441, 12],
  s,
  [2, 56]
]),
  goto: u([
  7,
  3,
  23,
  22,
  8,
  9,
  10,
  16,
  17,
  18,
  20,
  26,
  30,
  31,
  25,
  28,
  29,
  27,
  32,
  33,
  48,
  38,
  37,
  39,
  51,
  58,
  36,
  50,
  56,
  57,
  55,
  c,
  [20, 7],
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  60,
  62,
  58,
  c,
  [21, 3],
  27,
  64,
  66,
  65,
  70,
  23,
  22,
  c,
  [52, 11],
  16,
  16,
  71,
  72,
  74,
  73,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  77,
  76,
  30,
  31,
  c,
  [4, 8],
  24,
  24,
  25,
  25,
  26,
  c,
  [38, 3],
  81,
  30,
  31,
  83,
  s,
  [109, 31],
  s,
  [112, 27],
  c,
  [74, 4],
  s,
  [117, 28],
  s,
  [115, 27],
  s,
  [116, 27],
  s,
  [110, 31],
  s,
  [111, 31],
  1,
  2,
  3,
  3,
  27,
  27,
  95,
  93,
  94,
  s,
  [98, 4, 1],
  103,
  106,
  s,
  [27, 3],
  102,
  s,
  [85, 8, 1],
  96,
  97,
  104,
  105,
  c,
  [325, 18],
  110,
  51,
  58,
  c,
  [14, 4],
  c,
  [268, 3],
  c,
  [11, 10],
  83,
  c,
  [11, 8],
  27,
  s,
  [54, 27],
  s,
  [55, 15],
  71,
  72,
  s,
  [55, 12],
  74,
  73,
  s,
  [56, 27],
  s,
  [57, 27],
  s,
  [58, 27],
  s,
  [59, 27],
  s,
  [60, 27],
  s,
  [61, 11],
  113,
  s,
  [61, 16],
  s,
  [62, 27],
  s,
  [65, 11],
  114,
  s,
  [65, 16],
  115,
  c,
  [325, 8],
  117,
  118,
  c,
  [325, 8],
  s,
  [69, 28],
  s,
  [76, 29],
  55,
  s,
  [88, 29],
  121,
  85,
  121,
  85,
  123,
  124,
  8,
  8,
  9,
  9,
  113,
  125,
  126,
  10,
  10,
  127,
  11,
  11,
  s,
  [91, 6],
  131,
  62,
  58,
  66,
  c,
  [414, 3],
  65,
  27,
  12,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  s,
  [102, 27],
  s,
  [103, 27],
  s,
  [106, 27],
  s,
  [104, 27],
  21,
  21,
  30,
  31,
  30,
  31,
  22,
  22,
  23,
  23,
  s,
  [107, 31],
  s,
  [113, 27],
  s,
  [108, 31],
  s,
  [114, 27],
  s,
  [105, 27],
  c,
  [732, 18],
  c,
  [18, 325],
  s,
  [48, 26],
  s,
  [49, 27],
  s,
  [50, 27],
  s,
  [47, 27],
  s,
  [51, 27],
  s,
  [63, 27],
  s,
  [64, 27],
  s,
  [52, 27],
  s,
  [53, 27],
  78,
  155,
  153,
  154,
  c,
  [265, 5],
  99,
  58,
  66,
  99,
  c,
  [268, 5],
  65,
  c,
  [269, 7],
  160,
  121,
  161,
  85,
  121,
  162,
  85,
  s,
  [77, 29],
  79,
  86,
  80,
  163,
  164,
  161,
  162,
  166,
  66,
  65,
  167,
  168,
  94,
  94,
  127,
  95,
  95,
  96,
  96,
  28,
  28,
  c,
  [1425, 8],
  s,
  [28, 4],
  102,
  28,
  28,
  c,
  [1425, 7],
  28,
  104,
  105,
  29,
  29,
  c,
  [27, 8],
  s,
  [29, 4],
  102,
  29,
  29,
  c,
  [27, 7],
  29,
  104,
  105,
  s,
  [30, 5],
  c,
  [27, 5],
  s,
  [30, 4],
  102,
  s,
  [30, 10],
  104,
  105,
  s,
  [31, 5],
  c,
  [27, 5],
  s,
  [31, 4],
  102,
  s,
  [31, 10],
  104,
  105,
  32,
  32,
  95,
  c,
  [25, 5],
  s,
  [32, 4],
  102,
  32,
  32,
  87,
  88,
  90,
  96,
  32,
  104,
  105,
  s,
  [33, 5],
  c,
  [24, 5],
  s,
  [33, 4],
  102,
  s,
  [33, 10],
  104,
  105,
  34,
  34,
  c,
  [49, 6],
  s,
  [34, 4],
  102,
  34,
  34,
  c,
  [49, 4],
  34,
  104,
  105,
  35,
  35,
  c,
  [22, 6],
  s,
  [35, 4],
  102,
  35,
  35,
  c,
  [22, 4],
  35,
  104,
  105,
  36,
  36,
  c,
  [22, 6],
  s,
  [36, 4],
  102,
  36,
  36,
  c,
  [22, 4],
  36,
  104,
  105,
  37,
  37,
  c,
  [22, 6],
  s,
  [37, 4],
  102,
  37,
  37,
  c,
  [22, 4],
  37,
  104,
  105,
  s,
  [38, 5],
  c,
  [24, 5],
  s,
  [38, 4],
  102,
  s,
  [38, 10],
  104,
  105,
  s,
  [39, 5],
  c,
  [27, 5],
  s,
  [39, 4],
  102,
  s,
  [39, 10],
  104,
  105,
  40,
  40,
  c,
  [272, 8],
  s,
  [40, 4],
  c,
  [1724, 10],
  40,
  104,
  105,
  s,
  [41, 7],
  c,
  [27, 3],
  s,
  [41, 4],
  102,
  s,
  [41, 10],
  104,
  105,
  s,
  [42, 7],
  c,
  [27, 3],
  s,
  [42, 4],
  102,
  s,
  [42, 10],
  104,
  105,
  s,
  [43, 9],
  103,
  s,
  [43, 4],
  102,
  s,
  [43, 10],
  104,
  105,
  s,
  [44, 9],
  103,
  s,
  [44, 4],
  102,
  s,
  [44, 10],
  104,
  105,
  s,
  [45, 9],
  103,
  s,
  [45, 4],
  102,
  s,
  [45, 10],
  104,
  105,
  s,
  [46, 9],
  103,
  s,
  [46, 15],
  104,
  105,
  s,
  [66, 27],
  s,
  [70, 11],
  169,
  70,
  170,
  s,
  [70, 15],
  s,
  [72, 29],
  171,
  s,
  [75, 29],
  172,
  173,
  100,
  100,
  97,
  97,
  98,
  98,
  127,
  s,
  [68, 28],
  c,
  [1608, 4],
  c,
  [4, 4],
  s,
  [89, 6],
  s,
  [90, 6],
  s,
  [92, 6],
  c,
  [1610, 9],
  c,
  [755, 8],
  c,
  [1038, 18],
  c,
  [773, 17],
  s,
  [67, 28],
  c,
  [50, 22],
  s,
  [81, 4, 1],
  93,
  93,
  s,
  [71, 27],
  183,
  184,
  173,
  101,
  101,
  s,
  [74, 29],
  s,
  [73, 29]
])
}),
defaultActions: bda({
  idx: u([
  s,
  [4, 4, 1],
  s,
  [12, 4, 1],
  19,
  20,
  21,
  24,
  25,
  s,
  [27, 8, 1],
  40,
  s,
  [42, 5, 1],
  48,
  52,
  53,
  55,
  59,
  60,
  64,
  65,
  s,
  [67, 9, 1],
  s,
  [78, 7, 1],
  s,
  [104, 10, 1],
  s,
  [119, 4, 1],
  130,
  131,
  s,
  [151, 4, 2],
  158,
  160,
  165,
  166,
  167,
  172,
  s,
  [174, 6, 1],
  182,
  183,
  184
]),
  goto: u([
  s,
  [4, 4, 1],
  s,
  [17, 4, 1],
  24,
  25,
  26,
  109,
  112,
  117,
  115,
  116,
  110,
  111,
  1,
  2,
  3,
  54,
  s,
  [56, 5, 1],
  62,
  69,
  76,
  88,
  8,
  9,
  11,
  91,
  s,
  [12, 4, 1],
  102,
  103,
  106,
  104,
  21,
  22,
  23,
  107,
  113,
  108,
  114,
  105,
  48,
  49,
  50,
  47,
  51,
  63,
  64,
  52,
  53,
  78,
  77,
  79,
  86,
  80,
  95,
  96,
  66,
  72,
  75,
  100,
  97,
  68,
  89,
  90,
  92,
  67,
  s,
  [81, 4, 1],
  93,
  71,
  101,
  74,
  73
])
}),
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
        hash.destroy();             // destroy... well, *almost*!
    } else {
        throw new this.JisonParserError(str, hash);
    }
},
parse: function parse(input, cfg, one, two) {
    var self = this,
        stack = new Array(128),         // token stack: stores token which leads to state at the same index (column storage)
        sstack = new Array(128),        // state stack: stores states (column storage)

        vstack = new Array(128),        // semantic value stack
        lstack = new Array(128),        // location stack
        table = this.table,
        sp = 0;                         // 'stack pointer': index into the stacks

    var recovering = 0;                 // (only used when the grammar contains error recovery rules)
    var TERROR = this.TERROR,
        EOF = this.EOF,
        ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, table.length /* ensures that anyone using this new state will fail dramatically! */];

    //this.reductionCount = this.shiftCount = 0;

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: null,
        quoteName: null,
        lexer: null,
        parser: null,
        pre_parse: null,
        post_parse: null
    };
    // copy state
    for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState_yy[k] = this.yy[k];
      }
    }

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    lexer.setInput(input, sharedState_yy);

    if (typeof lexer.yylloc === 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack[sp] = yyloc;
    vstack[sp] = null;
    sstack[sp] = 0;
    stack[sp] = 0;
    ++sp;

    if (typeof lexer.yytext === 'undefined') {
        lexer.yytext = '';
    }
    var yytext = lexer.yytext;
    if (typeof lexer.yylineno === 'undefined') {
        lexer.yylineno = 0;
    }




    var ranges = lexer.options && lexer.options.ranges;

    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = sharedState_yy.parseError;
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = sharedState_yy.quoteName;
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, cfg, one, two);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, cfg, one, two);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.parseError = undefined;
            sharedState_yy.quoteName = undefined;
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;
        lstack.length = 0;
        vstack.length = 0;
        stack_pointer = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;
        }

        return resultValue;
    };

    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: lexer.yylloc,
            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            location_stack: lstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };


    function lex(cfg, one, two) {
        var token = lexer.lex(cfg, one, two);
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token || EOF;
    }


    var symbol = 0;
    var preErrorSymbol = 0;
    var lastEofErrorStateDepth = 0;
    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p, len, this_production;
    var lstack_begin, lstack_end;
    var newState;
    var retval = false;


    // Return the rule stack depth where the nearest error rule can be found.
    // Return -1 when no error recovery rule was found.
    function locateNearestErrorRecoveryRule(state) {
        var stack_probe = sp - 1;
        var depth = 0;

        // try to recover from error
        for (;;) {
            // check for error recovery rule in this state

            var t = table[state][TERROR] || NO_ACTION;
            if (t[0]) {
                // We need to make sure we're not cycling forever:
                // once we hit EOF, even when we `yyerrok()` an error, we must
                // prevent the core from running forever,
                // e.g. when parent rules are still expecting certain input to
                // follow after this, for example when you handle an error inside a set
                // of braces which are matched by a parent rule in your grammar.
                //
                // Hence we require that every error handling/recovery attempt
                // *after we've hit EOF* has a diminishing state stack: this means
                // we will ultimately have unwound the state stack entirely and thus
                // terminate the parse in a controlled fashion even when we have
                // very complex error/recovery code interplay in the core + user
                // action code blocks:

                if (symbol === EOF) {
                    if (!lastEofErrorStateDepth) {
                        lastEofErrorStateDepth = sp - 1 - depth;
                    } else if (lastEofErrorStateDepth <= sp - 1 - depth) {

                        --stack_probe; // popStack(1): [symbol, action]
                        state = sstack[stack_probe];
                        ++depth;
                        continue;
                    }
                }
                return depth;
            }
            if (state === 0 /* $accept rule */ || stack_probe < 1) {

                return -1; // No suitable error recovery rule available.
            }
            --stack_probe; // popStack(1): [symbol, action]
            state = sstack[stack_probe];
            ++depth;
        }
    }


    try {
        this.__reentrant_call_depth++;

        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy, cfg, one, two);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy, cfg, one, two);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex(cfg, one, two);
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];




                // handle parse error
                if (!action) {
                    // first see if there's any chance at hitting an error recovery rule:
                    var error_rule_depth = locateNearestErrorRecoveryRule(state);
                    var errStr = null;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    if (!recovering) {
                        // Report error
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ':\n' + lexer.showPosition(79 - 10, 10) + '\n';
                        } else {
                            errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                        }
                        if (expected.length) {
                            errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                        } else {
                            errStr += 'Unexpected ' + errSymbolDescr;
                        }
                        p = this.constructParseErrorInfo(errStr, null, expected, (error_rule_depth >= 0));
                        r = this.parseError(p.errStr, p);


                        if (!p.recoverable) {
                            retval = r;
                            break;
                        } else {
                            // TODO: allow parseError callback to edit symbol and or state at the start of the error recovery process...
                        }
                    }



                    // just recovered from another error
                    if (recovering === ERROR_RECOVERY_TOKEN_DISCARD_COUNT && error_rule_depth >= 0) {
                        // only barf a fatal hairball when we're out of look-ahead symbols and none hit a match;
                        // this DOES discard look-ahead while recovering from an error when said look-ahead doesn't
                        // suit the error recovery rules... The error HAS been reported already so we're fine with
                        // throwing away a few items if that is what it takes to match the nearest recovery rule!
                        if (symbol === EOF || preErrorSymbol === EOF) {
                            p = this.constructParseErrorInfo((errStr || 'Parsing halted while starting to recover from another error.'), null, expected, false);
                            retval = this.parseError(p.errStr, p);
                            break;
                        }

                        // discard current lookahead and grab another

                        yytext = lexer.yytext;

                        yyloc = lexer.yylloc;

                        symbol = lex(cfg, one, two);


                    }

                    // try to recover from error
                    if (error_rule_depth < 0) {
                        p = this.constructParseErrorInfo((errStr || 'Parsing halted. No suitable error recovery rule available.'), null, expected, false);
                        retval = this.parseError(p.errStr, p);
                        break;
                    }
                    sp -= error_rule_depth;

                    preErrorSymbol = (symbol === TERROR ? 0 : symbol); // save the lookahead token
                    symbol = TERROR;            // insert generic error symbol as new lookahead
                    // allow N (default: 3) real symbols to be shifted before reporting a new error
                    recovering = ERROR_RECOVERY_TOKEN_DISCARD_COUNT;

                    newState = sstack[sp - 1];



                    continue;
                }


            }


            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo(('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol), null, null, false);
                    retval = this.parseError(p.errStr, p);
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                retval = this.parseError(p.errStr, p);
                break;

            // shift:
            case 1:
                //this.shiftCount++;
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;
                lstack[sp] = lexer.yylloc;
                sstack[sp] = newState; // push state
                ++sp;
                symbol = 0;
                if (!preErrorSymbol) { // normal execution / no error
                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:

                    yytext = lexer.yytext;

                    yyloc = lexer.yylloc;

                    if (recovering > 0) {
                        recovering--;

                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error, *unless* that drops us straight back into error mode:
                    symbol = preErrorSymbol;
                    preErrorSymbol = 0;

                    // read action for current state and first input
                    t = (table[newState] && table[newState][symbol]) || NO_ACTION;
                    if (!t[0] || symbol === TERROR) {
                        // forget about that symbol and move forward: this wasn't a 'forgot to insert' error type where
                        // (simple) stuff might have been missing before the token which caused the error we're
                        // recovering from now...
                        //
                        // Also check if the LookAhead symbol isn't the ERROR token we set as part of the error
                        // recovery, for then this we would we idling (cycling) on the error forever.
                        // Yes, this does not take into account the possibility that the *lexer* may have
                        // produced a *new* TERROR token all by itself, but that would be a very peculiar grammar!

                        symbol = 0;
                    }
                }

                continue;

            // reduce:
            case 2:
                //this.reductionCount++;
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                len = this_production[1];
                lstack_end = sp;
                lstack_begin = lstack_end - (len || 1);
                lstack_end--;



                // Make sure subsequent `$$ = $1` default action doesn't fail
                // for rules where len==0 as then there's no $1 (you're reducing an epsilon rule then!)
                //
                // Also do this to prevent nasty action block codes to *read* `$0` or `$$`
                // and *not* get `undefined` as a result for their efforts!
                vstack[sp] = undefined;

                // perform semantic action
                yyval.$ = vstack[sp - len]; // default to $$ = $1; result must produce `undefined` when len == 0, as then there's no $1

                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack_begin].first_line,
                    last_line: lstack[lstack_end].last_line,
                    first_column: lstack[lstack_begin].first_column,
                    last_column: lstack[lstack_end].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack_begin].range[0], lstack[lstack_end].range[1]];
                }

                r = this.performAction.call(yyval, yytext, yyloc, newState, sp - 1, vstack, lstack, cfg, one, two);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= len;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                lstack[sp] = yyval._$;
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;

                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                //
                // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                // default, action):
                //
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //
                // which, combined with the parse kernel's `$accept` state behaviour coded below,
                // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                //
                // In code:
                //
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                if (typeof yyval.$ !== 'undefined') {
                    retval = yyval.$;
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too:
        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
        retval = this.parseError(p.errStr, p);
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;

/*
     * This chunk is included in the parser code, before the lexer definition section and after the parser has been defined.
     *
     * WARNING:
     *
     * Meanwhile, keep in mind that all the parser actions, which will execute inside the `parser.performAction()` function,
     * will have a `this` pointing to `$$`.
     *
     * If you want to access the lexer and/or parser, these are accessible inside the parser rule action code via
     * the `yy.lexer` and `yy.parser` dereferences respectively.
     */

    //console.log("parser object definition: ", this);











/*
 * This chunk is included in the parser object code,
 * following the 'init' code block that may be set in `%{ ... %}` at the top of this
 * grammar definition file.
 */



parser.createRangeFromRange = function (rangeref) {
    return {
        rangeRef: [parseReference(rangeref, global.Visyond.__parser_globals.worksheetIndex, {rangeref: true})],
        locInfo: null,
        consumeCount: 0
    };
};


parser.updateRangeLocationInfo = function (range, locInfo, consumeCount) {
    if (!range.locInfo) {
        range.locInfo = locInfo;
        assert(range.consumeCount === 0);
    } else {
        if (range.locInfo.last_line < locInfo.last_line || (range.locInfo.last_line === locInfo.last_line && range.locInfo.last_column < locInfo.last_column)) {
            range.locInfo.last_line = locInfo.last_line;
            range.locInfo.last_column = locInfo.last_column;
            if (locInfo.range) {
                assert(range.locInfo.range);
                assert(range.locInfo.range[1] <= locInfo.range[1]);
                assert(range.locInfo.range[1] <= locInfo.range[0]);
                range.locInfo.range[1] = locInfo.range[1];
            }
        }
        if (range.locInfo.first_line > locInfo.first_line || (range.locInfo.first_line === locInfo.first_line && range.locInfo.first_column > locInfo.first_column)) {
            range.locInfo.first_line = locInfo.first_line;
            range.locInfo.first_column = locInfo.first_column;
            if (locInfo.range) {
                assert(range.locInfo.range);
                assert(range.locInfo.range[0] <= locInfo.range[0]);
                assert(range.locInfo.range[1] <= locInfo.range[0]);
                range.locInfo.range[0] = locInfo.range[0];
            }
        }
    }
    range.consumeCount += consumeCount;
};

// THIS IS CALLED BY Visyond.Functions.__exec_wrapper in __support_functions.js

//e.g., gets {B4:A2,C7} and returns the values of [A2,B2,A3,B3,A4,B4,C7]
//e.g., Revenues[2011]:Revenues[2014], transforms into an array Cell IDs (e.g., [A2,B2,C2,D2]) and returns the values of the cells in the array
//
//Note: user can type B4:A2
//
// The `rangeSpec` parameter is expected to be an array, containing a series of CellRefRepresentation
// and BasicRangeRefRepresentation objects.
parser.getArrayValueOfCellRangeSpec = function(rangeSpec) {
    // In order to prevent double references in the range spec to be executed twice or more, we first collect
    // the set of referenced cells:
    var collection = new Uint8ClampedArray(global.MAX_GRID_ROW * global.MAX_GRID_COL);
    var rangesize = 0;
    for (var k = 0, len = rangeSpec.length; k < len; k++) {
        var spec = rangeSpec[k];
        // @GER, please note that when we call getArrayValueOfCellRangeSpec from outside the parser, spec has been reconstructed and is not an instance of the object anymore, hence I (GB) introduce alternate checks
        // assert(spec instanceof CellRefRepresentation);
        // assert(!(spec instanceof RangeRefRepresentation));

        // if (!(spec instanceof BasicRangeRefRepresentation)) {
        if (!spec.row2) {
            assert(spec.row !== -1);
            // regular cell ref acting like a 'range', e.g. `B7` or `{B7}`:
            rangesize++;
        } else if (spec.row === -1) {
            assert(spec.row2 === -1);
            // rangeref for a column set, e.g. `C:H`:
            //
            // get size of column(s) and use that to help calculate number of values...
            for (var j = spec.col; j <= spec.col2; j++) {
              // each column has its own set of cells, which' range we can find out here:
              var i = vGraph.getFirstPopulatedRowForCol(j);
              var i2 = vGraph.getLastPopulatedRowForCol(j);

              if (i !== false) {
                // the column actually has any cells in there!
                // WARNING: since we cannot yet depend on spec.workbookIndex to be valid,
                // we have to wing it because the next bit of alternative code which does *exact*
                // checking will FAIL.
                // However, since we know that a column has at least one cell, we can calculate the
                // *minimum* number of cells in the output set and use that... plus
                // the knowledge that assigning to out-of-range indexes in an array in JS
                // will automatically grow that array... at a (small) cost, however. Alas.
                if (1) {
                  rangesize++;   // hack!
                } else {
                  for (; i <= i2; i++) {
                    // check if cell exists at coordinate (i, j) and add it to the set
                    var checknode = vProject.getNodeWithCoords(i, j, this.workbookIndex);
                    if (checknode) {
                      rangesize++;
                    }
                  }
                }
              }
            }
        } else if (spec.col === -1) {
            assert(spec.col2 === -1);
            // rangeref for a row set, e.g. `3:7`:
            //
            // get size of row(s) and use that to help calculate number of values...
            for (var i = spec.row; i <= spec.row2; i++) {
              // each row has its own set of cells, which' range we can find out here:
              var j = vGraph.getFirstPopulatedColumnForRow(i);
              var j2 = vGraph.getLastPopulatedColumnForRow(i);

              if (j !== false) {
                // the row actually has any cells in there!
                // WARNING: since we cannot yet depend on spec.workbookIndex to be valid,
                // we have to wing it because the next bit of alternative code which does *exact*
                // checking will FAIL.
                // However, since we know that a row has at least one cell, we can calculate the
                // *minimum* number of cells in the output set and use that... plus
                // the knowledge that assigning to out-of-range indexes in an array in JS
                // will automatically grow that array... at a (small) cost, however. Alas.
                if (1) {
                  rangesize++;   // hack!
                } else {
                  for (; j <= j2; j++) {
                    // check if cell exists at coordinate (i, j) and add it to the set
                    var checknode = vProject.getNodeWithCoords(i, j, this.workbookIndex);
                    if (checknode) {
                      rangesize++;
                    }
                  }
                }
              }
            }
        } else {
            assert(spec.row !== -1);
            assert(spec.row2 !== -1);
            assert(spec.col !== -1);
            assert(spec.col2 !== -1);
            // regular range ref, e.g. `C3:H7`:

            // we need to make sure row < row2 and col < col2
            var sortedRowsCols = leftRightTopBottomSort(spec);
            rangesize += (sortedRowsCols.row2 - sortedRowsCols.row + 1) * (sortedRowsCols.col2 - sortedRowsCols.col + 1);
        }
    }
    var values = new Array(rangesize);
    var valindex = 0;
    for (var k = 0, len = rangeSpec.length; k < len; k++) {
        var spec = rangeSpec[k];
        // if (!(spec instanceof BasicRangeRefRepresentation)) {
        if (!spec.row2) {
            assert(spec.row !== -1);
            // regular cell ref acting like a 'range', e.g. `B7` or `{B7}`:
            var cellRef = spec.col + spec.row * global.MAX_GRID_COL;
            if (!collection[cellRef]) {
                collection[cellRef] = 1;
                spec.workbookIndex = spec.workbookIndex || getImplicitWBIdx();
                assert(spec.workbookIndex);
                values[valindex++] = getCellValueByRowColWS(spec.row, spec.col, spec.workbookIndex);
            }
        } else if (spec.row === -1) {
            assert(spec.row2 === -1);
            // rangeref for a column set, e.g. `C:H`:
            for (var j = spec.col; j <= spec.col2; j++) {
              // each column has its own set of cells, which' range we can find out here:
              var i = vGraph.getFirstPopulatedRowForCol(j);
              var i2 = vGraph.getLastPopulatedRowForCol(j);

              if (i !== false) {
                // the column actually has any cells in there!
                for (; i <= i2; i++) {
                    // check if cell exists at coordinate (i, j) and add it to the set
                    var checknode = vProject.getNodeWithCoords(i, j, this.workbookIndex);
                    if (checknode) {
                        var cellRef = i * global.MAX_GRID_COL + j;
                        if (!collection[cellRef]) {
                            collection[cellRef] = 1;
                            spec.workbookIndex = spec.workbookIndex || getImplicitWBIdx();
                            assert(spec.workbookIndex);
                            values[valindex++] = getCellValueByRowColWS(i, j, spec.workbookIndex);
                        }
                    }
                }
              }
            }
        } else if (spec.col === -1) {
            assert(spec.col2 === -1);
            // rangeref for a row set, e.g. `3:7`:
            for (var i = spec.row; i <= spec.row2; i++) {
              // each row has its own set of cells, which' range we can find out here:
              var j = vGraph.getFirstPopulatedColumnForRow(i);
              var j2 = vGraph.getLastPopulatedColumnForRow(i);

              if (j !== false) {
                // the column actually has any cells in there!
                for (; j <= j2; j++) {
                    // check if cell exists at coordinate (i, j) and add it to the set
                    var checknode = vProject.getNodeWithCoords(i, j, this.workbookIndex);
                    if (checknode) {
                        var cellRef = i * global.MAX_GRID_COL + j;
                        if (!collection[cellRef]) {
                            collection[cellRef] = 1;
                            spec.workbookIndex = spec.workbookIndex || getImplicitWBIdx();
                            assert(spec.workbookIndex);
                            values[valindex++] = getCellValueByRowColWS(i, j, spec.workbookIndex);
                        }
                    }
                }
              }
            }
        } else {
            assert(spec.row !== -1);
            assert(spec.row2 !== -1);
            assert(spec.col !== -1);
            assert(spec.col2 !== -1);
            // regular range ref, e.g. `C3:H7`:

            // create the array of cells

            // we need to make sure row < row2 and col < col2
            var sortedRowsCols = leftRightTopBottomSort(spec);
            rangesize += (sortedRowsCols.row2 - sortedRowsCols.row + 1) * (sortedRowsCols.col2 - sortedRowsCols.col + 1);

            for (var i = sortedRowsCols.row; i <= sortedRowsCols.row2; i++) {
                var rowstep = i * global.MAX_GRID_COL;
                for (var j = sortedRowsCols.col; j <= sortedRowsCols.col2; j++) {
                    var cellRef = j + rowstep;
                    if (!collection[cellRef]) {
                        collection[cellRef] = 1;
                        spec.workbookIndex = spec.workbookIndex || getImplicitWBIdx();
                        assert(spec.workbookIndex);
                        values[valindex++] = getCellValueByRowColWS(i, j, spec.workbookIndex);
                    }
                }
            }
        }
    }
    // and redimension the array once so that the receiver gets a nice, clean, array of cell values.
    values.length = valindex;
    return values;
};






/*
 * Return TRUE if all AST nodes in the arglist collection (an array) are constants.
 *
 * Otherwise return FALSE.
 */
parser.isEntireArgListConstant = function (arglist) {
    var i,
        l = arglist.length;
    for (i = 0; i < l; l++) {
        if (!arglist[i].constant) {
            return false;
        }
    }
    return true;
};


/*
 * Return the UNIT of the arglist collective: when all have the same UNIT, it is that.
 *
 * Otherwise it is `FU_ANY` as we cannot say how these AST nodes combine (`SUM`/`AVG`/`MULTIPLY`/...).
 */
parser.determineArgListUnit = function (arglist) {
    var i, u, l = arglist.length;
    if (!l) {
        return FU_ANY;
    }
    u = arglist[0].unit;
    for (i = 1; i < l; l++) {
        if (arglist[i].unit != u) {
            return FU_ANY;
        }
    }
    return u;
};


/*
 * Decode cell references such as `A5` when these are entered in input fields, etc.
 *
 * This performs a regular parse and then makes sure that the parsed 'formula' is actually
 * a single, valid, cell reference and returns the corresponding AST object.
 *
 * When the entered content is NOT a valid cell reference, an exception (error message) is thrown.
 */
parser.parseCellReference = function (input) {
    this.parse_mode = FPM_CELLREF;
    var ast;

    try {
        ast = this.parse(input);
    }
    finally {
        this.parse_mode = FPM_FORMULA;
    }

    if (typeof ast !== "undefined" && ast.opcode == FKW_CELLREF) {
        return ast;
    }

    throw new Error(input + " is not a valid cell reference");
};


/*
 * Decode cell range references such as `A5:C7` when these are entered in input fields, etc.
 *
 * This performs a regular parse and then makes sure that the parsed 'formula' is actually
 * a single, valid, range reference and returns the corresponding AST object.
 *
 * When the entered content is NOT a valid range reference, an exception (error message) is thrown.
 */
parser.parseRangeReference = function (input) {
    this.parse_mode = FPM_RANGEREF;
    var ast;

    try {
        ast = this.parse(input);
    }
    finally {
        this.parse_mode = FPM_FORMULA;
    }

    if (typeof ast !== "undefined" && ast.opcode == FKW_RANGEREF) {
        return ast;
    }

    throw new Error(input + " is not a valid range reference");
};


/*
 * Decode the input expression and 'fold' it into a single value, i.e. calculate its present value.
 *
 * This performs a regular parse and then makes sure that the parsed 'formula' is 'folded'
 * into a single (numeric / string / boolean) value and returns the corresponding AST object.
 *
 * When the entered content is NOT a valid immediate value expression, an exception (error message) is thrown.
 */
parser.parseValue = function (input) {
    this.parse_mode = FPM_IMMEDIATE_VALUE;
    var ast;

    try {
        ast = this.parse(input);
    }
    finally {
        this.parse_mode = FPM_FORMULA;
    }

    if (typeof ast !== "undefined" && ast.opcode == FKW_VALUE) {
        return ast;
    }

    throw new Error(input + " is not a valid value expression");
};


/*
 * Remove duplicated quotes (of the form `quote_str + quote_str`, e.g. `""`) from the input string.
 */
parser.dedupQuotedString = function (str, quote_str) {
    return str.replace(quote_str + quote_str, quote_str);
};


// Would it be a viable basic column identifier?
parser.isValidColumnID = function (s) {
    var col;
    var match;

    if (s.length <= global.MAX_GRID_COL_ID_LENGTH) {
        s = s.toUpperCase();
        match = s.match(/^[A-Z]+$/);
        if (match) {
            // check if this is a legal column id:
            col = colLetterToNumber(s);
            assert(col === false || assertGraphCol(col));
            if (col >= 1 && col <= global.MAX_GRID_COL) {
                return col;
            }
        }
    }
    return false;
};


// Would it be a viable basic row identifier?
parser.isValidRowID = function (s) {
    var row;
    var match;

    if (s.length <= global.MAX_GRID_ROW_ID_LENGTH) {
        s = s.toUpperCase();
        match = s.match(/^[0-9]+$/);
        if (match) {
            // check if this is a legal column id:
            row = parseInt(s);
            if (row >= 1 && row <= global.MAX_GRID_ROW) {
                return row;
            }
        }
    }
    return false;
};




// Would it be a viable cell reference?
parser.isValidCellRef = function (s) {
    var rv = cellLabelWithDollarToRowColWorkbook(s, {
        fireEventOnError: false
    });
    return rv;
};




// Would it be a viable cell range reference?
parser.isValidCellRange = function (s) {
    var rv = rangeLabelWithDollarToRowColWorkbook(s, {
        fireEventOnError: false
    });
    return rv;
};



/*
 * Return the definition structure for the given symbol name, or FALSE when the symbol is unknown.
 *
 * The definition structure contains these elements:
 *
 * - token
 * - defined_value
 */

parser.getSymbol4Function = function (name) {
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.functions);
    var rv = this._symbol2token_lookup_table.functions[name];
    if (rv && rv.quality < vUserPreferences.quality) {
        return false;
    }
    return rv || false;
};

parser.getSymbol4DefinedConstant = function (name, mandatory_category_bits) {
    mandatory_category_bits |= 0;
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.constants);
    var rv = this._symbol2token_lookup_table.constants[name];
    if (rv && rv.quality < vUserPreferences.quality) {
        return false;
    }
    if (rv && (rv.category & mandatory_category_bits) !== mandatory_category_bits) {
        return false;
    }
    return rv || false;
};

parser.getSymbol4Currency = function (name) {
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.currencies);
    var rv = this._symbol2token_lookup_table.currencies[name];
    if (rv && rv.quality < vUserPreferences.quality) {
        return false;
    }
    /*
     * output structure:
     *
     * - notation: FKA constant
     * - prefix:   string (optional; required for currencies which are not hard-coded FKA notation constants)
     */
    return rv || false;
};

parser.getJSONfilterSymbol = function (name) {
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.json_filter_functions);
    var rv = this._symbol2token_lookup_table.json_filter_functions[name];
    return rv || false;
};

parser.getSymbol4RowOrColumnName = function (name) {
    var rv = this.getSymbol4RowName(name);
    if (!rv) {
        rv = this.getSymbol4ColumnName(name);
        if (rv) {
            assert(rv.col >= 1);
            assert(rv.provides === NRA_COLUMN);
            return rv;
        }
        return false;
    } else {
        assert(rv.row >= 1);
        assert(rv.provides === NRA_ROW);
        return rv;
    }
};

parser.getSymbol4RowName = function (name) {
    var rv = vGraph.getRowOfLabel(name);
    if (rv) {
        return {
            row: rv,
            provides: NRA_ROW
        };
    }
    return false;
};

parser.getSymbol4ColumnName = function (name) {
    var rv = vGraph.getColOfLabel(name);
    if (rv) {
        return {
            col: rv,
            provides: NRA_COLUMN
        };
    }
    return false;
};

parser.getSymbol4CellRef = function (name) {
    var rv = vGraph.getCellOfLabel(name);
    if (rv) {
        return {
            col: rv.col,
            row: rv.row,
            provides: NRA_COLUMN | NRA_ROW
        };
    }
    return false;
};


/*
 * Initialize the symbol lookup tables.
 */
parser.initSymbolTable = function (custom_symbols) {
    this._symbol2token_lookup_table = {
        functions: {},                  // hash table ~ dictionary
        constants: {},                  // hash table ~ dictionary
        currencies: {},                 // hash table ~ dictionary
        json_filter_functions: {}       // hash table ~ dictionary
    };

    // first set up the default symbols: constants, etc.; once that is done, register the custom symbols:
    this.addSymbols(get_predefined_formula_constants(), FSC_PREDEFINED_CONSTANT);
    this.addSymbols(get_predefined_formula_currencies(), FSC_CURRENCY);
    this.addSymbols(get_predefined_formula_functions(), FSC_FUNCTION);

    return this.addSymbols(custom_symbols);
};


/*
 * Register one or more symbols in the symbol lookup tables:
 */
parser.addSymbols = function (symbols, default_category) {
    var s, category, name, done, node, alts, k;

    for (var i = 0, len = symbols.length; i < len; i++) {
        s = symbols[i];

        // ignore symbols which are not enabled / suitable for the current quality level:
        if (s.quality < vUserPreferences.quality) {
            continue;
        }

        category = s.category || default_category;
        done = 0;
        if (category & FSC_FUNCTION) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.functions[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_PREDEFINED_CONSTANT) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.constants[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_CURRENCY) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.currencies[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_CELL_LABEL) {
            vGraph.setCellLabel(s.col, s.row, s.name);
            ++done;
        }
        if (category & FSC_COLUMN_LABEL) {
            vGraph.setColLabel(s.col, s.name);
            ++done;
        }
        if (category & FSC_ROW_LABEL) {
            vGraph.setRowLabel(s.row, s.name);
            ++done;
        }
        if (category & FSC_JSON_FILTER_FUNCTION) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.json_filter_functions[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_CELL_VALUE_PRESET) {
            // WARNING: this category is really here to assist the unit tests; in actual use, this is never expected to be invoked!
            node = vGraph.createBlankNode(s.row, s.col);
            assert(node, "Old vs New: createBlankNode does not always create node anymore when collaborator");

//            node.formula = "" + s.value;
            node.value = s.value;
            vProject.addNode(node, node.value);
            ++done;
        }
        if (!done) {
            //console.log("symbol [" + s.name + "] does not belong in any category: ", i, s, category);
            throw new Error("symbol [" + s.name + "] does not belong in any category");
        }
    }
    return this;
};




/*
 * Store the current comment which has terminated and needs to be stored until the next token is produced by the lexer.
 */
parser.pushComment = function () {
    var lexer = this.lexer;

    // a la pastInput():
    var past = lexer.matched.substr(0, this.matched.length - this.match.length);
    var startloc = lexer.inline_comment_start_yylloc.ranges[1]; // pick the offset beyond the comment-start marker!
    past = past.substr(startloc);
    // strip surrounding whitespace:
    // http://jsperf.com/javascript-trim-string/2
    past = past.trim();

    var node = new Visyond.FormulaParser.inlineComment(FKW_INLINE_COMMENT, lexer.inline_comment_start_yylloc, past);
    this.comments.push(node);
    return this;
};


/*
 * Return the array of comments when there are any, otherwise return FALSE.
 *
 * Also empty the comment store.
 */
parser.popComments = function () {
    var rv = this.comments;
    this.clearComments();
    if (typeof rv !== "undefined" && rv.length > 0) {
        return rv;
    } else {
        return false;
    }
};


/*
 * Clear / (re-)initialize the comments' store.
 */
parser.clearComments = function () {
    this.comments = [];
    return this;
};


/*
 * Return the index to the next available slot in the comment store.
 *
 * Consequently returns 0 when the comment store is empty.
 */
parser.getNextCommentIndex = function () {
    var rv = this.comments;
    if (typeof rv !== "undefined" && rv.length > 0) {
        return rv.length;
    } else {
        return 0;
    }
};


parser.pre_parse = function (yy) {
    //console.log("parser init", this, arguments);

    /*
     * The 'init phase' is always invoked for every parse invocation.
     *
     * At this point in time, nothing has happened yet: no token has
     * been lexed, no real statement has been parsed yet.
     *
     * Incidentally, we also use this moment in time to reset the
     * 'inline comments' monitor: depending on the `options.inline_comments_mode`
     * setting do we allow inline comments
     *
     *  - always,
     *  - only after the "=" starting the formula, or
     *  - never
     *
     * The grammar has been constructed such that this rule can be
     * resolved without any look-ahead, thanks to a 'default action'.
     */
    //yy.lexer.options.backtrack_lexer = true;
    //yy.lexer.options.ranges = true;             // required for the inline comments to work as the start location is tracked via the `yylloc.range[]`
    yy.lexer.options.inline_comment_mode = yy.inline_comment_mode | 0;

    if (yy.lexer.options.inline_comment_mode < 2) {
        yy.lexer.inline_comments_monitor = 0; // for `mode=1` comment support will be enabled as soon as we encounter a `=`
    } else {
        yy.lexer.inline_comments_monitor = yy.lexer.options.inline_comment_mode + 1;
    }

    // and make sure the comments store is prepped:
    yy.parser.clearComments();

    // and init the symbol tables if the caller didn't do so already (we do this in order to prevent undesirable crashes)
    if (typeof yy.parser._symbol2token_lookup_table === "undefined") {
        yy.parser.initSymbolTable([]);
    }

    /*
     * Depending on parser mode we must push a 'magick marker' into the lexer stream
     * which is a hack offering a working alternative to having the parser generator
     * support multiple %start rules.
     */
    yy.lexer.pushState('PARSE_MODE_DETECTION');
    switch (yy.parser.parser_mode) {
    default:
        break;

    case FPM_CELLREF:
        yy.lexer.unput("\u0001");
        break;

    case FPM_RANGEREF:
        yy.lexer.unput("\u0002");
        break;

    case FPM_IMMEDIATE_VALUE:
        yy.lexer.unput("\u0003");
        break;
    }
};







// Return FALSE on success, return object containing both index number of argument which mismatched the spec + minimal error report
//
// break_on_severity_level: when set, it determines whether this validation function will break on the first WARNING (-1/false) or ERROR (+1/true)
parser.passingArgumentSetValidation = function (opcode, args_array, break_on_severity_level) {
    // opcode is a reference to the object

    break_on_severity_level |= 0;
    break_on_severity_level--;          // FALSE --> -1 // TRUE --> 0

    // console.log("opcode.parameter_set_definition from passingArgumentSetValidation: ",opcode.parameter_set_definition);
    // console.log("args_array from passingArgumentSetValidation: ",args_array);

    var arg_def_set = opcode.parameter_set_definition;
    var alen, dlen, ai, di, dt, at, i;
    var basic_type, dotdotdot, coerce;
    var oki;

    alen = args_array.length;
    dlen = arg_def_set.length;

    // example: [FAX_NUMBER | FAX_COERCE | FAX_DOTDOTDOT]

    // check each incoming argument against the function interface specification:
    di = 0;
    for (ai = 0; ai < alen; ai++) {
        if (di >= dlen) {
            // We ran out of argument specs early: apparently we received more function arguments than is legally allowed!
            return {
                severity: 1,         // ERROR > 0
                index: ai,
                spec_index: di,
                spec_bits: null,
                is_user_failure: true,
                message: "Argument #" + (ai + 1) + " is superfluous and ignored by the function"
            };
        }
        dt = arg_def_set[di]; // FAX_... bits defining the expected argument type.
        // extract basic type and option bits:
        basic_type = (dt & FAX_ANY);
        optional = (dt & FAX_OPTIONAL);
        dotdotdot = (dt & FAX_DOTDOTDOT);
        coerce = (dt & FAX_COERCE);

        at = typeof args_array[ai];
        // TODO: fix this code so it works out for COUNTIF() et al: those have FAX_DOTDOTDOT followed by 'trailing' argument(s) in the spec!
        /*
         * Nasty: two ways to invoke COUNTIF() et al as Excel formula expressions:
         *
         * **Edit: NOT TRUE -- > EXCEL DOES NOT ALLOW TO INVOKE THEM LIKE THE BELOW, ONLY RANGE AND CONDITION**
         *
         * =COUNTIF(A1, A2, A3, A4, A5, ">0");
         * -->
         * =COUNTIF(1, 2, 3, 4, 5, ">0");
         * i.e. args_array.length = 6
         *
         * =COUNTIF(A1:A5, ">0");
         * -->
         * =COUNTIF([1, 2, 3, 4, 5], ">0");
         * i.e. args_array.length = 2
         */

        di++;

        if (dotdotdot) {
            // when the spec announces it expects an arbitrary number of arguments like this one,
            // we do NOT increment the spec index as the next argument must be matched against the same
            // spec entry.
            di--;
        }

        if (optional) {
            // argument is allowed to not be present, i.e. may be undefined/null(=empty). E.g. 2nd arg for "IF(cond,,false_value)"
            if (at === 'undefined' || args_array[ai] === null) {
                continue;
            }
        }
        // when the spec announces the argument will be coerced to some type(s), we currently accept ANYTHING!
        if (coerce) {
            continue;
        }
        // when the argument may be anything, we're down with that too!
        if (basic_type === FAX_ANY) {
            continue;
        }

        // basic_type is a bitfield itself, so check argument type against the bits:
        switch (at) {
        case 'undefined':
            // that's unexpected: we only get here when the argument is NOT OPTIONAL.
            // ... and 'undefined' is NOT identical to 'empty' ...
            return {
                severity: 1,         // ERROR > 0
                index: ai,
                spec_index: di,
                spec_bits: dt,
                is_user_failure: false,
                message: "Argument #" + (ai + 1) + " is unexpectedly empty/undefined; was expecting " + parser.describeFAXbits(dt)
            };

        case 'boolean':
            if (!(basic_type & FAX_BOOLEAN)) {
                oki = {
                    severity: -1,         // WARNING < 0
                    index: ai,
                    spec_index: di,
                    spec_bits: dt,
                    is_user_failure: false,
                    message: "Argument #" + (ai + 1) + " is a boolean, which will not be coerced; was expecting " + parser.describeFAXbits(dt)
                };
                if (break_on_severity_level <= oki.severity) return oki;
            }
            continue;

        case 'string':
            if (!(basic_type & FAX_STRING)) {
                // When we don't accept a string input, we may still accept something similar: a DATE
                // (Side note: we 'know' that FAX_COMPLEX_NUMBER = FAX_STRING so we don't go and check for FAX_COMPLEX_NUMBER separately here!)
                if (!(basic_type & FAX_DATE)) {
                    oki = {
                        severity: -1,         // WARNING < 0
                        index: ai,
                        spec_index: di,
                        spec_bits: dt,
                        is_user_failure: false,
                        message: "Argument #" + (ai + 1) + " is a string, which will not be coerced; was expecting " + parser.describeFAXbits(dt)
                    };
                    if (break_on_severity_level <= oki.severity) return oki;
                }
                // When we allow a date, we now assume ANY string will correctly coerce into a valid date.
                // We do know this is a very fast and off-handed (and WRONG) approach, but we want speed over accuracy for now...
            }
            continue;

        case 'number':
            if (!(basic_type & FAX_NUMBER)) {
                // When we don't accept a numeric input, we may still accept something similar: a DATE
                if (!(basic_type & FAX_DATE)) {
                    oki = {
                        severity: -1,         // WARNING < 0
                        index: ai,
                        spec_index: di,
                        spec_bits: dt,
                        is_user_failure: false,
                        message: "Argument #" + (ai + 1) + " is a number, which will not be coerced; was expecting " + parser.describeFAXbits(dt)
                    };
                    if (break_on_severity_level <= oki.severity) return oki;
                }
                // When we allow a date, we now assume ANY number will correctly coerce into a valid date.
                // We do know this is a very fast and off-handed (and WRONG) approach, but we want speed over accuracy for now...
            }
            continue;

        default:
            // If the given argument is an array or NULL we arrive here.
            // NULL **MAY** be a result from an earlier parse error (#VALUE or some such, maybe?)
            // so we need to differentiate between NULL and 'the rest of 'em':
            if (args_array[ai] === null) {
                if (!(basic_type & FAX_VOID)) {
                    // This is pretty darn illegal as it's the same to us as 'undefined':
                    return {
                        severity: 1,         // ERROR > 0
                        index: ai,
                        spec_index: di,
                        spec_bits: dt,
                    is_user_failure: false,
                        message: "Argument #" + (ai + 1) + " is null/empty/undefined; was expecting " + parser.describeFAXbits(dt)
                    };
                } else {
                    // This function accepts a `(void)` parameter, i.e. this function accepts *zero* arguments:
                    assert(ai === 0);
                    assert(alen === 1);
                    continue;
                }
            }
            // 'the rest of 'em': RANGEREF, CELLREF, etc. will only show up as-is in the AST grammar;
            // here they have been 'expanded' in value arrays already.
            // For simplicity, we simply accept any of those when the function argument is an array/object/non-basic-JS-type:
            if (!(basic_type & (FAX_DATASET | FAX_COLREF | FAX_ROWREF | FAX_CELLREF | FAX_RANGEREF))) {
                oki = {
                    severity: -1,         // WARNING < 0
                    index: ai,
                    spec_index: di,
                    spec_bits: dt,
                    is_user_failure: false,
                    message: "Argument #" + (ai + 1) + " is of incorrect type; was expecting " + parser.describeFAXbits(dt)
                };
                if (break_on_severity_level <= oki.severity) return oki;
            }
            continue;
        }
    }

    if (di < dlen) {
        // Fewer arguments were passed than strictly required. Or is it? (FAX_OPTIONAL / FAX_DOTDOTDOT)
        //
        // It is only OKAY when
        // - ALL missing arguments are FAX_OPTIONAL
        // - this argument is FAX_DOTDOTDOT **AND** no further 'trailing' arguments are expected (COUNTIF()!!!)

        dt = arg_def_set[di]; // FAX_... bits defining the expected argument type.
        // extract basic type and option bits:
        basic_type = (dt & FAX_ANY);
        optional = (dt & FAX_OPTIONAL);
        dotdotdot = (dt & FAX_DOTDOTDOT);
        coerce = (dt & FAX_COERCE);

        if (optional) {
            // We MAY omit this argument, but then we should also be allowed to omit the subsequent ones,
            // otherwise this FAX_OPTIONAL would've been caught inside the for() loop above!
            for (i = di + 1; i < dlen; i++) {
                if (!(arg_def_set[i] & FAX_OPTIONAL)) {
                    // any NON-optional argument following us means we are at fault already!
                    return {
                        severity: 1,         // ERROR > 0
                        index: ai,
                        spec_index: i,
                        spec_bits: arg_def_set[i],
                        is_user_failure: true,
                        message: "Incorrect number of arguments; you did not specify a required argument"
                    };
                }
            }
            // It turns out this argument and all following it are optional, so we're good to go!
        } else if (dotdotdot) {
            // no more /specified/ arguments after this one allowed, because we don't have any more to offer!
            if (di + 1 < dlen) {
                return {
                    severity: 1,         // ERROR > 0
                    index: ai,
                    spec_index: di,
                    spec_bits: dt,
                    is_user_failure: true,
                    message: "Incorrect number of arguments; you did not specify the trailing arguments"
                };
            }
            // We're the last spec entry, so we're good to go!
        } else {
            // We have checked all given function arguments, yet still have some unmatched argument specs, which are NON-OPTIONAL.
            // This means the user didn't provide all the required arguments!
            return {
                severity: 1,         // ERROR > 0
                index: ai,
                spec_index: di,
                spec_bits: dt,
                is_user_failure: true,
                message: "Incorrect number of arguments; you did not specify one or more required arguments"
            };
        }
    }

    return false;
};


parser.describeFAXbits = function (t) {
    var s, b, v, d, c, o;

    t |= 0;
    b = (t & FAX_ANY);
    v = (t & FAX_VOID);
    o = (t & FAX_OPTIONAL);
    c = (t & FAX_COERCE);
    d = (t & FAX_DOTDOTDOT);

    if (b === FAX_ANY) {
        s = "(anything)";
    } else if (v) {
        s = "(void)";
    } else {
        assert(b != 0);
        s = "(";
        if (b & FAX_NUMBER) {
            s += "number";
        }

        // tricky: we 'know' the FAX_COMPLEX_NUMBER only shows up in the spec when it is FAX_NUMBER | FAX_COMPLEX_NUMBER, i.e. FAX_NUMBER | FAX_STRING:
        if ((FAX_NUMBER | FAX_STRING | FAX_COMPLEX_NUMBER) === (b & (FAX_NUMBER | FAX_STRING | FAX_COMPLEX_NUMBER))) {
            if (s) s += ",";
            s += "complex";
        }

        if (b & FAX_DATE) {
            if (s) s += ",";
            s += "date";
        }
        if (b & FAX_BOOLEAN) {
            if (s) s += ",";
            s += "boolean";
        }
        if (b & FAX_STRING) {
            if (s) s += ",";
            s += "string";
        }
        if (b & FAX_DATASET) {
            if (s) s += ",";
            s += "dataset";
        }
        if (b & FAX_COLREF) {
            if (s) s += ",";
            s += "columnREF";
        }
        if (b & FAX_ROWREF) {
            if (s) s += ",";
            s += "rowREF";
        }
        if (b & FAX_CELLREF) {
            if (s) s += ",";
            s += "cellREF";
        }
        if (b & FAX_RANGEREF) {
            if (s) s += ",";
            s += "rangeREF";
        }

        s += ")";
    }

    if (c) {
        s += "*";
    }

    if (d) {
        s += "...";
    }

    if (o) {
        s = "[" + s + "]";
    }

    return s;
};






// CellRef class which is going to be schlepped around as if it were a kind-of-native *value*, a bit like the #ERROR class instances
// which help us propagate and properly *calculate* when there's a calculus #ERROR in a user formula.
//
// The key idea here is that the class should propagate as much as possible, but be *automatically* coerced to a native value when
// it encounters a calculation such as the basic summation in `A1 + 1`: here `A1` is considered/expected to represent its *cell value*,
// while another formula like `ADDRESS(A1)` expects the `A1` to represent its *cell reference coordinates* i.e. the *cell node reference*.
//
// Using JavaScript auto-coercion through .valueOf() et al, we can create augmented 'value objects' like this one and have them act as
// basic numeric or string values where the need arrises without complicating/cluttering/slowing down(!) calculus activities as we don't
// have to add if(...) checks everywhere to see if we have a special object or a native value before we perform the actual bit of calculus.
//
// Note: of course a proper formula compiler can perform type prediction and generate the appropriate type conversion code, but we don't
// have a proper compiler yet, so this last point is currently 'glorious future'.
//
var CellRefRepresentation = function (yytext) {
    var rowColumn = cellLabelWithDollarToRowColWorkbook(yytext);

    // check if cell is within grid space
    this.faulty = !rowColumn;

    if (!this.faulty) {
        this.row = rowColumn.row;
        this.col = rowColumn.col;
        this.fixed_row = rowColumn.fixed_row;
        this.fixed_col = rowColumn.fixed_col;
	    this.workbookIndex = rowColumn.workbookIndex;
        this.source = rowColumn.source;

        // don't bother collecting precedents when we're recalculating:
        if (!recalcValueOnly) {
            if (!this.source) {
                addCellNameToPrecedents(this);
            }
        }
    }

    this.locInfo = null;
    this.consumeCount = 0;
};

// Automatically invoked by the JS engine 99.9% of the time, i.e. when this object is confronted with a
// math operator such as `+` or `*`. The remaining 0.1% shall have to be handled manually, i.e. by
// *explicitly* invoking this method.
CellRefRepresentation.prototype.valueOf = function () {
    var cellValue;

    if (this.faulty) {
        return Number.NaN;
    }

    if (!this.source) {
        var node = vProject.getNodeWithCoords(this.row, this.col, this.workbookIndex);
        if (node) {
            cellValue = node.getValue();
        } else {
            cellValue = ""; // by default, if cell does not have a value or content is a string
        }
    } else {
        cellValue = getExternalReferenceValue(this);
    }

    return cellValue;
};

CellRefRepresentation.prototype.toString = function () {
    // return "YOU'RE BUGGERED. PROBABLY VALUE NEEDED?";
    var cellValue;

    if (this.faulty) {
        return Number.NaN;
    }

    if (!this.source) {
        var node = vProject.getNodeWithCoords(this.row, this.col, this.workbookIndex);

        if (node) {
            cellValue = node.getValue();
        } else {
            cellValue = ""; // by default, if cell does not have a value or content is a string
        }
    } else {
        cellValue = getExternalReferenceValue(this);
    }

    return cellValue;
};

// iterate over the single cell and invoke callback, returning the value it produced.
//
// Note: this method is available for the CellRef to ensure that all CellRef/RangeRef instances
// share this method in their API; this greatly simplifies the implementation of the API for
// the RangeRefRepresentation class.
CellRefRepresentation.prototype.traverseRange = function (callback, errorCallback) {
    if (this.faulty) {
	    errorCallback({
	    	msg: "Invalid cell reference",
	    	invalidCellReference: true
	    });
	    return false;
	} else {
		return callback(this.row, this.col, this.workbookIndex);
	}
};





// -------------------------------------------------------------------------------------------------------

// Ditto as for CellRefRepresentation...
//
// BasicRangeRef is a class which represents simple `A1:C3` range references;
// RangeRefRepresentation o.t.o.h. (which is another class!) is then meant to
// *collect* the set of cellrefs and (basic) rangerefs that together constitute
// a 'fragmented range' a la `{A1,C3:C7,D4}` -- and any of the others.
//
// BasicRangeRefRepresentation only serves INSIDE the parser and should never get
// out as-is.
  var BasicRangeRefRepresentation = function(yytext) {
    var rowColumn = rangeLabelWithDollarToRowColWorkbook(yytext);

    // check if cell is within grid space
    this.faulty = !rowColumn;

    if (!this.faulty) {
      this.row = rowColumn.row;
      this.col = rowColumn.col;
      this.fixed_row = rowColumn.fixed_row;
      this.fixed_col = rowColumn.fixed_col;
      this.row2 = rowColumn.row2;
      this.col2 = rowColumn.col2;
      this.fixed_row2 = rowColumn.fixed_row2;
      this.fixed_col2 = rowColumn.fixed_col2;
      this.workbookIndex = rowColumn.workbookIndex;
      this.source = rowColumn.source;

      // don't bother collecting precedents when we're recalculating:
      if (!recalcValueOnly) {
        if (!this.source) {
          if (this.row === -1) {
            // WARNING: we're looking at a column set regangeref, e.g. `C:H`.
            // Make sure to grab all the cells in each of these columns in this
            // expansion loop!
            for (j = this.col; j <= this.col2; j++) {
              // each column has its own set of cells, which' range we can find out here:
              i = vGraph.getFirstPopulatedRowForCol(j);
              var i2 = vGraph.getLastPopulatedRowForCol(j);

              if (i !== false) {
                // the column actually has any cells in there!
                for (; i <= i2; i++) {
                  // Sideline story:
                  //
                  // Suppose we have a grid like this:
                  //
                  //
                  // C1 C2              C7
                  //             D5 D6
                  // E1
                  // F1    F3
                  // G1                    G8
                  //
                  // and add a formula with the `C:H` rangeref in it somewhere in cell J1.
                  //
                  // We CHOOSE (management / design decision) to not mark any not-yet-existing
                  // cells as yellow and create nodes for them, as we would for `SUM(C1:H8)`
                  // because `SUM(C:H)` would be spanning *thousands* of cells in columns
                  // C to H.
                  // This causes a few problems for us, because now J1 won't be automatically
                  // known as a *dependent* for cell C3 when we later insert a formula there!
                  //
                  // There are few fundamental solution approaches for this problem:
                  //
                  // 1: add J1 to a queue or list of 'cells with special ranges' and then when
                  //    *any* cell is *created* (cell updates don't matter! ;-) ) the cell
                  //    create process must go through that queue/list to rescan every cell
                  //    formula in there to ensure those cells get their *precedents* updated.
                  //
                  // 2: we introduce *dependents* tracking for columns and rows, so that on
                  //    *adding* another cell, say C3, we can have its creation process query
                  //    column C and row 3 to deliver a set (possibly empty) of known-dependent
                  //    cells like J1. The trouble with this solution is that dragging/swapping
                  //    etc. activities now need to update another coordinate-based storage:
                  //    the column and row tracking objects.
                  //    Another disadvantage of this solution is that we currently only get
                  //    our *dependents* *indirectly through our precedent set* and this approach
                  //    *reverses* that principle of internal causality: now we have to start
                  //    with a set of *dependents* and work back from those to update thei
                  //    *precedents* (J1 being a registered dependent of column C and C3 being
                  //    the new precedent of column C -> J1)
                  //
                  // 3: we can also be *very lazy* and choose not to do anything at all.
                  //    This doesn't sound like a solution, but it is, at a fundamental level at least.
                  //    Here the consequence is that cell J1 will only get updated (recalculated)
                  //    when it does a rescan of the C:H range due to it being edited or
                  //    recalced. The latter can happen when another cell which has J1 in its
                  //    precedent list is being recalced: the DFS will than visit J1 and that
                  //    visit (assuming J1 is marked like OFFSET et al: special treatment required)
                  //    can trigger a precedents set refresh, which will then add C3 to the list.
                  //    Of course this can happen any (long) arbitrary time after C3 was added
                  //    so users will et confused: "when do I see the update in J1 now that I
                  //    added C3?"
                  // 3-part B:
                  //    To cover for that user question, a solution might be to 'scan the area',
                  //    i.e. periodically iterate over the visible grid (visible? - then you won't see J1
                  //    if it's outside visible range, but only indirectly involved!)
                  //    Any cells found marked as 'requires special treatment' during such a scan
                  //    would then get processed thus updating J1 after a while.
                  //
                  // Solution 3/B looks a lot like solution 1, except that it is now a statistical
                  // approach instead of a guaranteed action, hence J1 updates will sometimes
                  // take a while before becoming visible with 3/B. The question still remaining
                  // (as of this writing) is: which solution do we pick and if 3/B, can we live
                  // with the 'slow update of the rest of the grid' potential consequence as that
                  // statistical approach will sometimes be fast and nice and sometimes slow and late.
                  //
                  // ----
                  //
                  // Now, since we only add *existing cells* to our set, contrary to our handling
                  // of `C1:H8` ranges (see further below) we MUST check first if the given
                  // row/col position IS an existing cell?

                  var checknode = vProject.getNodeWithCoords(i, j, this.workbookIndex);
                  if (checknode) {
                      addCellNameToPrecedents({
                        row: i,
                        col: j,
                        workbookIndex: this.workbookIndex,
                        fixed_row: this.fixed_row,
                        fixed_col: this.fixed_col
                      });
                  }
                }
              }
            }
          } else if (this.col === -1) {
            // WARNING: we're looking at a row set rangeref, e.g. `1:8`.
            // Make sure to grab all the cells in each of these rows in this
            // expansion loop!
            for (i = this.row; i <= this.row2; i++) {
              // each row has its own set of cells, which' range we can find out here:
              j = vGraph.getFirstPopulatedColumnForRow(i);
              var j2 = vGraph.getLastPopulatedColumnForRow(i);

              if (j !== false) {
                // the row actually has any cells in there!
                for (; j <= j2; j++) {
                  // Now, since we only add *existing cells* to our set, contrary to our handling
                  // of `C1:H8` ranges (see further below) we MUST check first if the given
                  // row/col position IS an existing cell?

                  var checknode = vProject.getNodeWithCoords(i, j, this.workbookIndex);
                  if (checknode) {
                      addCellNameToPrecedents({
                        row: i,
                        col: j,
                        workbookIndex: this.workbookIndex,
                        fixed_row: this.fixed_row,
                        fixed_col: this.fixed_col
                      });
                  }
                }
              }
            }
          } else {
            // business as usual: we have to expand a range like `C1:H8`:
            for (i = this.row; i <= this.row2; i++) {
              for (j = this.col; j <= this.col2; j++) {
                addCellNameToPrecedents({
                  row: i,
                  col: j,
                  workbookIndex: this.workbookIndex,
                  fixed_row: this.fixed_row,
                  fixed_col: this.fixed_col
                });
              }
            }
          }
        }
      }
    }

    this.locInfo = null;
    this.consumeCount = 0;
  };

// make BasicRangeRefRepresentation class look like an extension of the CellRefRepresentation class:
if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(BasicRangeRefRepresentation.prototype, CellRefRepresentation.prototype);
} else {
    BasicRangeRefRepresentation.prototype = Object.create(CellRefRepresentation.prototype);
}
BasicRangeRefRepresentation.prototype.constructor = BasicRangeRefRepresentation;
BasicRangeRefRepresentation.prototype.name = 'BasicRangeRefRepresentation';


// Automatically invoked by the JS engine 99.9% of the time, i.e. when this object is confronted with a
// math operator such as `+` or `*`. The remaining 0.1% shall have to be handled manually, i.e. by
// *explicitly* invoking this method.
BasicRangeRefRepresentation.prototype.valueOf = function () {
	// can't get a value from a range, ever!
    return Number.NaN;
};

BasicRangeRefRepresentation.prototype.toString = function () {
    // can't get a value from a range, ever!
    return Number.NaN;
};

// iterate over all cells within range and invoke callback for every cell, until callback returns truthy value;
// this method then returns that truthy value.
BasicRangeRefRepresentation.prototype.traverseRange = function (callback, errorCallback) {
	var rv = false;

    if (this.faulty) {
	    errorCallback({
	    	msg: "No cells in range",
	    	noCellsInRange: true
	    });
	} else {
		var i, j, r2, c1, c2, wbi;

		r2 = this.row2;
		c1 = this.col;
		c2 = this.col2;
		wbi = this.workbookIndex;
		for (i = this.row; i <= r2; i++) {
			for (j = c1; j <= c2; j++) {
				rv = callback(i, j, wbi);
				if (rv) {
					return rv;
				}
			}
		}
	}
    return rv;
};





// -------------------------------------------------------------------------------------------------------

// RangeRefRepresentation is a collection of Cell and BasicRange refs...
//
// `ref0` and (optional!) `ref1` are the first few references to be carried by this collection.
//
// See also comment at BasicRangeRefRepresentation class.
var RangeRefRepresentation = function (ref0, ref1) {
    this.faulty = !(ref0 instanceof CellRefRepresentation);

    this.__collection = [];

    if (!this.faulty) {
        this.__collection.push(ref0);

        this.locInfo = ref0.locInfo;
        this.consumeCount = ref0.consumeCount;

        if (ref1 instanceof CellRefRepresentation) {
            this.__collection.push(ref1);

            parser.updateRangeLocationInfo(this, ref1.locInfo, ref1.consumeCount);
        }
    } else {
        this.locInfo = null;
        this.consumeCount = 0;
    }
};

// make RangeRefRepresentation class look like an extension of the BasicRangeRefRepresentation class:
if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(RangeRefRepresentation.prototype, BasicRangeRefRepresentation.prototype);
} else {
    RangeRefRepresentation.prototype = Object.create(BasicRangeRefRepresentation.prototype);
}
RangeRefRepresentation.prototype.constructor = RangeRefRepresentation;
RangeRefRepresentation.prototype.name = 'RangeRefRepresentation';

// iterate over all cells within range and invoke callback for every cell, until callback returns truthy value;
// this method then returns that truthy value.
RangeRefRepresentation.prototype.traverseRange = function (callback, errorCallback) {
	var rv = false;

    if (this.faulty) {
	    errorCallback({
	    	msg: "No cells in range",
	    	noCellsInRange: true
	    });
	} else {
		var i, c, e, len;

		c = this.__collection;
		len = c.length;
		for (i = 0; i < len; i++) {
			e = c[i];
			assert(typeof e.traverseRange === 'function');
			rv = e.traverseRange(callback, errorCallback);
			if (rv) {
				return rv;
			}
		}
	}
    return rv;
};

RangeRefRepresentation.prototype.addRef = function (ref) {
    // `ref` can be a cellref or rangeref; in the latter case, we need to grab its constuents
    // and push each of those into our own collection: every constituent is, itself, a
    // cellref or BASIC rangeref, i.e. it is guaranteed to be `A1` or `A1:B3`, but not
    // `{A1:B3, C7, D3:D9}` because such a fragmented rangeref MUST already have been
    // 'flattened' on a previous rule 'reduce' action which MUST have called this `addRef()`
    // method back then.

	if (ref instanceof RangeRefRepresentation) {
      var list = ref.__collection;
      assert(list);
      for (var i = 0, len = list.length; i < len; i++) {
        this.__collection.push(list[i]);
      }
    } else {
      this.__collection.push(ref);
    }
    return this;
};







// publish the classes:
parser.CellRefRepresentation = CellRefRepresentation;
parser.BasicRangeRefRepresentation = BasicRangeRefRepresentation;
parser.RangeRefRepresentation = RangeRefRepresentation;








// This method converts the original scanned yytext *string* to a CellRefRepresentation object
// instance which can act as both a cell *reference* suitable for the rest of the V code *or*
// as a cell *value* (the value of the cell which is referenced) for those places where we
// are doing straight calculus on the cell value.
//
// Example of the latter: a formula like
//
//     =1+A1
//
// will try to 'read' the CellRefRepresentation instance value (via its .valueOf() member) when we
// execute the '+' action, which is number-oriented.
//
// Meanwhile we carry the *reference* to the cell with us in the grammar rules until we hit such a
// math operation, either directly, such as that '+', or indirectly, inside a Excel.Function(...),
// enabling us to look at the input 'value' fed to such an Excel function as a cell reference coordinate
// which makes HLOOKUP() et al a reality.
// (The fundamental is that the lexed value for the CELLREF token is stored in lexer.yytext, which
// is transformed to a CellRefRepresentation instance just before the lexer passes that token to
// the parser (grammar engine) where the formula grammar rules pick up and propagate these token 'values'
// coming from the lexer via those `$name` references in the grammar action code.)
parser.convertYYTEXTtoCellRefObject = function (yytext) {
    var cri = new parser.CellRefRepresentation(yytext);
    assert(cri);
    return cri;
};


parser.convertYYTEXTtoRangeRefObject = function (yytext) {
    var cri = new parser.BasicRangeRefRepresentation(yytext);
    assert(cri);
    return cri;
};
/* generated by jison-lex 0.3.4-166 */
var lexer = (function () {
// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonLexerError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) { // V8
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
} else {
    JisonLexerError.prototype = Object.create(Error.prototype);
}
JisonLexerError.prototype.constructor = JisonLexerError;
JisonLexerError.prototype.name = 'JisonLexerError';


var lexer = {
    EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        // <-- injected by the code generator

    // options: {},                             // <-- injected by the code generator

    // yy: ...,                                 // <-- injected by setInput()

    __currentRuleSet__: null,                   // <-- internal rule set cache for the current lexer state

    __error_infos: [],                          // INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup

    __decompressed: false,                      // INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use

    done: false,                                // INTERNAL USE ONLY
    _backtrack: false,                          // INTERNAL USE ONLY
    _input: '',                                 // INTERNAL USE ONLY
    _more: false,                               // INTERNAL USE ONLY
    _signaled_error_token: false,               // INTERNAL USE ONLY

    conditionStack: [],                         // INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`

    match: '',                                  // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!
    matched: '',                                // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far
    matches: false,                             // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt
    yytext: '',                                 // ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.
    offset: 0,                                  // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far
    yyleng: 0,                                  // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)
    yylineno: 0,                                // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located
    yylloc: null,                               // READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction

    // INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable) {
        var pei = {
            errStr: msg,
            recoverable: !!recoverable,
            text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...
            token: null,
            line: this.yylineno,
            loc: this.yylloc,
            yy: this.yy,
            lexer: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructLexErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    },

    parseError: function lexer_parseError(str, hash) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
            return this.yy.parser.parseError(str, hash) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
            return this.yy.parseError.call(this, str, hash) || this.ERROR;
        } else {
            throw new this.JisonLexerError(str);
        }
    },

    // final cleanup function for when we have completed lexing the input; 
    // make it an API so that external code can use this one once userland
    // code has decided it's time to destroy any lingering lexer error
    // hash object instances and the like: this function helps to clean
    // up these constructs, which *may* carry cyclic references which would
    // otherwise prevent the instances from being properly and timely
    // garbage-collected, i.e. this function helps prevent memory leaks!
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
        var rv;

        // prevent lingering circular references from causing memory leaks:
        this.setInput('', {});

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;
        }

        return this;
    },

    // clear the lexer token context; intended for internal use only
    clear: function lexer_clear() {
        this.yytext = '';
        this.yyleng = 0;
        this.match = '';
        this.matches = false;
        this._more = false;
        this._backtrack = false;
    },

    // resets the lexer, sets new input
    setInput: function lexer_setInput(input, yy) {
        this.yy = yy || this.yy || {};

        // also check if we've fully initialized the lexer instance,
        // including expansion work to be done to go from a loaded
        // lexer to a usable lexer:
        if (!this.__decompressed) {
          // step 1: decompress the regex list:
          var rules = this.rules;
          for (var i = 0, len = rules.length; i < len; i++) {
            var rule_re = rules[i];

            // compression: is the RE an xref to another RE slot in the rules[] table?
            if (typeof rule_re === 'number') {
              rules[i] = rules[rule_re];
            }
          }

          // step 2: unfold the conditions[] set to make these ready for use:
          var conditions = this.conditions;
          for (var k in conditions) {
            var spec = conditions[k];

            var rule_ids = spec.rules;

            var len = rule_ids.length;
            var rule_regexes = new Array(len + 1);            // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!
            var rule_new_ids = new Array(len + 1);

            if (this.rules_prefix1) {
                var rule_prefixes = new Array(65536);
                var first_catch_all_index = 0;

                for (var i = 0; i < len; i++) {
                  var idx = rule_ids[i];
                  var rule_re = rules[idx];
                  rule_regexes[i + 1] = rule_re;
                  rule_new_ids[i + 1] = idx;

                  var prefix = this.rules_prefix1[idx];
                  // compression: is the PREFIX-STRING an xref to another PREFIX-STRING slot in the rules_prefix1[] table?
                  if (typeof prefix === 'number') {
                    prefix = this.rules_prefix1[prefix];
                  }
                  // init the prefix lookup table: first come, first serve...
                  if (!prefix) {
                    if (!first_catch_all_index) {
                      first_catch_all_index = i + 1;
                    }
                  } else {
                    for (var j = 0, pfxlen = prefix.length; j < pfxlen; j++) {
                      var pfxch = prefix.charCodeAt(j);
                      // first come, first serve:
                      if (!rule_prefixes[pfxch]) {
                        rule_prefixes[pfxch] = i + 1;
                      }  
                    }
                  }
                }

                // if no catch-all prefix has been encountered yet, it means all
                // rules have limited prefix sets and it MAY be that particular
                // input characters won't be recognized by any rule in this 
                // condition state.
                // 
                // To speed up their discovery at run-time while keeping the
                // remainder of the lexer kernel code very simple (and fast),
                // we point these to an 'illegal' rule set index *beyond*
                // the end of the rule set.
                if (!first_catch_all_index) {
                  first_catch_all_index = len + 1;
                }

                for (var i = 0; i < 65536; i++) {
                  if (!rule_prefixes[i]) {
                    rule_prefixes[i] = first_catch_all_index; 
                  }
                }

                spec.__dispatch_lut = rule_prefixes;
            } else {
                for (var i = 0; i < len; i++) {
                  var idx = rule_ids[i];
                  var rule_re = rules[idx];
                  rule_regexes[i + 1] = rule_re;
                  rule_new_ids[i + 1] = idx;
                }
            }

            spec.rules = rule_new_ids;
            spec.__rule_regexes = rule_regexes;
            spec.__rule_count = len;
          }

          this.__decompressed = true;
        }

        this._input = input || '';
        this.clear();
        this._signaled_error_token = false;
        this.done = false;
        this.yylineno = 0;
        this.matched = '';
        this.conditionStack = ['INITIAL'];
        this.__currentRuleSet__ = null;
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
    },

    // consumes and returns one char from the input
    input: function lexer_input() {
        if (!this._input) {
            //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
            return null;
        }
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        // Count the linenumber up when we hit the LF (or a stand-alone CR).
        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
        // and we advance immediately past the LF as well, returning both together as if
        // it was all a single 'character' only.
        var slice_len = 1;
        var lines = false;
        if (ch === '\n') {
            lines = true;
        } else if (ch === '\r') {
            lines = true;
            var ch2 = this._input[1];
            if (ch2 === '\n') {
                slice_len++;
                ch += ch2;
                this.yytext += ch2;
                this.yyleng++;
                this.offset++;
                this.match += ch2;
                this.matched += ch2;
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }
            }
        }
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(slice_len);
        return ch;
    },

    // unshifts one char (or a string) into the input
    unput: function lexer_unput(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - len);
        this.matched = this.matched.substr(0, this.matched.length - len);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }

        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = (lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                + oldLines[oldLines.length - lines.length].length - lines[0].length :
                this.yylloc.first_column - len);

        if (this.options.ranges) {
            this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng - len;
        }
        this.yyleng = this.yytext.length;
        this.done = false;
        return this;
    },

    // When called from action, caches matched text and appends it on next action
    more: function lexer_more() {
        this._more = true;
        return this;
    },

    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject: function lexer_reject() {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            // when the parseError() call returns, we MUST ensure that the error is registered.
            // We accomplish this by signaling an 'error' token to be produced for the current
            // .lex() run.
            var p = this.constructLexErrorInfo('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), false);
            this._signaled_error_token = (this.parseError(p.errStr, p) || this.ERROR);
        }
        return this;
    },

    // retain first n characters of the match
    less: function lexer_less(n) {
        return this.unput(this.match.slice(n));
    },

    // return (part of the) already matched input, i.e. for error messages.
    // Limit the returned string length to `maxSize` (default: 20).
    // Limit the returned string to the `maxLines` number of lines of input (default: 1).
    // Negative limit values equal *unlimited*.
    pastInput: function lexer_pastInput(maxSize, maxLines) {
        var past = this.matched.substring(0, this.matched.length - this.match.length);
        if (maxSize < 0)
            maxSize = past.length;
        else if (!maxSize)
            maxSize = 20;
        if (maxLines < 0)
            maxLines = past.length;         // can't ever have more input lines than this!
        else if (!maxLines)
            maxLines = 1;
        // `substr` anticipation: treat \r\n as a single character and take a little
        // more than necessary so that we can still properly check against maxSize
        // after we've transformed and limited the newLines in here:
        past = past.substr(-maxSize * 2 - 2);
        // now that we have a significantly reduced string to process, transform the newlines
        // and chop them, then limit them:
        var a = past.replace(/\r\n|\r/g, '\n').split('\n');
        a = a.slice(-maxLines);
        past = a.join('\n');
        // When, after limiting to maxLines, we still have too much to return, 
        // do add an ellipsis prefix...
        if (past.length > maxSize) {
            past = '...' + past.substr(-maxSize);
        }
        return past;
    },

    // return (part of the) upcoming input, i.e. for error messages.
    // Limit the returned string length to `maxSize` (default: 20).
    // Limit the returned string to the `maxLines` number of lines of input (default: 1).
    // Negative limit values equal *unlimited*.
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
        var next = this.match;
        if (maxSize < 0)
            maxSize = next.length + this._input.length;
        else if (!maxSize)
            maxSize = 20;
        if (maxLines < 0)
            maxLines = maxSize;         // can't ever have more input lines than this!
        else if (!maxLines)
            maxLines = 1;
        // `substring` anticipation: treat \r\n as a single character and take a little
        // more than necessary so that we can still properly check against maxSize
        // after we've transformed and limited the newLines in here:
        if (next.length < maxSize * 2 + 2) {
            next += this._input.substring(0, maxSize * 2 + 2);  // substring is faster on Chrome/V8
        }
        // now that we have a significantly reduced string to process, transform the newlines
        // and chop them, then limit them:
        var a = next.replace(/\r\n|\r/g, '\n').split('\n');
        a = a.slice(0, maxLines);
        next = a.join('\n');
        // When, after limiting to maxLines, we still have too much to return, 
        // do add an ellipsis postfix...
        if (next.length > maxSize) {
            next = next.substring(0, maxSize) + '...';
        }
        return next;
    },

    // return a string which displays the character position where the lexing error occurred, i.e. for error messages
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
        var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
        var c = new Array(pre.length + 1).join('-');
        return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    // helper function, used to produce a human readable description as a string, given
    // the input `yylloc` location object. 
    // Set `display_range_too` to TRUE to include the string character index position(s)
    // in the description if the `yylloc.range` is available. 
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
        var l1 = yylloc.first_line;
        var l2 = yylloc.last_line;
        var o1 = yylloc.first_column;
        var o2 = yylloc.last_column - 1;
        var dl = l2 - l1;
        var d_o = (dl === 0 ? o2 - o1 : 1000);
        var rv;
        if (dl === 0) {
            rv = 'line ' + l1 + ', ';
            if (d_o === 0) {
                rv += 'column ' + o1;
            } else {
                rv += 'columns ' + o1 + ' .. ' + o2;
            }
        } else {
            rv = 'lines ' + l1 + '(column ' + o1 + ') .. ' + l2 + '(column ' + o2 + ')';
        }
        if (yylloc.range && display_range_too) {
            var r1 = yylloc.range[0];
            var r2 = yylloc.range[1] - 1;
            if (r2 === r1) {
                rv += ' {String Offset: ' + r1 + '}';
            } else {
                rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
            }
        }
        return rv;
        // return JSON.stringify(yylloc);
    },

    // test the lexed token: return FALSE when not a match, otherwise return token.
    //
    // `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
    // contains the actually matched text string.
    //
    // Also move the input cursor forward and update the match collectors:
    // - yytext
    // - yyleng
    // - match
    // - matches
    // - yylloc
    // - offset
    test_match: function lexer_test_match(match, indexed_rule, cfg, one, two) {
        var token,
            lines,
            backup,
            match_str;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        match_str = match[0];
        lines = match_str.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match_str.length
        };
        this.yytext += match_str;
        this.match += match_str;
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset + this.yyleng];
        }
        // previous lex rules MAY have invoked the `more()` API rather than producing a token:
        // those rules will already have moved this `offset` forward matching their match lengths,
        // hence we must only add our own match length now:
        this.offset += match_str.length;
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match_str.length);
        this.matched += match_str;

        // calling this method: 
        //
        //   function lexer__performAction(yy, yy_, $avoiding_name_collisions, YY_START) {...}
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1] /* = YY_START */, cfg, one, two);
        // otherwise, when the action codes are all simple return token statements:
        //token = this.simpleCaseActionClusters[indexed_rule];

        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            this.__currentRuleSet__ = null;
            return false; // rule action called reject() implying the next rule should be tested instead.
        } else if (this._signaled_error_token) {
            // produce one 'error' token as .parseError() in reject() did not guarantee a failure signal by throwing an exception!
            token = this._signaled_error_token;
            this._signaled_error_token = false;
            return token;
        }
        return false;
    },

    // return next match in input
    next: function lexer_next(cfg, one, two) {
        if (this.done) {
            this.clear();
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.clear();
        }
        var spec = this.__currentRuleSet__;
        if (!spec) {
            // Update the ruleset cache as we apparently encountered a state change or just started lexing.
            // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
            // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
            // speed up those activities a tiny bit.
            spec = this.__currentRuleSet__ = this._currentRules();
        }

        var rule_ids = spec.rules;
//        var dispatch = spec.__dispatch_lut;
        var regexes = spec.__rule_regexes;
        var len = spec.__rule_count;

//        var c0 = this._input[0];

        // Note: the arrays are 1-based, while `len` itself is a valid index, 
        // hence the non-standard less-or-equal check in the next loop condition!
        // 
        // `dispatch` is a lookup table which lists the *first* rule which matches the 1-char *prefix* of the rule-to-match.
        // By using that array as a jumpstart, we can cut down on the otherwise O(n*m) behaviour of this lexer, down to
        // O(n) ideally, where:
        // 
        // - N is the number of input particles -- which is not precisely characters 
        //   as we progress on a per-regex-match basis rather than on a per-character basis
        //   
        // - M is the number of rules (regexes) to test in the active condition state.
        //  
        for (var i = 1 /* (dispatch[c0] || 1) */ ; i <= len; i++) {
            tempMatch = this._input.match(regexes[i]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rule_ids[i], cfg, one, two);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = undefined;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rule_ids[index], cfg, one, two);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === '') {
            this.done = true;
            return this.EOF;
        } else {
            var p = this.constructLexErrorInfo('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), this.options.lexer_errors_are_recoverable);
            token = (this.parseError(p.errStr, p) || this.ERROR);
            if (token === this.ERROR) {
                // we can try to recover from a lexer error that parseError() did not 'recover' for us, by moving forward at least one character at a time:
                if (!this.match.length) {
                    this.input();
                }
            }
            return token;
        }
    },

    // return next match that has a token
    lex: function lexer_lex(cfg, one, two) {
        var r;
        // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
        if (typeof this.options.pre_lex === 'function') {
            r = this.options.pre_lex.call(this, cfg, one, two);
        }
        while (!r) {
            r = this.next(cfg, one, two);
        }
        if (typeof this.options.post_lex === 'function') {
            // (also account for a userdef function which does not return any value: keep the token as is)
            r = this.options.post_lex.call(this, r, cfg, one, two) || r;
        }
        return r;
    },

    // backwards compatible alias for `pushState()`;
    // the latter is symmetrical with `popState()` and we advise to use
    // those APIs in any modern lexer code, rather than `begin()`.
    begin: function lexer_begin(condition) {
        return this.pushState(condition);
    },

    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    pushState: function lexer_pushState(condition) {
        this.conditionStack.push(condition);
        this.__currentRuleSet__ = null;
        return this;
    },

    // pop the previously active lexer condition state off the condition stack
    popState: function lexer_popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            this.__currentRuleSet__ = null;
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState: function lexer_topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return 'INITIAL';
        }
    },

    // (internal) determine the lexer rule set which is active for the currently active lexer condition state
    _currentRules: function lexer__currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
        } else {
            return this.conditions['INITIAL'];
        }
    },

    // return the number of states currently on the stack
    stateStackSize: function lexer_stateStackSize() {
        return this.conditionStack.length;
    },
options: {
  backtrack_lexer: true,
  parseParams: [
    "cfg",
    "one",
    "two"
  ]
},
JisonLexerError: JisonLexerError,
performAction: function lexer__performAction(yy, yy_, $avoiding_name_collisions, YY_START) {

    /*
     * This chunk is included in the lexer action code at the very start of that method.
     *
     * `YY_START` is defined then, `YYSTATE` is not! `yy` and `yy_` are also available here.
     */
    var s, s2, s3;
    var rv, rv2, e_offset, col, row, len, value;
    var match, match2;

    //console.log("lexer action: ", yy, yy_, this, yy_.yytext, YY_START, $avoiding_name_collisions);

    var parser = yy.parser;

var YYSTATE = YY_START;
switch($avoiding_name_collisions) {
case 0 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       \u0001 */ 
 
            this.popState();
            return 24;
         
break;
case 1 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       \u0002 */ 
 
            this.popState();
            return 25;
         
break;
case 2 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       \u0003 */ 
 
            this.popState();
            return 26;
         
break;
case 3 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       . */ 
 
            this.popState();
            /*
             * When we did not observe one of the special character codes at the forefront of our
             * input stream then we will parsing the entire input in the default mode, i.e. as a formula.
             *
             * Therefore, let the previous lexer state (should be `INITIAL`) process this bit instead;
             * do not consume the matched input.
             *
             * **WARNING**: you might think this would be easily accomplished using the lexer.reject()
             * call like this:
             *
             *     this.reject();
             *
             * but `reject()` only works as expected _as long as you do NOT switch lexer states_!
             *
             * Some understanding of the lexer internals is required here: when you call `reject()`, the
             * lexer will simply test the input against the next regex in the current set. The key here
             * is _the current set_: when the lexer is required to produce a token, it will construct
             * a _regex set_ given the _current lexer state_.
             *
             * What we need here is the lexer retrying matching the same input after we changed the
             * lexer state above when we called:
             *
             *     this.popState();
             *
             * The way to accomplish this is to 'push back' the matched content into the input buffer using
             * `.unput()` and then signal the lexer that we matched nothing by returning no token at all:
             *
             *      return false;
             *
             * That `return false` will make sure the lexer considers this action as 'complete' (by
             * us `return`ing from the lexer), while the boolean `false` tells the lexer it will need
             * to run another round in order to provide its caller with a 'real' lexed token.
             *
             *
             * ### For the technically inquisitive
             *
             * The crux is us employing the side effects of the jison lexer engine,
             * more specifically this bit, where I'd like you to take notice of
             * the recursive nature of the `.lex()` method in here, plus the fact that `.next()`
             * will call `._currentRules()` each time it is invoked (while this is a very much
             * reduced and somewhat paraphrased extract of the original):
             *
             *      // generated by jison-lex...
             *      parser.lexer = {
             *          ...,
             *          next: function () {
             *              ...
             *              var match, token, rule_under_test;
             *              var rules = this._currentRules();
             *              for (var i = 0; i < rules.length; i++) {
             *                  rule_under_test = this.rules[rules[i]];
             *                  match = this._input.match(rule_under_test);
             *                  ...
             *                  if (match) {
             *                      // exec the matching lexer action code:
             *                      token = this.test_match(match, rule_under_test);
             *
             *                      // stay in this loop when .reject() was called,
             *                      // otherwise we'll run with this match:
             *                      if (!this.rejected) break;
             *                  }
             *              }
             *              if (match) {
             *                  ...
             *                  if (token !== false) {
             *                      return token;
             *                  }
             *                  // else: this is a lexer rule which consumes input
             *                  //       without producing a token (e.g. whitespace)
             *                  return false;
             *              }
             *              ...
             *          },
             *
             *          // return next match that has a token
             *          lex: function lex() {
             *              var r = this.next();
             *              if (r) {
             *                  return r;
             *              } else {
             *                  return this.lex();
             *              }
             *          },
             *
             *          // produce the lexer rule set which is active
             *          // for the currently active lexer condition state
             *          _currentRules: function _currentRules() {
             *              ...
             *              return this.conditions[...].rules;
             *          },
             *
             *          ...
             *
             *          conditions: {
             *              "PARSE_MODE_DETECTION": {
             *                  rules: [
             *                      0, 1, 2, 3, 4
             *                  ],
             *                  inclusive: false
             *              },
             *              ...
             *              "INITIAL": {
             *                  rules: [
             *                      5, 6, 7, 8, 9,
             *                      ...
             *                  ],
             *                  inclusive: true
             *              }
             *          }
             *      };
             *
             */
            this.unput(this.matches[0]);
            return false;
         
break;
case 4 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       $ */ 
 
            this.popState();
            // let the previous lexer state process that EOF for real...
            return false;
         
break;
case 5 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_ID}(\s*\(\s*\)) */ 
 
            /*
             * lookup this blurb: it MAY be an Excel constant posing as a function (e.g. `PI()`).
             *
             * Note that this is really another kind of lexical hack as here we include
             * a part of the GRAMMAR KNOWLEDGE in the lexer itself:
             *
             * since we 'know' now that the blurb `\1` is followed by an open brace `(`, we
             * can be certain that this is a function identifier and nothing else
             * that may have the same 'name', e.g. constant `E` or `PI` (or for very wide
             * spreadsheets: `ABS`).
             *
             * > ### Note
             * >
             * > the braces in the regex are there so we can easily grab each bit,
             * > and in particular that very last bit: it will ALWAYS be pushed back
             * > into the lexer queue as that bit is our 'additional look-ahead' at
             * > work!
             */
            // console.log("looking up functional constant in symbol table: ", yy_.yytext, this, this.matches);
            /*
             * **WARNING**: take heed of the comment further above regarding the `ID` and `WORD`
             * lexer regex 'macros' and JISON's behaviour regarding those!
             *
             * Hence we should be able to pick up the `(` at the end at `this.matches[2]`!
             */
            //this.unput(this.matches[2]);
            s = this.matches[1];
            rv = parser.getSymbol4DefinedConstant(s, FSC_FUNCTION);
            if (rv) {
                yy_.yytext = rv.value;
                switch (rv.attributes & OPCODE_MASK_FOR_FT_VALUE_TYPE) {
                default:
                    return 56;

                case FT_BOOLEAN:
                    if (rv.value)
                        return 57;
                    else
                        return 58;

                case FT_STRING:
                    return 59;
                }
            }

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 6 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_ID}(?=\s*\() */ 
 
            /*
             * lookup this blurb: it MAY be a (possibly namespaced) function identifier
             * (e.g. `SUM`, `namespace.user_defined_function42`).
             *
             * When it is not, then it most probably is a cell reference with a JSON filter expression,
             * including a filter _function_.
             *
             * Note that this is really another kind of lexical hack as here we include
             * a part of the GRAMMAR KNOWLEDGE in the lexer itself:
             *
             * since we 'know' now that the blurb `\1` is followed by an open brace `(`, we
             * can be certain that this is a function identifier and nothing else
             * that may have the same 'name', e.g. constant `E` or `PI` (or for very wide
             * spreadsheets: `ABS`).
             *
             * > ### Note
             * >
             * > the braces in the regex are there so we can easily grab each bit,
             * > and in particular that very last bit: it will ALWAYS be pushed back
             * > into the lexer queue as that bit is our 'additional look-ahead' at
             * > work!
             */
            // console.log("looking up function identifier token (+ look-ahead) in symbol table: ", yy_.yytext, this, this.matches);
            /*
             * **WARNING**: take heed of the comment further above regarding the `ID` and `WORD`
             * lexer regex 'macros' and JISON's behaviour regarding those!
             *
             * Hence we should be able to pick up the `(` at the end at `this.matches[3]`!
             */
            s = yy_.yytext;
            rv = parser.getSymbol4Function(s);
            /*
             * play nasty: produce a token ID for all functions which we support directly
             * and produce a FUNCTION token (with attribute) for everyone else.
             */
            if (rv) {
                yy_.yytext = {
                    opcode: rv,
                    text: s
                };

                return 44;
            }

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 7 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+[:]{WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+ */ 
  if (parser.isValidCellRange(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoRangeRefObject(yy_.yytext); return 51; } else { this.reject(); }  
break;
case 8 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[0-9]+[:]{WORKBOOK_PREFIX}?{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRange(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoRangeRefObject(yy_.yytext); return 51; } else { this.reject(); }  
break;
case 9 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\][:]{WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\] */ 
  if (parser.isValidCellRange(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoRangeRefObject(yy_.yytext); return 51; } else { this.reject(); }  
break;
case 10 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\][:]{WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRange(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoRangeRefObject(yy_.yytext); return 51; } else { this.reject(); }  
break;
case 11 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+[:]{WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\] */ 
  if (parser.isValidCellRange(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoRangeRefObject(yy_.yytext); return 51; } else { this.reject(); }  
break;
case 12 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+[:]{WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRange(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoRangeRefObject(yy_.yytext); return 51; } else { this.reject(); }  
break;
case 13 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\] */ 
  if (parser.isValidCellRef(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoCellRefObject(yy_.yytext); return 49; } else { this.reject(); }  
break;
case 14 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRef(yy_.yytext)) { yy_.yytext = parser.convertYYTEXTtoCellRefObject(yy_.yytext); return 49; } else { this.reject(); }  
break;
case 15 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {SOURCE}{WORKBOOK_PREFIX}{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
 
            if (parser.isValidCellRef(yy_.yytext)) {
                yy_.yytext = parser.convertYYTEXTtoCellRefObject(yy_.yytext);
                return 49;
            }
            else
            {
                this.reject();
            }
         
break;
case 16 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {SOURCE}{WORKBOOK_STRING_PREFIX}{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
 
            console.log("Eating dead parser", yy_.yytext);
            if (parser.isValidCellRef(yy_.yytext)) {
                yy_.yytext = parser.convertYYTEXTtoCellRefObject(yy_.yytext);
                return 49;
            }
            else
            {
                this.reject();
            }
         
break;
case 17 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_ID}(?={DUALIC_OPERATOR_MUST_FOLLOW}) */ 
 
            /*
             * lookup this blurb: it MAY be a namespaced constant (`LN10`, `namespace.user_defined_constant42`, `MATH.E`).
             */
            // console.log("looking up namespaced constant identifier token (+ look-ahead) in symbol table: ", yy_.yytext, this, this.matches);
            s = yy_.yytext;
            rv = parser.getSymbol4DefinedConstant(s);
            if (rv) {
                yy_.yytext = rv.value;
                switch (rv.attributes & OPCODE_MASK_FOR_FT_VALUE_TYPE) {
                default:
                    return 56;

                case FT_BOOLEAN:
                    if (rv.value)
                        return 57;
                    else
                        return 58;

                case FT_STRING:
                    return 59;
                }
            }

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 18 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       (?:[{LABEL_START}][{LABEL_START} \\\/,.:-]+)(?=\s*$) */ 
 
            // TODO: parse as date (+ optional timestamp): if it is A-okay, then we have a hit.
            //
            // Else: reject.

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 19 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {BASIC_FLOATING_POINT_NUMBER}[kKmMgG]|[0-9]+[kKmMgG][0-9]+ */ 
 
            /*
             * Numbers with Kilo, Mega or Giga, including **resistor notation**, i.e. `1K5`.
             *
             * Keep in mind that certain locations in a formula do accept 'labels'
             * which can look **exactly** like 'numbers' for pathologically-named
             * row/column labels, e.g. `2K12`.
             *
             * We use the parser to disambiguate between the two when the lexer rules
             * above haven't already dealt with this condition.
             */
            s = yy_.yytext;
            rv = s.match(/^([^kKmMgG]+)([kKmMgG])([^kKmMgG]*)$/);
            //console.log("parsing 'resistor notation' value: ", rv, s);
            switch (rv[2].toUpperCase()) {
            case "K":
                rv2 = 1E3;
                break;

            case "M":
                rv2 = 1E6;
                break;

            case "G":
                rv2 = 1E9;
                break;

            default:
                rv2 = 1;
                break;
            }
            if (rv[3].length > 0) {
                rv[1] += "." + rv[3];
            }
            // http://jsperf.com/number-vs-plus-vs-toint-vs-tofloat/26 --> parseFloat()
            s2 = parseFloat(rv[1]) * rv2;

            yy_.yytext = s2;

            // since these numbers cannot 'pose' as ROW numbers, we need not check for `INTEGER_NUMBER` suitability:
            return 54;
         
break;
case 20 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {BASIC_FLOATING_POINT_NUMBER}(?:[eE][+-]?[0-9]+)? */ 
 
            /*
             * Any numbers, including those in 'scientific notation', i.e. `1E5`
             *
             * Keep in mind that certain locations in a formula do accept 'labels'
             * which can look **exactly** like 'numbers' for pathologically-named
             * row / column labels, e.g. `2012`.
             *
             * We use the parser to disambiguate between the two when the lexer rules
             * above haven't already dealt with this condition.
             */

            s = yy_.yytext;
            // http://jsperf.com/number-vs-plus-vs-toint-vs-tofloat/26 --> parseFloat()
            s2 = parseFloat(s);

            yy_.yytext = s2;

            // for a number to be a floating point number, it must have a dot or an E part or be too large / small to be an integer
            if (parseInt(s, 10) !== s2) {
                return 54;
            }
            // else:
            return 55;
         
break;
case 21 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       [%](?=\s*([^{IDENTIFIER_LAST}\(\s]|$)) */ 
 
            yy_.yytext = '%';
            return 28;
         
break;
case 22 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {OPERATOR} */ 
 
            /*
             * Check if the matched string STARTS WITH an operator in the list below.
             *
             * On the first pass, a hash table is created (and cached) to speed up matching.
             */
            if (!this.__operator_hash_table) {
                var definition_table = [
                    {
                        name: "$",
                        lexer_opcode: FKA_FIXED_ROW_OR_COLUMN_MARKER,
                        produce: function () {
                            return 21;
                        }
                    },
                    {
                        name: ":",
                        lexer_opcode: FKA_RANGE_MARKER,
                        produce: function () {
                            return 22;
                        }
                    },
                    {
                        name: "...",                   /* .. and ... equal : */
                        lexer_opcode: FKA_RANGE_MARKER,
                        produce: function () {
                            return 22;
                        }
                    },
                    {
                        name: "..",                    /* .. and ... equal : */
                        lexer_opcode: FKA_RANGE_MARKER,
                        produce: function () {
                            return 22;
                        }
                    },
                    {
                        name: ",",
                        lexer_opcode: FKA_COMMA,
                        produce: function () {
                            return 20;
                        }
                    },
                    {
                        name: "/*",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["*/"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "(*",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["*)"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "{*",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["*}"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "#",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["#"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "\u203c",                                  /* ‼ */
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["!!", "\u203c" /* ‼ */];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "\u2590",                                  /* ▐ */
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["\u258c" /* ▌ */, "\u2590" /* ▐ */];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "&&",
                        opcode: FKW_BOOLEAN_AND_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 31;
                        }
                    },
                    {
                        name: "||",
                        opcode: FKW_BOOLEAN_OR_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 32;
                        }
                    },
                    {
                        name: "&",
                        opcode: FKW_STRING_CONCATENATION_OPERATOR | FT_STRING | FU_STRING,
                        produce: function () {
                            return 40;
                        }
                    },
                    {
                        name: "<=",                                     // Unicode alternatives: \u22dc
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 38;
                        }
                    },
                    {
                        name: ">=",                                     // Unicode alternatives: \u22dd
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 37;
                        }
                    },
                    {
                        name: "\u2264",
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 38;                         /* ≤ */
                        }
                    },
                    {
                        name: "\u2266",
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 38;                         /* ≦ */
                        }
                    },
                    {
                        name: "\u2265",
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 37;                      /* ≥ */
                        }
                    },
                    {
                        name: "\u2267",
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 37;                      /* ≧ */
                        }
                    },
                    {
                        name: "<>",                                     // Unicode alternatives: \u2276, \u2277
                        opcode: FKW_NOT_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 33;
                        }
                    },
                    {
                        name: "!=",                                     // Unicode alternatives: \u2260
                        opcode: FKW_NOT_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 33;
                        }
                    },
                    {
                        name: "!==",
                        opcode: FKW_NOT_IDENTICAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 34;
                        }
                    },
                    {
                        name: "<",
                        opcode: FKW_LESS_THAN | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 5;
                        }
                    },
                    {
                        name: ">",
                        opcode: FKW_GREATER_THAN | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 4;
                        }
                    },
                    {
                        name: "===",
                        opcode: FKW_IS_IDENTICAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 36;
                        }
                    },
                    {
                        name: "==",
                        opcode: FKW_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 39;
                        }
                    },
                    {
                        name: "=",
                        opcode: FKW_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            // This MAY be the `=` starting a formula: mark the event for the inline comments:
                            if (this.options.inline_comment_mode > 0) {
                                if (!this.inline_comments_monitor) {
                                    this.inline_comments_monitor = this.options.inline_comment_mode + 1;
                                }
                            }
                            return 3;
                        }
                    },
                    {
                        name: "**",
                        opcode: FKW_POWER | FT_NUMBER | FU_ANY,
                        produce: function () {
                            return 10;
                        }
                    },
                    {
                        name: "*",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 8;
                        }
                    },
                    {
                        name: "/",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 9;
                        }
                    },
                    {
                        name: "-",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 7;
                        }
                    },
                    {
                        name: "+",
                        opcode: FKW_ADD | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 6;
                        }
                    },
                    {
                        name: "^",
                        opcode: FKW_POWER | FT_NUMBER | FU_ANY,
                        produce: function () {
                            return 10;
                        }
                    },
                    {
                        name: "%",
                        opcode: FKW_MODULO_OPERATOR,
                        produce: function () {
                            return 27;
                        }
                    },
                    {
                        name: "\u2030",
                        opcode: FKW_PROMILAGE_OPERATOR,
                        produce: function () {
                            return 29;                 /* ‰ */
                        }
                    },
                    {
                        name: "\u221a",
                        opcode: FKW_SQRT_OPERATOR | FT_NUMBER | FU_ANY,
                        produce: function () {
                            return 41;                     /* √ */
                        }
                    },
                    {
                        name: "\u2248",
                        opcode: FKW_ALMOST_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 35;                      /* ≈ */
                        }
                    },
                    {
                        name: "\u2260",
                        opcode: FKW_NOT_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 33;                         /* ≠ */
                        }
                    },
                    {
                        name: "\u2264",
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 38;                     /* ≤ */
                        }
                    },
                    {
                        name: "\u2265",
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 37;                  /* ≥ */
                        }
                    },
                    {
                        name: "\u2212",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 7;                                 /* − */
                        }
                    },
                    {
                        name: "\u2013",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 7;                                 /* – */
                        }
                    },
                    {
                        name: "\u2012",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 7;                                 /* ‒ */
                        }
                    },
                    {
                        name: "\u2014",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 7;                                 /* — */
                        }
                    },
                    {
                        name: "\u2215",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 9;                                 /* ∕ */
                        }
                    },
                    {
                        name: "\u2044",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 9;                                 /* ⁄ */
                        }
                    },
                    {
                        name: "\u2219",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 8;                                 /* ∙ */
                        }
                    },
                    {
                        name: "\u2022",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 8;                                 /* • */
                        }
                    },
                    {
                        name: "\u2261",
                        opcode: FKW_IS_IDENTICAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 36;                      /* ≡ */
                        }
                    },
                    {
                        name: "\u2310",
                        opcode: FKW_BOOLEAN_NOT_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 12;                                 /* ⌐ */
                        }
                    },
                    {
                        name: "\u00ac",
                        opcode: FKW_BOOLEAN_NOT_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 12;                                 /* ¬ */
                        }
                    },
                    {
                        name: "!",
                        opcode: FKW_BOOLEAN_NOT_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 12;
                        }
                    },
                    {
                        name: "\u2229",
                        opcode: FKW_BOOLEAN_AND_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 31;              /* ∩ */
                        }
                    },
                    {
                        name: "\u00f7",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 9;                                 /* ÷ */
                        }
                    },
                    {
                        name: "\u00d7",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 8;                                 /* × */
                        }
                    },
                    {
                        name: "\u00b7",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 8;                                 /* · */
                        }
                    },
                    {
                        name: "\u2219",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 8;                                 /* ∙ */
                        }
                    },
                    {
                        name: "\u00b0",
                        opcode: FKW_DEGREES_OPERATOR,
                        produce: function () {
                            return 52;                  /* ° */
                        }
                    },
                    {
                        name: "\u00b2",
                        opcode: FKW_SQUARE_OPERATOR | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;                   /* ² */
                        }
                    },
                    {
                        name: "\u00b3",
                        opcode: FKW_CUBE_OPERATOR | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 43;                     /* ³ */
                        }
                    },
                    {
                        /*
                         * This token is an alternative notation which does not require the curly braces around
                         * a 'fragmented range reference', e.g. `{A1, A2, A3, B1}` is equivalent to `A1 ○ A2 ○ A3 ○ B1`
                         * which could also be written as `A1:A3 ○ B1`
                         */
                        name: "\u25cb",
                        opcode: FKW_ARRAY_CONCATENATION_OPERATOR,
                        produce: function () {
                            return 50;      /* ○ */
                        }
                    },
                    {
                        /*
                         * This token is an alternative notation which does not require the curly braces around
                         * a 'fragmented range reference', e.g. `{A1, A2, A3, B1}` is equivalent to `A1 ◦ A2 ◦ A3 ◦ B1`
                         * which could also be written as `A1:A3 ◦ B1`
                         */
                        name: "\u25e6",
                        opcode: FKW_ARRAY_CONCATENATION_OPERATOR,
                        produce: function () {
                            return 50;      /* ◦ */
                        }
                    },
                    {
                        name: "@",
                        opcode: FKW_DATA_MARKER,
                        produce: function () {
                            return 23;
                        }
                    },
                    {
                        name: ".",
                        opcode: FKW_DOT,
                        produce: function () {
                            // switch lexer modes RIGHT NOW: next up is the `json_filter_expression` rule!
                            assert(this.topState() !== 'JSON_FILTERING');
                            //this.pushState('JSON_FILTERING');   -- Fixed #880

                            return 13;
                        }
                    }
                ];
                var k, d, tlen, ht;

                ht = [{}, {}, {}, {}];
                for (var k = 0, tlen = definition_table.length; k < tlen; k++) {
                    d = definition_table[k];
                    assert(d.name);
                    ht[d.name.length][d.name] = d;
                }

                this.__operator_hash_table = ht;
            }

            var s1 = false, s2 = false, s3 = false;

            s = yy_.yytext;
            switch (s.length) {
            case 3:
                s3 = s;
                s = s.substr(0, 2);
                // fall through
            case 2:
                s2 = s;
                s = s.substr(0, 1);
                // fall through
            case 1:
                s1 = s;
                break;
            default:
                assert(0, "should never get here");
                break;
            }

            // reset `s`:
            s = yy_.yytext;

            // now find matches in the operator lookup table, largest match first:
            rv = this.__operator_hash_table[3][s3] || this.__operator_hash_table[2][s2] || this.__operator_hash_table[1][s1];
            if (rv) {
                // push the remainder back into the buffer before we continue:
                if (s.length > rv.name.length) {
                    this.unput(s.substr(rv.name.length));
                }

                if (rv.opcode) {
                    yy_.yytext = rv.name;
                } else if (rv.lexer_opcode) {
                    yy_.yytext = rv.name;
                }
                return rv.produce.call(this, yy_.yylloc, yy_.yytext);
            }

            /* This may be a single Unicode character representing some constant or currency */
            if (s.length > 1) {
                this.unput(s.substr(1));
            }
            s = s1;

            rv = parser.getSymbol4Currency(s);
            if (rv) {
                yy_.yytext = s;
                return 53;
            }

            // no dice, now see if this is a predefined constant
            rv = parser.getSymbol4DefinedConstant(s);
            if (rv) {
                yy_.yytext = rv.value;
                switch (rv.attributes & OPCODE_MASK_FOR_FT_VALUE_TYPE) {
                default:
                    return 56;

                case FT_BOOLEAN:
                    if (rv.value)
                        return 57;
                    else
                        return 58;

                case FT_STRING:
                    return 59;
                }
            }

            // when we don't have a match at all, we leave it to the other rules to hit something:
            this.reject();
         
break;
case 29 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \u2039([^\u203a]*)\u203a */ 
                                                   /* ‹string› */
            s = this.matches[1];
            yy_.yytext = s;
            return 59;
         
break;
case 30 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \u201c([^\u201d]*)\u201d */ 
                                                   /* “string” */
            s = this.matches[1];
            yy_.yytext = s;
            return 59;
         
break;
case 31 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \u00ab([^\u00bb]*)\u00bb */ 
                                                   /* «string» */
            s = this.matches[1];
            yy_.yytext = s;
            return 59;
         
break;
case 32 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       '(.*)$ */ 
 
            // This lexer rule should only accept Excel string values, i.e. non-formula entities
            // which start with a quote.
            //
            // TODO: later on make the lexer smarter (and a bit faster) by using lexer states
            // instead of this hack which checks the location info to recognize whether this is
            // the very first token we encounter: only when it is does this special situation apply.
            var pos = this.offset - yy_.yyleng;
            if (pos > 0) {
                this.reject();
            } else {
                s = this.matches[1];
                // s2 = parser.dedupQuotedString(s, "'");  -- Excel does not 'deduplicate' quotes in literal string values like these.

                yy_.yytext = s;
                // In MS Excel you can force any (entire!) formula or other input to be parsed as a string by prefixing it with a single "'" single quote.
                return 30;
            }
         
break;
case 33 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       "(.*)$ */ 
 
            // This lexer rule should only accept Excel string values, i.e. non-formula entities
            // which start with a quote.
            //
            // TODO: later on make the lexer smarter (and a bit faster) by using lexer states
            // instead of this hack which checks the location info to recognize whether this is
            // the very first token we encounter: only when it is does this special situation apply.
            var pos = this.offset - yy_.yyleng;
            if (pos > 0) {
                this.reject();
            } else {
                s = this.matches[1];
                // s2 = parser.dedupQuotedString(s, '"');  -- Excel does not 'deduplicate' quotes in literal string values like these.

                yy_.yytext = s;
                // In MS Excel you can force any (entire!) formula or other input to be parsed as a string by prefixing it with a single "'" single quote.
                return 30;
            }
         
break;
case 34 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       '([^']*(?:''[^']*)*)'{TOKEN_SENTINEL} */ 
 
            this.unput(this.matches[2]);

            s = this.matches[1];
            s2 = parser.dedupQuotedString(s, "'");
            yy_.yytext = s2;
            return 59;
         
break;
case 35 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       "([^"]*(?:""[^"]*)*)"{TOKEN_SENTINEL} */ 
 
            this.unput(this.matches[2]);

            s = this.matches[1];
            s2 = parser.dedupQuotedString(s, '"');
            yy_.yytext = s2;
            return 59;
         
break;
case 36 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       [^\/\*\)\}#!\u203c\u258c\u2590]+ */ 
                                                   /* * / ) | # ! ‼ ▌ ▐ */
            /* keep it all; we haven't hit an end-of-comment marker starting character yet! */
            this.more();
         
break;
case 37 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       . */ 
 
            for (rv = 0, len = this.inline_comment_end_markers.length; rv < len; rv++) {
                s2 = this.inline_comment_end_markers[rv];
                if (s2[0] === this.matches[0]) {
                    // we got a POTENTIAL MATCH; let's see if we need more:
                    if (s2.length > 1) {
                        // when yes, test the next rule!
                        this.reject();
                        return false;
                    } else {
                        /*
                        * Full match! end of comment reached.
                        *
                        * Remove this last bit from the parsed text and strip leading / trailing whitespace.
                        *
                        * > ### Notes
                        * >
                        * > Since returning actual tokens for any inline comments would
                        * > break the LALR(1) grammar most severely, we concatenate
                        * > comments and attach them to the next token.
                        * >
                        * > Since the 'next token' MAY be `EOF`, we need the parser
                        * > to check if there's any leech called `comment` hanging
                        * > off that EOF it might've got dropped in the in-box...
                        */
                        parser.pushComment();
                        this.popState();
                        return false;
                    }
                }
            }
            // collect input until we hit something we know:
            this.more();
         
break;
case 38 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       .. */ 
 
            /*
             * We only hit this rule when the previous one was `reject()`-ed
             * as that rule will match anything that's the start of this one.
             *
             * Hence we know we have a partial match on a comment terminator,
             * but we need to make sure.
             *
             * We also know that our longest 'end markers' are 2 characters wide,
             * so this solution is sufficient and complete.
             *
             * Now all we have to do is scan the longer-than-1-character
             * comment markers against what we've got here and if there's
             * NO MATCH, we need to keep in mind that nasty people can write
             * comments like `{***}` and we have a hit on `**}` so we may only
             * consume one character here in that case.
             */
            for (rv = 0, len = this.inline_comment_end_markers.length; rv < len; rv++) {
                s2 = this.inline_comment_end_markers[rv];
                if (s2 === this.matches[0]) {
                    /*
                     * Full match! end of comment reached.
                     *
                     * Remove this last bit from the parsed text and strip leading/trailing whitespace.
                     *
                     * Since returning actual tokens for any inline comments would
                     * break the LALR(1) grammar most severely, we concatenate
                     * comments and attach them to the next token.
                     *
                     * Since the 'next token' MAY be `EOF`, we need the parser
                     * to check if there's any leech called `comment` hanging
                     * of that EOF it might've got dropped in the in-box...
                     */
                    parser.pushComment();
                    this.popState();
                    return false;
                }
            }
            // we may only consume a single character, so we `unput()` the last one:
            this.less(1);

            // collect input until we hit something we know:
            this.more();
         
break;
case 39 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       $ */ 
 
            parser.pushComment();

            rv = yy.parser.parseError("Unterminated inline comment.", {
                text: yy_.yytext,
                //token: $error,
                line: yy_.yylloc,
                loc: yy_.yylloc,
                outer_loc: yy_.yylloc,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return 2;
         
break;
case 40 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \s+ */ 
 /*: skip whitespace */ 
break;
case 42 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_WORDS} */ 
 
            rv = yy.parser.parseError("Don't know what to do with this: it's unsupported input.", {
                text: yy_.yytext,
                //token: $error,
                line: yy_.yylloc,
                loc: yy_.yylloc,
                outer_loc: yy_.yylloc,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return 2;
         
break;
case 43 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       . */ 
 
            rv = yy.parser.parseError("Don't know what to do with this: it's unsupported input.", {
                text: yy_.yytext,
                //token: $error,
                line: yy_.yylloc,
                loc: yy_.yylloc,
                outer_loc: yy_.yylloc,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return 2;
         
break;
default:
  return this.simpleCaseActionClusters[$avoiding_name_collisions];
}
},
simpleCaseActionClusters: {

  /*! Conditions:: INITIAL */ 
  /*! Rule::       \( */ 
   23 : 14,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \) */ 
   24 : 15,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \{ */ 
   25 : 18,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \} */ 
   26 : 19,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \[ */ 
   27 : 16,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \] */ 
   28 : 17,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       $ */ 
   41 : 1
},
rules: [
/^(?:\u0001)/,
/^(?:\u0002)/,
/^(?:\u0003)/,
/^(?:.)/,
/^(?:$)/,
/^(?:([^\u0000-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?)(\s*\(\s*\)))/,
/^(?:([^\u0000-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?)(?=\s*\())/,
/^(?:(\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+[:](\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+)/,
/^(?:(\d+[!])?([$])?\d+[:](\d+[!])?([$])?\d+)/,
/^(?:(\d+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\][:](\d+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])/,
/^(?:(\d+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\][:](\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+)/,
/^(?:(\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+[:](\d+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])/,
/^(?:(\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+[:](\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+)/,
/^(?:(\d+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])/,
/^(?:(\d+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+)/,
/^(?:(\[[^\u0000-\u001f!-\-\/:-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])(\d+[!])([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+)/,
/^(?:(\[[^\u0000-\u001f!-\-\/:-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])('[^\u0000-\u001f!-\-\/:-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+'[!])([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?\d+)/,
/^(?:([^\u0000-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?)(?=(\s*(?:$|[\u0000-\b\u000e-\u001f#%&)-\-\/:-?\\-\^`|-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]))))/,
/^(?:(?:[^\u0000-\/:-@\[-`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff][^\u0000-\u001f!-+;-@\[\]-`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+)(?=\s*$))/,
/^(?:((?:\d+(?:\.\d*)?|\.\d+))[GKMgkm]|\d+[GKMgkm]\d+)/,
/^(?:((?:\d+(?:\.\d*)?|\.\d+))(?:[Ee][+-]?\d+)?)/,
/^(?:[%](?=\s*([\u0000-\b\u000e-\u001f!-')-\/:-@\[-\^`{-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]|$)))/,
/^(?:([\u0000-\b\u000e-\u001f!-\/:-@\[-\^`{-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]{1,3}))/,
/^(?:\()/,
/^(?:\))/,
/^(?:\{)/,
/^(?:\})/,
/^(?:\[)/,
/^(?:\])/,
/^(?:\u2039([^›]*)\u203a)/,
/^(?:\u201c([^”]*)\u201d)/,
/^(?:\u00ab([^»]*)\u00bb)/,
/^(?:'(.*)$)/,
/^(?:"(.*)$)/,
/^(?:'([^']*(?:''[^']*)*)'(\s*(?:$|[\u0000-\b\u000e-\u001f#%&)-\-\/:-?\\-\^`|-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])))/,
/^(?:"([^"]*(?:""[^"]*)*)"(\s*(?:$|[\u0000-\b\u000e-\u001f#%&)-\-\/:-?\\-\^`|-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])))/,
/^(?:[^!#)*\/}‼▌▐]+)/,
/^(?:.)/,
/^(?:..)/,
/^(?:$)/,
/^(?:\s+)/,
/^(?:$)/,
/^(?:([^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\b\u000e-\u001f!-\-\/:-@\[-\^`{-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?))/,
/^(?:.)/
],
conditions: {
  "PARSE_MODE_DETECTION": {
    rules: [
      0,
      1,
      2,
      3,
      4
    ],
    inclusive: false
  },
  "INLINE_COMMENT": {
    rules: [
      36,
      37,
      38,
      39
    ],
    inclusive: false
  },
  "INITIAL": {
    rules: [
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      40,
      41,
      42,
      43
    ],
    inclusive: true
  }
}
};

return lexer;
})();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();




if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = formulaVisyondActive;
  exports.Parser = formulaVisyondActive.Parser;
  exports.parse = function () {
    return formulaVisyondActive.parse.apply(formulaVisyondActive, arguments);
  };
  exports.main = function commonjsMain(args) {
    // When the parser comes with its own `main` function, then use that one:
    if (typeof exports.parser.main === 'function') {
      return exports.parser.main(args);
    }

    var fs = require('fs');
    var path = require('path');

    if (!args[1]) {
        console.log('Usage: ' + path.basename(args[0]) + ' FILE');
        process.exit(1);
    }
    var source = fs.readFileSync(path.normalize(args[1]), 'utf8');
    var dst = exports.parser.parse(source);
    console.log('parser output: ', {
        type: typeof dst,
        value: dst
    });
    var rv = 0;
    if (typeof dst === 'number' || typeof dst === 'boolean') {
        rv = dst;
    }
    return dst;
};
  if (typeof module !== 'undefined' && require.main === module) {
    exports.main(process.argv.slice(1));
  }
}

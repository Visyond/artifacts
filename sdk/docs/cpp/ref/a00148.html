<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LibreOffice: rtl::OString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibreOffice
   </div>
   <div id="projectbrief">LibreOffice 6.3 SDK C/C++ API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00454.html">rtl</a></li><li class="navelem"><a class="el" href="a00148.html">OString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00686.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rtl::OString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This String class provide base functionality for C++ like 8-Bit character array handling.  
 <a href="a00148.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00387_source.html">string.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdbfeafcd9fffb3de8ae92e034591a72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#abdbfeafcd9fffb3de8ae92e034591a72">OString</a> ()</td></tr>
<tr class="memdesc:abdbfeafcd9fffb3de8ae92e034591a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string containing no characters.  <a href="#abdbfeafcd9fffb3de8ae92e034591a72">More...</a><br/></td></tr>
<tr class="separator:abdbfeafcd9fffb3de8ae92e034591a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa56e932cbed3343dc22bc72785e7364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aaa56e932cbed3343dc22bc72785e7364">OString</a> (const <a class="el" href="a00148.html">OString</a> &amp;str)</td></tr>
<tr class="memdesc:aaa56e932cbed3343dc22bc72785e7364"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>.  <a href="#aaa56e932cbed3343dc22bc72785e7364">More...</a><br/></td></tr>
<tr class="separator:aaa56e932cbed3343dc22bc72785e7364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640d18f0ca3e80cd497dc54f43373d28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a640d18f0ca3e80cd497dc54f43373d28">OString</a> (rtl_String *str)</td></tr>
<tr class="memdesc:a640d18f0ca3e80cd497dc54f43373d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> data.  <a href="#a640d18f0ca3e80cd497dc54f43373d28">More...</a><br/></td></tr>
<tr class="separator:a640d18f0ca3e80cd497dc54f43373d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9db46533a6bf69adfabba1e885dec3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aee9db46533a6bf69adfabba1e885dec3">OString</a> (rtl_String *str, <a class="el" href="a00409.html#a30b3dd1d6058d15544996570e4f14244">__sal_NoAcquire</a>)</td></tr>
<tr class="memdesc:aee9db46533a6bf69adfabba1e885dec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> data without acquiring it.  <a href="#aee9db46533a6bf69adfabba1e885dec3">More...</a><br/></td></tr>
<tr class="separator:aee9db46533a6bf69adfabba1e885dec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636d5f2bbb47aa148334a44d82b6a783"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a636d5f2bbb47aa148334a44d82b6a783">OString</a> (<a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> value)</td></tr>
<tr class="memdesc:a636d5f2bbb47aa148334a44d82b6a783"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a single character.  <a href="#a636d5f2bbb47aa148334a44d82b6a783">More...</a><br/></td></tr>
<tr class="separator:a636d5f2bbb47aa148334a44d82b6a783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd46138514d3877b15d82fb7e186aac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#abcd46138514d3877b15d82fb7e186aac">if</a> (<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T &gt;::length==0)</td></tr>
<tr class="separator:abcd46138514d3877b15d82fb7e186aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad892314d33d8cfd6f2f653aadec59e04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ad892314d33d8cfd6f2f653aadec59e04">OString</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value, sal_Int32 length)</td></tr>
<tr class="memdesc:ad892314d33d8cfd6f2f653aadec59e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a character buffer array.  <a href="#ad892314d33d8cfd6f2f653aadec59e04">More...</a><br/></td></tr>
<tr class="separator:ad892314d33d8cfd6f2f653aadec59e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0805f7647f0c8887b7b0f8bf8eb3ea65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a0805f7647f0c8887b7b0f8bf8eb3ea65">OString</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *value, sal_Int32 length, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> encoding, sal_uInt32 convertFlags=<a class="el" href="a00386.html#a8edb860d1ae6e2db3c161242d6ace6a6">OUSTRING_TO_OSTRING_CVTFLAGS</a>)</td></tr>
<tr class="memdesc:a0805f7647f0c8887b7b0f8bf8eb3ea65"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a Unicode character buffer array.  <a href="#a0805f7647f0c8887b7b0f8bf8eb3ea65">More...</a><br/></td></tr>
<tr class="separator:a0805f7647f0c8887b7b0f8bf8eb3ea65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad480f8774cc33a66b9b3d3a7651cb4a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ad480f8774cc33a66b9b3d3a7651cb4a5">~OString</a> ()</td></tr>
<tr class="memdesc:ad480f8774cc33a66b9b3d3a7651cb4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the string data.  <a href="#ad480f8774cc33a66b9b3d3a7651cb4a5">More...</a><br/></td></tr>
<tr class="separator:ad480f8774cc33a66b9b3d3a7651cb4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f76aec26dc61b16bcd36ec009f4988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00148.html">OString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ad7f76aec26dc61b16bcd36ec009f4988">operator=</a> (const <a class="el" href="a00148.html">OString</a> &amp;str)</td></tr>
<tr class="memdesc:ad7f76aec26dc61b16bcd36ec009f4988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new string.  <a href="#ad7f76aec26dc61b16bcd36ec009f4988">More...</a><br/></td></tr>
<tr class="separator:ad7f76aec26dc61b16bcd36ec009f4988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5dd6deae8e6f8ec764512fc1aa3208"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd5dd6deae8e6f8ec764512fc1aa3208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00148.html">OString</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#abd5dd6deae8e6f8ec764512fc1aa3208">operator=</a> (T &amp;literal)</td></tr>
<tr class="memdesc:abd5dd6deae8e6f8ec764512fc1aa3208"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#abd5dd6deae8e6f8ec764512fc1aa3208">More...</a><br/></td></tr>
<tr class="separator:abd5dd6deae8e6f8ec764512fc1aa3208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1362b7dd860f5fe07ad45b635a15e96d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00148.html">OString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a1362b7dd860f5fe07ad45b635a15e96d">operator+=</a> (const <a class="el" href="a00148.html">OString</a> &amp;str)</td></tr>
<tr class="memdesc:a1362b7dd860f5fe07ad45b635a15e96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string to this string.  <a href="#a1362b7dd860f5fe07ad45b635a15e96d">More...</a><br/></td></tr>
<tr class="separator:a1362b7dd860f5fe07ad45b635a15e96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca9f8b46a516429031e091221c808ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a6ca9f8b46a516429031e091221c808ed">clear</a> ()</td></tr>
<tr class="memdesc:a6ca9f8b46a516429031e091221c808ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the string, i.e, makes a zero-character string.  <a href="#a6ca9f8b46a516429031e091221c808ed">More...</a><br/></td></tr>
<tr class="separator:a6ca9f8b46a516429031e091221c808ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8623ff42d0d50803a2406830d3fc37e"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae8623ff42d0d50803a2406830d3fc37e">getLength</a> () const </td></tr>
<tr class="memdesc:ae8623ff42d0d50803a2406830d3fc37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of this string.  <a href="#ae8623ff42d0d50803a2406830d3fc37e">More...</a><br/></td></tr>
<tr class="separator:ae8623ff42d0d50803a2406830d3fc37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba09070a2bfd4052b672d027f07d3009"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aba09070a2bfd4052b672d027f07d3009">isEmpty</a> () const </td></tr>
<tr class="memdesc:aba09070a2bfd4052b672d027f07d3009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a string is empty.  <a href="#aba09070a2bfd4052b672d027f07d3009">More...</a><br/></td></tr>
<tr class="separator:aba09070a2bfd4052b672d027f07d3009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56df3c85362dcde3374245cbb4476e0c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a56df3c85362dcde3374245cbb4476e0c">getStr</a> () const SAL_RETURNS_NONNULL</td></tr>
<tr class="memdesc:a56df3c85362dcde3374245cbb4476e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the characters of this string.  <a href="#a56df3c85362dcde3374245cbb4476e0c">More...</a><br/></td></tr>
<tr class="separator:a56df3c85362dcde3374245cbb4476e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabedf0030558d9aa34ce0bd9cddfde83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aabedf0030558d9aa34ce0bd9cddfde83">operator[]</a> (sal_Int32 index) const </td></tr>
<tr class="memdesc:aabedf0030558d9aa34ce0bd9cddfde83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to individual characters.  <a href="#aabedf0030558d9aa34ce0bd9cddfde83">More...</a><br/></td></tr>
<tr class="separator:aabedf0030558d9aa34ce0bd9cddfde83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af094b7ac4e784ea736cdf010b0df0156"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#af094b7ac4e784ea736cdf010b0df0156">compareTo</a> (const <a class="el" href="a00148.html">OString</a> &amp;str) const </td></tr>
<tr class="memdesc:af094b7ac4e784ea736cdf010b0df0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings.  <a href="#af094b7ac4e784ea736cdf010b0df0156">More...</a><br/></td></tr>
<tr class="separator:af094b7ac4e784ea736cdf010b0df0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015694f6b7f941174b4782a9e25dd455"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a015694f6b7f941174b4782a9e25dd455">compareTo</a> (const <a class="el" href="a00148.html">OString</a> &amp;rObj, sal_Int32 maxLength) const </td></tr>
<tr class="memdesc:a015694f6b7f941174b4782a9e25dd455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings with an maximum count of characters.  <a href="#a015694f6b7f941174b4782a9e25dd455">More...</a><br/></td></tr>
<tr class="separator:a015694f6b7f941174b4782a9e25dd455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ef7a47e824c10a9cde0edd83d3caf"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aba6ef7a47e824c10a9cde0edd83d3caf">reverseCompareTo</a> (const <a class="el" href="a00148.html">OString</a> &amp;str) const </td></tr>
<tr class="memdesc:aba6ef7a47e824c10a9cde0edd83d3caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings in reverse order.  <a href="#aba6ef7a47e824c10a9cde0edd83d3caf">More...</a><br/></td></tr>
<tr class="separator:aba6ef7a47e824c10a9cde0edd83d3caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3f22f2f95e44d6d8c664c9764179f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a5d3f22f2f95e44d6d8c664c9764179f8">equals</a> (const <a class="el" href="a00148.html">OString</a> &amp;str) const </td></tr>
<tr class="memdesc:a5d3f22f2f95e44d6d8c664c9764179f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a comparison of two strings.  <a href="#a5d3f22f2f95e44d6d8c664c9764179f8">More...</a><br/></td></tr>
<tr class="separator:a5d3f22f2f95e44d6d8c664c9764179f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aa87069bcb9c93143271fdf999ba98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a98aa87069bcb9c93143271fdf999ba98">equalsL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value, sal_Int32 length) const </td></tr>
<tr class="memdesc:a98aa87069bcb9c93143271fdf999ba98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a comparison of two strings.  <a href="#a98aa87069bcb9c93143271fdf999ba98">More...</a><br/></td></tr>
<tr class="separator:a98aa87069bcb9c93143271fdf999ba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07701372f5ba265b4ccd2f928bed8f91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a07701372f5ba265b4ccd2f928bed8f91">equalsIgnoreAsciiCase</a> (const <a class="el" href="a00148.html">OString</a> &amp;str) const </td></tr>
<tr class="memdesc:a07701372f5ba265b4ccd2f928bed8f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ASCII lowercase comparison of two strings.  <a href="#a07701372f5ba265b4ccd2f928bed8f91">More...</a><br/></td></tr>
<tr class="separator:a07701372f5ba265b4ccd2f928bed8f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af010e246b922e736e2ff845d8c9e4b63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af010e246b922e736e2ff845d8c9e4b63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#af010e246b922e736e2ff845d8c9e4b63">equalsIgnoreAsciiCase</a> (const T &amp;asciiStr) const </td></tr>
<tr class="memdesc:af010e246b922e736e2ff845d8c9e4b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ASCII lowercase comparison of two strings.  <a href="#af010e246b922e736e2ff845d8c9e4b63">More...</a><br/></td></tr>
<tr class="separator:af010e246b922e736e2ff845d8c9e4b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcbbc4fbbc6e3f56971e32df09a6080"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdcbbc4fbbc6e3f56971e32df09a6080"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#abdcbbc4fbbc6e3f56971e32df09a6080">equalsIgnoreAsciiCase</a> (T &amp;asciiStr) const </td></tr>
<tr class="separator:abdcbbc4fbbc6e3f56971e32df09a6080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36683c350429ca8833a93167a7fd894f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36683c350429ca8833a93167a7fd894f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a36683c350429ca8833a93167a7fd894f">equalsIgnoreAsciiCase</a> (T &amp;literal) const </td></tr>
<tr class="memdesc:a36683c350429ca8833a93167a7fd894f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a36683c350429ca8833a93167a7fd894f">More...</a><br/></td></tr>
<tr class="separator:a36683c350429ca8833a93167a7fd894f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8a84c459e462c65b217416745ffc1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#adc8a84c459e462c65b217416745ffc1b">equalsIgnoreAsciiCaseL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 asciiStrLength) const </td></tr>
<tr class="memdesc:adc8a84c459e462c65b217416745ffc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ASCII lowercase comparison of two strings.  <a href="#adc8a84c459e462c65b217416745ffc1b">More...</a><br/></td></tr>
<tr class="separator:adc8a84c459e462c65b217416745ffc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bd46105d7b3db98b1e03c3d3b481d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae6bd46105d7b3db98b1e03c3d3b481d1">match</a> (const <a class="el" href="a00148.html">OString</a> &amp;str, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ae6bd46105d7b3db98b1e03c3d3b481d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string.  <a href="#ae6bd46105d7b3db98b1e03c3d3b481d1">More...</a><br/></td></tr>
<tr class="separator:ae6bd46105d7b3db98b1e03c3d3b481d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51810e1b68fe8adf2b3ba34a0606b1e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51810e1b68fe8adf2b3ba34a0606b1e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a51810e1b68fe8adf2b3ba34a0606b1e2">match</a> (T &amp;literal, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a51810e1b68fe8adf2b3ba34a0606b1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a51810e1b68fe8adf2b3ba34a0606b1e2">More...</a><br/></td></tr>
<tr class="separator:a51810e1b68fe8adf2b3ba34a0606b1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6644ed0bae62b4cf0077d018facf514"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae6644ed0bae62b4cf0077d018facf514">matchL</a> (char const *str, sal_Int32 strLength, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ae6644ed0bae62b4cf0077d018facf514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string.  <a href="#ae6644ed0bae62b4cf0077d018facf514">More...</a><br/></td></tr>
<tr class="separator:ae6644ed0bae62b4cf0077d018facf514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c697a4dd1845e3f7d174eabbaf6a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a0f8c697a4dd1845e3f7d174eabbaf6a6">matchIgnoreAsciiCase</a> (const <a class="el" href="a00148.html">OString</a> &amp;str, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a0f8c697a4dd1845e3f7d174eabbaf6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string, ignoring the case of ASCII letters.  <a href="#a0f8c697a4dd1845e3f7d174eabbaf6a6">More...</a><br/></td></tr>
<tr class="separator:a0f8c697a4dd1845e3f7d174eabbaf6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa596697514c67acee8c1875d1ca2a25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa596697514c67acee8c1875d1ca2a25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#aaa596697514c67acee8c1875d1ca2a25">matchIgnoreAsciiCase</a> (T &amp;literal, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:aaa596697514c67acee8c1875d1ca2a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#aaa596697514c67acee8c1875d1ca2a25">More...</a><br/></td></tr>
<tr class="separator:aaa596697514c67acee8c1875d1ca2a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64551f449806c349c250a1ea16f353c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a64551f449806c349c250a1ea16f353c2">startsWith</a> (<a class="el" href="a00148.html">OString</a> const &amp;str, <a class="el" href="a00148.html">OString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a64551f449806c349c250a1ea16f353c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string starts with a given substring.  <a href="#a64551f449806c349c250a1ea16f353c2">More...</a><br/></td></tr>
<tr class="separator:a64551f449806c349c250a1ea16f353c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fb5e6b0b72ad3db891fb529798aa76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1fb5e6b0b72ad3db891fb529798aa76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#ad1fb5e6b0b72ad3db891fb529798aa76">startsWith</a> (T &amp;literal, <a class="el" href="a00148.html">OString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:ad1fb5e6b0b72ad3db891fb529798aa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#ad1fb5e6b0b72ad3db891fb529798aa76">More...</a><br/></td></tr>
<tr class="separator:ad1fb5e6b0b72ad3db891fb529798aa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48485dac043240fc732166fa641ffe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aa48485dac043240fc732166fa641ffe2">startsWithIgnoreAsciiCase</a> (<a class="el" href="a00148.html">OString</a> const &amp;str, <a class="el" href="a00148.html">OString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:aa48485dac043240fc732166fa641ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string starts with a given string, ignoring the case of ASCII letters.  <a href="#aa48485dac043240fc732166fa641ffe2">More...</a><br/></td></tr>
<tr class="separator:aa48485dac043240fc732166fa641ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60e102f79bf625589d0e3b5750a8ceb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad60e102f79bf625589d0e3b5750a8ceb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#ad60e102f79bf625589d0e3b5750a8ceb">startsWithIgnoreAsciiCase</a> (T &amp;literal, <a class="el" href="a00148.html">OString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:ad60e102f79bf625589d0e3b5750a8ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#ad60e102f79bf625589d0e3b5750a8ceb">More...</a><br/></td></tr>
<tr class="separator:ad60e102f79bf625589d0e3b5750a8ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb94f9b21e139043c5d6909fa23c1e09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#adb94f9b21e139043c5d6909fa23c1e09">endsWith</a> (<a class="el" href="a00148.html">OString</a> const &amp;str, <a class="el" href="a00148.html">OString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:adb94f9b21e139043c5d6909fa23c1e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string ends with a given substring.  <a href="#adb94f9b21e139043c5d6909fa23c1e09">More...</a><br/></td></tr>
<tr class="separator:adb94f9b21e139043c5d6909fa23c1e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9c01ebdb31b57171135b47e203c48e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd9c01ebdb31b57171135b47e203c48e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#afd9c01ebdb31b57171135b47e203c48e">endsWith</a> (T &amp;literal, <a class="el" href="a00148.html">OString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:afd9c01ebdb31b57171135b47e203c48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#afd9c01ebdb31b57171135b47e203c48e">More...</a><br/></td></tr>
<tr class="separator:afd9c01ebdb31b57171135b47e203c48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2afd8c18ca6b22dbb86195e7abb4b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aca2afd8c18ca6b22dbb86195e7abb4b2">endsWithL</a> (char const *str, sal_Int32 strLength) const </td></tr>
<tr class="memdesc:aca2afd8c18ca6b22dbb86195e7abb4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string ends with a given substring.  <a href="#aca2afd8c18ca6b22dbb86195e7abb4b2">More...</a><br/></td></tr>
<tr class="separator:aca2afd8c18ca6b22dbb86195e7abb4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad037bbbc7b3a63d9a576e49b6681ce74"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ad037bbbc7b3a63d9a576e49b6681ce74">hashCode</a> () const </td></tr>
<tr class="memdesc:ad037bbbc7b3a63d9a576e49b6681ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hashcode for this string.  <a href="#ad037bbbc7b3a63d9a576e49b6681ce74">More...</a><br/></td></tr>
<tr class="separator:ad037bbbc7b3a63d9a576e49b6681ce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90defe2edc10cce082d9e0b68b406698"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a90defe2edc10cce082d9e0b68b406698">indexOf</a> (<a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> ch, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a90defe2edc10cce082d9e0b68b406698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.  <a href="#a90defe2edc10cce082d9e0b68b406698">More...</a><br/></td></tr>
<tr class="separator:a90defe2edc10cce082d9e0b68b406698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ac873a31711760ae82a2044dfd71eb"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ac7ac873a31711760ae82a2044dfd71eb">lastIndexOf</a> (<a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> ch) const </td></tr>
<tr class="memdesc:ac7ac873a31711760ae82a2044dfd71eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified character, searching backward starting at the end.  <a href="#ac7ac873a31711760ae82a2044dfd71eb">More...</a><br/></td></tr>
<tr class="separator:ac7ac873a31711760ae82a2044dfd71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc60ca9a3aab4c21bcec95469103b0a"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a6bc60ca9a3aab4c21bcec95469103b0a">lastIndexOf</a> (<a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> ch, sal_Int32 fromIndex) const </td></tr>
<tr class="memdesc:a6bc60ca9a3aab4c21bcec95469103b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified character, searching backward starting before the specified index.  <a href="#a6bc60ca9a3aab4c21bcec95469103b0a">More...</a><br/></td></tr>
<tr class="separator:a6bc60ca9a3aab4c21bcec95469103b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37610494aa7ae42d9d595b5c2734fef4"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a37610494aa7ae42d9d595b5c2734fef4">indexOf</a> (const <a class="el" href="a00148.html">OString</a> &amp;str, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a37610494aa7ae42d9d595b5c2734fef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.  <a href="#a37610494aa7ae42d9d595b5c2734fef4">More...</a><br/></td></tr>
<tr class="separator:a37610494aa7ae42d9d595b5c2734fef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482c74454709d9b58e42ee570034e8b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a482c74454709d9b58e42ee570034e8b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, sal_Int32 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a482c74454709d9b58e42ee570034e8b0">indexOf</a> (T &amp;literal, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a482c74454709d9b58e42ee570034e8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a482c74454709d9b58e42ee570034e8b0">More...</a><br/></td></tr>
<tr class="separator:a482c74454709d9b58e42ee570034e8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab237c155f542d87e6856a7f2bc1d0427"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ab237c155f542d87e6856a7f2bc1d0427">indexOfL</a> (char const *str, sal_Int32 len, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ab237c155f542d87e6856a7f2bc1d0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.  <a href="#ab237c155f542d87e6856a7f2bc1d0427">More...</a><br/></td></tr>
<tr class="separator:ab237c155f542d87e6856a7f2bc1d0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceb274b014f492d085ff7386aaa7d3e"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aeceb274b014f492d085ff7386aaa7d3e">lastIndexOf</a> (const <a class="el" href="a00148.html">OString</a> &amp;str) const </td></tr>
<tr class="memdesc:aeceb274b014f492d085ff7386aaa7d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the end.  <a href="#aeceb274b014f492d085ff7386aaa7d3e">More...</a><br/></td></tr>
<tr class="separator:aeceb274b014f492d085ff7386aaa7d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64a51a44f987072b02cf4a6d4d8f5ae"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae64a51a44f987072b02cf4a6d4d8f5ae">lastIndexOf</a> (const <a class="el" href="a00148.html">OString</a> &amp;str, sal_Int32 fromIndex) const </td></tr>
<tr class="memdesc:ae64a51a44f987072b02cf4a6d4d8f5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified substring, searching backward starting before the specified index.  <a href="#ae64a51a44f987072b02cf4a6d4d8f5ae">More...</a><br/></td></tr>
<tr class="separator:ae64a51a44f987072b02cf4a6d4d8f5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2b79f602aca681188fbf3564006e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a2a2b79f602aca681188fbf3564006e87">copy</a> (sal_Int32 beginIndex) const </td></tr>
<tr class="memdesc:a2a2b79f602aca681188fbf3564006e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string that is a substring of this string.  <a href="#a2a2b79f602aca681188fbf3564006e87">More...</a><br/></td></tr>
<tr class="separator:a2a2b79f602aca681188fbf3564006e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c2a9f9193d66c9844d642d838fb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aca9c2a9f9193d66c9844d642d838fb51">copy</a> (sal_Int32 beginIndex, sal_Int32 count) const </td></tr>
<tr class="memdesc:aca9c2a9f9193d66c9844d642d838fb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string that is a substring of this string.  <a href="#aca9c2a9f9193d66c9844d642d838fb51">More...</a><br/></td></tr>
<tr class="separator:aca9c2a9f9193d66c9844d642d838fb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a87a7f1a05350b00fa7ddbcaeacb595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a9a87a7f1a05350b00fa7ddbcaeacb595">concat</a> (const <a class="el" href="a00148.html">OString</a> &amp;str) const </td></tr>
<tr class="memdesc:a9a87a7f1a05350b00fa7ddbcaeacb595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the specified string to the end of this string.  <a href="#a9a87a7f1a05350b00fa7ddbcaeacb595">More...</a><br/></td></tr>
<tr class="separator:a9a87a7f1a05350b00fa7ddbcaeacb595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c6fcbbc4136e12e0aa6c08dc7eb38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ad6c6fcbbc4136e12e0aa6c08dc7eb38d">replaceAt</a> (sal_Int32 index, sal_Int32 count, const <a class="el" href="a00148.html">OString</a> &amp;newStr) const </td></tr>
<tr class="memdesc:ad6c6fcbbc4136e12e0aa6c08dc7eb38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing n = count characters from position index in this string with newStr.  <a href="#ad6c6fcbbc4136e12e0aa6c08dc7eb38d">More...</a><br/></td></tr>
<tr class="separator:ad6c6fcbbc4136e12e0aa6c08dc7eb38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2ccb7318f9f71287420a4ce83973eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aad2ccb7318f9f71287420a4ce83973eb">replace</a> (<a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> oldChar, <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> newChar) const </td></tr>
<tr class="memdesc:aad2ccb7318f9f71287420a4ce83973eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.  <a href="#aad2ccb7318f9f71287420a4ce83973eb">More...</a><br/></td></tr>
<tr class="separator:aad2ccb7318f9f71287420a4ce83973eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6037f9899f3ca372d433b5d3b6b410d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a6037f9899f3ca372d433b5d3b6b410d9">replaceFirst</a> (<a class="el" href="a00148.html">OString</a> const &amp;from, <a class="el" href="a00148.html">OString</a> const &amp;to, sal_Int32 *index=NULL) const </td></tr>
<tr class="memdesc:a6037f9899f3ca372d433b5d3b6b410d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing the first occurrence of a given substring with another substring.  <a href="#a6037f9899f3ca372d433b5d3b6b410d9">More...</a><br/></td></tr>
<tr class="separator:a6037f9899f3ca372d433b5d3b6b410d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae304ffd50763e6299ca33539f32982cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae304ffd50763e6299ca33539f32982cd">replaceAll</a> (<a class="el" href="a00148.html">OString</a> const &amp;from, <a class="el" href="a00148.html">OString</a> const &amp;to) const </td></tr>
<tr class="memdesc:ae304ffd50763e6299ca33539f32982cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of a given substring with another substring.  <a href="#ae304ffd50763e6299ca33539f32982cd">More...</a><br/></td></tr>
<tr class="separator:ae304ffd50763e6299ca33539f32982cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da03994f37e2aa6f46a54656348f1b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a4da03994f37e2aa6f46a54656348f1b5">toAsciiLowerCase</a> () const </td></tr>
<tr class="memdesc:a4da03994f37e2aa6f46a54656348f1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from this string all ASCII uppercase characters (65-90) to ASCII lowercase characters (97-122).  <a href="#a4da03994f37e2aa6f46a54656348f1b5">More...</a><br/></td></tr>
<tr class="separator:a4da03994f37e2aa6f46a54656348f1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cef32e692f6189596bb83bf18b0fa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a88cef32e692f6189596bb83bf18b0fa3">toAsciiUpperCase</a> () const </td></tr>
<tr class="memdesc:a88cef32e692f6189596bb83bf18b0fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from this string all ASCII lowercase characters (97-122) to ASCII uppercase characters (65-90).  <a href="#a88cef32e692f6189596bb83bf18b0fa3">More...</a><br/></td></tr>
<tr class="separator:a88cef32e692f6189596bb83bf18b0fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774da45847400007b96971b272c4f385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a774da45847400007b96971b272c4f385">trim</a> () const </td></tr>
<tr class="memdesc:a774da45847400007b96971b272c4f385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from removing white space from both ends of the string.  <a href="#a774da45847400007b96971b272c4f385">More...</a><br/></td></tr>
<tr class="separator:a774da45847400007b96971b272c4f385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a99ab2fb2827c8d4dcbdab7240acb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ac9a99ab2fb2827c8d4dcbdab7240acb2">getToken</a> (sal_Int32 token, <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> cTok, sal_Int32 &amp;index) const </td></tr>
<tr class="memdesc:ac9a99ab2fb2827c8d4dcbdab7240acb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a token in the string.  <a href="#ac9a99ab2fb2827c8d4dcbdab7240acb2">More...</a><br/></td></tr>
<tr class="separator:ac9a99ab2fb2827c8d4dcbdab7240acb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba090468721022b098a2ef0c08dd4372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aba090468721022b098a2ef0c08dd4372">getToken</a> (sal_Int32 count, char separator) const </td></tr>
<tr class="memdesc:aba090468721022b098a2ef0c08dd4372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a token from the string.  <a href="#aba090468721022b098a2ef0c08dd4372">More...</a><br/></td></tr>
<tr class="separator:aba090468721022b098a2ef0c08dd4372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b7745436817f13b72d03835dfbbae1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#af8b7745436817f13b72d03835dfbbae1">toBoolean</a> () const </td></tr>
<tr class="memdesc:af8b7745436817f13b72d03835dfbbae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Boolean value from this string.  <a href="#af8b7745436817f13b72d03835dfbbae1">More...</a><br/></td></tr>
<tr class="separator:af8b7745436817f13b72d03835dfbbae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a627e16ae35ee506331ddd8d00cc69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a04a627e16ae35ee506331ddd8d00cc69">toChar</a> () const </td></tr>
<tr class="memdesc:a04a627e16ae35ee506331ddd8d00cc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first character from this string.  <a href="#a04a627e16ae35ee506331ddd8d00cc69">More...</a><br/></td></tr>
<tr class="separator:a04a627e16ae35ee506331ddd8d00cc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033da0eb6b38c955d94877df5347794b"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a033da0eb6b38c955d94877df5347794b">toInt32</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a033da0eb6b38c955d94877df5347794b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int32 value from this string.  <a href="#a033da0eb6b38c955d94877df5347794b">More...</a><br/></td></tr>
<tr class="separator:a033da0eb6b38c955d94877df5347794b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ce74f5a8ea906e6ea5bb28a4b2f1c7"><td class="memItemLeft" align="right" valign="top">sal_uInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a10ce74f5a8ea906e6ea5bb28a4b2f1c7">toUInt32</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a10ce74f5a8ea906e6ea5bb28a4b2f1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uint32 value from this string.  <a href="#a10ce74f5a8ea906e6ea5bb28a4b2f1c7">More...</a><br/></td></tr>
<tr class="separator:a10ce74f5a8ea906e6ea5bb28a4b2f1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a51db6d09f140de2c91871baca775a3"><td class="memItemLeft" align="right" valign="top">sal_Int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a5a51db6d09f140de2c91871baca775a3">toInt64</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a5a51db6d09f140de2c91871baca775a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int64 value from this string.  <a href="#a5a51db6d09f140de2c91871baca775a3">More...</a><br/></td></tr>
<tr class="separator:a5a51db6d09f140de2c91871baca775a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc09868ce8399e269544d84b71bae51"><td class="memItemLeft" align="right" valign="top">sal_uInt64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#accc09868ce8399e269544d84b71bae51">toUInt64</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:accc09868ce8399e269544d84b71bae51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uint64 value from this string.  <a href="#accc09868ce8399e269544d84b71bae51">More...</a><br/></td></tr>
<tr class="separator:accc09868ce8399e269544d84b71bae51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3af99714b9c6146cd8ffb3ebfb22d9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a0a3af99714b9c6146cd8ffb3ebfb22d9">toFloat</a> () const </td></tr>
<tr class="memdesc:a0a3af99714b9c6146cd8ffb3ebfb22d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the float value from this string.  <a href="#a0a3af99714b9c6146cd8ffb3ebfb22d9">More...</a><br/></td></tr>
<tr class="separator:a0a3af99714b9c6146cd8ffb3ebfb22d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5972e7117b9388fa718f7ea002147184"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a5972e7117b9388fa718f7ea002147184">toDouble</a> () const </td></tr>
<tr class="memdesc:a5972e7117b9388fa718f7ea002147184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double value from this string.  <a href="#a5972e7117b9388fa718f7ea002147184">More...</a><br/></td></tr>
<tr class="separator:a5972e7117b9388fa718f7ea002147184"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a35ef353c45b4d4cfee27299ccbb2af11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a35ef353c45b4d4cfee27299ccbb2af11">number</a> (int i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a35ef353c45b4d4cfee27299ccbb2af11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the integer argument.  <a href="#a35ef353c45b4d4cfee27299ccbb2af11">More...</a><br/></td></tr>
<tr class="separator:a35ef353c45b4d4cfee27299ccbb2af11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ef6b3c16e87efcaeced9246de906b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a7a1ef6b3c16e87efcaeced9246de906b">number</a> (unsigned int i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a7a1ef6b3c16e87efcaeced9246de906b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a7a1ef6b3c16e87efcaeced9246de906b">More...</a><br/></td></tr>
<tr class="separator:a7a1ef6b3c16e87efcaeced9246de906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c181a370f9975121037cb184b99a3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ac8c181a370f9975121037cb184b99a3b">number</a> (long i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:ac8c181a370f9975121037cb184b99a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ac8c181a370f9975121037cb184b99a3b">More...</a><br/></td></tr>
<tr class="separator:ac8c181a370f9975121037cb184b99a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200e3d5fef2bd7bedbb2e40247153537"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a200e3d5fef2bd7bedbb2e40247153537">number</a> (unsigned long i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a200e3d5fef2bd7bedbb2e40247153537"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a200e3d5fef2bd7bedbb2e40247153537">More...</a><br/></td></tr>
<tr class="separator:a200e3d5fef2bd7bedbb2e40247153537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fec2b0357b35eb9667ff24147d42ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a64fec2b0357b35eb9667ff24147d42ad">number</a> (long long ll, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a64fec2b0357b35eb9667ff24147d42ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a64fec2b0357b35eb9667ff24147d42ad">More...</a><br/></td></tr>
<tr class="separator:a64fec2b0357b35eb9667ff24147d42ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359f108f34b056d6392958d0bc4d7e06"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a359f108f34b056d6392958d0bc4d7e06">number</a> (unsigned long long ll, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a359f108f34b056d6392958d0bc4d7e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a359f108f34b056d6392958d0bc4d7e06">More...</a><br/></td></tr>
<tr class="separator:a359f108f34b056d6392958d0bc4d7e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d5d3f38401c364d08c4ee81bd7a065"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#af6d5d3f38401c364d08c4ee81bd7a065">number</a> (float f)</td></tr>
<tr class="memdesc:af6d5d3f38401c364d08c4ee81bd7a065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the float argument.  <a href="#af6d5d3f38401c364d08c4ee81bd7a065">More...</a><br/></td></tr>
<tr class="separator:af6d5d3f38401c364d08c4ee81bd7a065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60c05ca3e6850c1ea9e3c776664d456"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae60c05ca3e6850c1ea9e3c776664d456">number</a> (double d)</td></tr>
<tr class="memdesc:ae60c05ca3e6850c1ea9e3c776664d456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the double argument.  <a href="#ae60c05ca3e6850c1ea9e3c776664d456">More...</a><br/></td></tr>
<tr class="separator:ae60c05ca3e6850c1ea9e3c776664d456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d98306d52ef7ba741fa934f6c3e92d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a2d98306d52ef7ba741fa934f6c3e92d6">valueOf</a> (<a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a> b)</td></tr>
<tr class="memdesc:a2d98306d52ef7ba741fa934f6c3e92d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the sal_Bool argument.  <a href="#a2d98306d52ef7ba741fa934f6c3e92d6">More...</a><br/></td></tr>
<tr class="separator:a2d98306d52ef7ba741fa934f6c3e92d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c42c611eb44213b12e708043c9eda"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aa54c42c611eb44213b12e708043c9eda">boolean</a> (bool b)</td></tr>
<tr class="memdesc:aa54c42c611eb44213b12e708043c9eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the boolean argument.  <a href="#aa54c42c611eb44213b12e708043c9eda">More...</a><br/></td></tr>
<tr class="separator:aa54c42c611eb44213b12e708043c9eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabbf098cb9433978088f3a2dd035039"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#acabbf098cb9433978088f3a2dd035039">valueOf</a> (<a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> c)</td></tr>
<tr class="memdesc:acabbf098cb9433978088f3a2dd035039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the char argument.  <a href="#acabbf098cb9433978088f3a2dd035039">More...</a><br/></td></tr>
<tr class="separator:acabbf098cb9433978088f3a2dd035039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaee3f20592c53f5e55b25676b3dd02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a2aaee3f20592c53f5e55b25676b3dd02">valueOf</a> (sal_Int32 i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a2aaee3f20592c53f5e55b25676b3dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the int argument.  <a href="#a2aaee3f20592c53f5e55b25676b3dd02">More...</a><br/></td></tr>
<tr class="separator:a2aaee3f20592c53f5e55b25676b3dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1db6a4e8fc99e211f6ed861746ab9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aca1db6a4e8fc99e211f6ed861746ab9a">valueOf</a> (sal_Int64 ll, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:aca1db6a4e8fc99e211f6ed861746ab9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the long argument.  <a href="#aca1db6a4e8fc99e211f6ed861746ab9a">More...</a><br/></td></tr>
<tr class="separator:aca1db6a4e8fc99e211f6ed861746ab9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae3dff03492d44fa0ca2b1b4307ed66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a0ae3dff03492d44fa0ca2b1b4307ed66">valueOf</a> (float f)</td></tr>
<tr class="memdesc:a0ae3dff03492d44fa0ca2b1b4307ed66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the float argument.  <a href="#a0ae3dff03492d44fa0ca2b1b4307ed66">More...</a><br/></td></tr>
<tr class="separator:a0ae3dff03492d44fa0ca2b1b4307ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10cb8e21ebacd5e41465ef0414ae63f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#af10cb8e21ebacd5e41465ef0414ae63f">valueOf</a> (double d)</td></tr>
<tr class="memdesc:af10cb8e21ebacd5e41465ef0414ae63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the double argument.  <a href="#af10cb8e21ebacd5e41465ef0414ae63f">More...</a><br/></td></tr>
<tr class="separator:af10cb8e21ebacd5e41465ef0414ae63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7b20715b6defeb01283d393ce8473665"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b20715b6defeb01283d393ce8473665"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a7b20715b6defeb01283d393ce8473665">pData</a> = NULL</td></tr>
<tr class="memdesc:a7b20715b6defeb01283d393ce8473665"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a character buffer array.  <a href="#a7b20715b6defeb01283d393ce8473665">More...</a><br/></td></tr>
<tr class="separator:a7b20715b6defeb01283d393ce8473665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0d7ab904718c7b41cb40c88187d92c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00386.html#a0d52b8e6a0f37d9fb60db1502fbde90b">rtl_string_newFromStr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a9b0d7ab904718c7b41cb40c88187d92c">pData</a></td></tr>
<tr class="separator:a9b0d7ab904718c7b41cb40c88187d92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd576caa64faaa3a6222f5cdba223f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#abcd576caa64faaa3a6222f5cdba223f4">else</a></td></tr>
<tr class="separator:abcd576caa64faaa3a6222f5cdba223f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4b8112707f012a0aa829901fdb152709"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a4b8112707f012a0aa829901fdb152709">operator==</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:a4b8112707f012a0aa829901fdb152709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a7f495d22ebac6166b24d101d46634"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ad1a7f495d22ebac6166b24d101d46634">operator!=</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:ad1a7f495d22ebac6166b24d101d46634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab369dfccf3f28ee88a5ceb9b4a76de2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ab369dfccf3f28ee88a5ceb9b4a76de2a">operator&lt;</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:ab369dfccf3f28ee88a5ceb9b4a76de2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae326fe19a8030ff4fba5add8289b6c20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#ae326fe19a8030ff4fba5add8289b6c20">operator&gt;</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:ae326fe19a8030ff4fba5add8289b6c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f51636936328029c4e34ffa741a4aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a1f51636936328029c4e34ffa741a4aee">operator&lt;=</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:a1f51636936328029c4e34ffa741a4aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38d7871c50d3d9ee3b5196270e9da55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#aa38d7871c50d3d9ee3b5196270e9da55">operator&gt;=</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:aa38d7871c50d3d9ee3b5196270e9da55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6314053bf068c27350f32cb17ab0363"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6314053bf068c27350f32cb17ab0363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#af6314053bf068c27350f32cb17ab0363">operator==</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const T &amp;value)</td></tr>
<tr class="separator:af6314053bf068c27350f32cb17ab0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea948a942e2dd1b22b23f149b77de732"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea948a942e2dd1b22b23f149b77de732"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#aea948a942e2dd1b22b23f149b77de732">operator==</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, T &amp;value)</td></tr>
<tr class="separator:aea948a942e2dd1b22b23f149b77de732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1679ec17be557862b2a9c80bb44aaf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1679ec17be557862b2a9c80bb44aaf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#ac1679ec17be557862b2a9c80bb44aaf0">operator==</a> (const T &amp;value, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:ac1679ec17be557862b2a9c80bb44aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b04259d96ad7c103d0f8a9ffbca5271"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b04259d96ad7c103d0f8a9ffbca5271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a8b04259d96ad7c103d0f8a9ffbca5271">operator==</a> (T &amp;value, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:a8b04259d96ad7c103d0f8a9ffbca5271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271532c250e680f70a617d0733f15b46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a271532c250e680f70a617d0733f15b46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a271532c250e680f70a617d0733f15b46">operator==</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr, T &amp;literal)</td></tr>
<tr class="memdesc:a271532c250e680f70a617d0733f15b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a271532c250e680f70a617d0733f15b46">More...</a><br/></td></tr>
<tr class="separator:a271532c250e680f70a617d0733f15b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a018460d39222e88c423f108ed956"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c2a018460d39222e88c423f108ed956"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a2c2a018460d39222e88c423f108ed956">operator==</a> (T &amp;literal, const <a class="el" href="a00148.html">OString</a> &amp;rStr)</td></tr>
<tr class="memdesc:a2c2a018460d39222e88c423f108ed956"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a2c2a018460d39222e88c423f108ed956">More...</a><br/></td></tr>
<tr class="separator:a2c2a018460d39222e88c423f108ed956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd011410af089ce813621ff4364cf05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9dd011410af089ce813621ff4364cf05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a9dd011410af089ce813621ff4364cf05">operator!=</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, const T &amp;value)</td></tr>
<tr class="separator:a9dd011410af089ce813621ff4364cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dd82c64739902c99c6b86d74d46f81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62dd82c64739902c99c6b86d74d46f81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a62dd82c64739902c99c6b86d74d46f81">operator!=</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr1, T &amp;value)</td></tr>
<tr class="separator:a62dd82c64739902c99c6b86d74d46f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88b80a4d5ac123c20d9c1e00aba694a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af88b80a4d5ac123c20d9c1e00aba694a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#af88b80a4d5ac123c20d9c1e00aba694a">operator!=</a> (const T &amp;value, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:af88b80a4d5ac123c20d9c1e00aba694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff234951576ff92f817bfb4473112727"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff234951576ff92f817bfb4473112727"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#aff234951576ff92f817bfb4473112727">operator!=</a> (T &amp;value, const <a class="el" href="a00148.html">OString</a> &amp;rStr2)</td></tr>
<tr class="separator:aff234951576ff92f817bfb4473112727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad775e2225f757122548641c674fbd913"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad775e2225f757122548641c674fbd913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#ad775e2225f757122548641c674fbd913">operator!=</a> (const <a class="el" href="a00148.html">OString</a> &amp;rStr, T &amp;literal)</td></tr>
<tr class="memdesc:ad775e2225f757122548641c674fbd913"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#ad775e2225f757122548641c674fbd913">More...</a><br/></td></tr>
<tr class="separator:ad775e2225f757122548641c674fbd913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45add47a019d4a53d12266aa18e8371e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45add47a019d4a53d12266aa18e8371e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00148.html#a45add47a019d4a53d12266aa18e8371e">operator!=</a> (T &amp;literal, const <a class="el" href="a00148.html">OString</a> &amp;rStr)</td></tr>
<tr class="memdesc:a45add47a019d4a53d12266aa18e8371e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a45add47a019d4a53d12266aa18e8371e">More...</a><br/></td></tr>
<tr class="separator:a45add47a019d4a53d12266aa18e8371e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eec9430a89671ff921a02015a326c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html#a4eec9430a89671ff921a02015a326c03">operator+</a> (const <a class="el" href="a00148.html">OString</a> &amp;str1, const <a class="el" href="a00148.html">OString</a> &amp;str2)</td></tr>
<tr class="separator:a4eec9430a89671ff921a02015a326c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This String class provide base functionality for C++ like 8-Bit character array handling. </p>
<p>The advantage of this class is, that it handle all the memory management for you - and it do it more efficient. If you assign a string to another string, the data of both strings are shared (without any copy operation or memory allocation) as long as you do not change the string. This class stores also the length of the string, so that many operations are faster as the C-str-functions.</p>
<p>This class provides only readonly string handling. So you could create a string and you could only query the content from this string. It provides also functionality to change the string, but this results in every case in a new string instance (in the most cases with an memory allocation). You don't have functionality to change the content of the string. If you want to change the string content, then you should use the <a class="el" href="a00149.html" title="A string buffer implements a mutable sequence of characters. ">OStringBuffer</a> class, which provides these functionalities and avoid too much memory allocation.</p>
<p>The design of this class is similar to the string classes in Java and so more people should have fewer understanding problems when they use this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abdbfeafcd9fffb3de8ae92e034591a72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string containing no characters. </p>

</div>
</div>
<a class="anchor" id="aaa56e932cbed3343dc22bc72785e7364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a640d18f0ca3e80cd497dc54f43373d28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramtype">rtl_String *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee9db46533a6bf69adfabba1e885dec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramtype">rtl_String *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#a30b3dd1d6058d15544996570e4f14244">__sal_NoAcquire</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> data without acquiring it. </p>
<p>Takeover of ownership.</p>
<p>The SAL_NO_ACQUIRE dummy parameter is only there to distinguish this from other constructors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a636d5f2bbb47aa148334a44d82b6a783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from a single character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad892314d33d8cfd6f2f653aadec59e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from a character buffer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a character array. </td></tr>
    <tr><td class="paramname">length</td><td>the number of character which should be copied. The character array length must be greater or equal than this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0805f7647f0c8887b7b0f8bf8eb3ea65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::OString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>convertFlags</em> = <code><a class="el" href="a00386.html#a8edb860d1ae6e2db3c161242d6ace6a6">OUSTRING_TO_OSTRING_CVTFLAGS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from a Unicode character buffer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a Unicode character array. </td></tr>
    <tr><td class="paramname">length</td><td>the number of character which should be converted. The Unicode character array length must be greater or equal than this value. </td></tr>
    <tr><td class="paramname">encoding</td><td>the text encoding in which the Unicode character sequence should be converted. </td></tr>
    <tr><td class="paramname">convertFlags</td><td>flags which controls the conversion. see RTL_UNICODETOTEXT_FLAGS_...</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>is thrown if an out-of-memory condition occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad480f8774cc33a66b9b3d3a7651cb4a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::~OString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the string data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa54c42c611eb44213b12e708043c9eda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::boolean </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the boolean argument. </p>
<p>If the argument is true, the string "true" is returned. If the argument is false, the string "false" is returned. This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>a bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a6ca9f8b46a516429031e091221c808ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rtl::OString::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the string, i.e, makes a zero-character string. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.4 </dd></dl>

</div>
</div>
<a class="anchor" id="af094b7ac4e784ea736cdf010b0df0156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::compareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a015694f6b7f941174b4782a9e25dd455"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::compareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>maxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings with an maximum count of characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rObj</td><td>the object to be compared. </td></tr>
    <tr><td class="paramname">maxLength</td><td>the maximum count of characters to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a9a87a7f1a05350b00fa7ddbcaeacb595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the specified string to the end of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string that is concatenated to the end of this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string that represents the concatenation of this string followed by the string argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a2b79f602aca681188fbf3564006e87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::copy </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>beginIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string that is a substring of this string. </p>
<p>The substring begins at the specified beginIndex. If beginIndex is negative or be greater than the length of this string, behaviour is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIndex</td><td>the beginning index, inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified substring. </dd></dl>

</div>
</div>
<a class="anchor" id="aca9c2a9f9193d66c9844d642d838fb51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::copy </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string that is a substring of this string. </p>
<p>The substring begins at the specified beginIndex and contains count characters. If either beginIndex or count are negative, or beginIndex + count are greater than the length of this string then behaviour is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIndex</td><td>the beginning index, inclusive. </td></tr>
    <tr><td class="paramname">count</td><td>the number of characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified substring. </dd></dl>

</div>
</div>
<a class="anchor" id="adb94f9b21e139043c5d6909fa23c1e09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::endsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string ends with a given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest. Available since LibreOffice 4.2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the end of this string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="afd9c01ebdb31b57171135b47e203c48e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::endsWith </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aca2afd8c18ca6b22dbb86195e7abb4b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::endsWithL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>strLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string ends with a given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared; must not be null and must point to memory of at least strLength bytes</td></tr>
    <tr><td class="paramname">strLength</td><td>the length of the substring; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the end of this string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a5d3f22f2f95e44d6d8c664c9764179f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a07701372f5ba265b4ccd2f928bed8f91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::equalsIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ASCII lowercase comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string, ignoring the case. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af010e246b922e736e2ff845d8c9e4b63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a>&lt; T, bool &gt;::Type rtl::OString::equalsIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>asciiStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ASCII lowercase comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string, ignoring the case. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and</p>
<ol type="1">
<li>The ASCII string must be NULL-terminated. This function can't be used for language specific comparison.</li>
</ol>
<p>Note: The argument type is always either char* or const char*, the return type is bool. The template is used only for technical reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abdcbbc4fbbc6e3f56971e32df09a6080"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::equalsIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>asciiStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36683c350429ca8833a93167a7fd894f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::equalsIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="adc8a84c459e462c65b217416745ffc1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::equalsIgnoreAsciiCaseL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ASCII lowercase comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string, ignoring the case. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and</p>
<ol type="1">
<li>The ASCII string must be greater or equal in length as asciiStrLength. This function can't be used for language specific comparison.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of the ascii string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a98aa87069bcb9c93143271fdf999ba98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::equalsL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string. The ASCII string must be NULL-terminated and must be greater or equal as length. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a character array. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8623ff42d0d50803a2406830d3fc37e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::getLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of this string. </p>
<p>The length is equal to the number of characters in this string.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the sequence of characters represented by this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a56df3c85362dcde3374245cbb4476e0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>* rtl::OString::getStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the characters of this string. </p>
<p>The returned pointer is guaranteed to point to a null-terminated byte string. But note that this string object may contain embedded null characters, which will thus also be embedded in the returned null-terminated byte string.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a null-terminated byte string representing the characters of this string object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9a99ab2fb2827c8d4dcbdab7240acb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00148.html">OString</a> rtl::OString::getToken </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>cTok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a token in the string. </p>
<p>Example: sal_Int32 nIndex = 0; do { ... <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> aToken = aStr.getToken( 0, ';', nIndex ); ... } while ( nIndex &gt;= 0 );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the number of the token to return. </td></tr>
    <tr><td class="paramname">cTok</td><td>the character which separate the tokens. </td></tr>
    <tr><td class="paramname">index</td><td>the position at which the token is searched in the string. The index must not be greater than the length of the string. This param is set to the position of the next token or to -1, if it is the last token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the token; if either token or index is negative, an empty token is returned (and index is set to -1) </dd></dl>

</div>
</div>
<a class="anchor" id="aba090468721022b098a2ef0c08dd4372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00148.html">OString</a> rtl::OString::getToken </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a token from the string. </p>
<p>The same as getToken(sal_Int32, sal_Char, sal_Int32 &amp;), but always passing in 0 as the start index in the third argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of the token to return, starting with 0 </td></tr>
    <tr><td class="paramname">separator</td><td>the character which separates the tokens</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given token, or an empty string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ad037bbbc7b3a63d9a576e49b6681ce74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::hashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a hashcode for this string. </p>
<dl class="section return"><dt>Returns</dt><dd>a hash code value for this object.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00150.html" title="A helper to use OStrings with hash maps. ">rtl::OStringHash</a> for convenient use of std::unordered_map </dd></dl>

</div>
</div>
<a class="anchor" id="abcd46138514d3877b15d82fb7e186aac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T &gt;::length&#160;</td>
          <td class="paramname"> = <code>=&#160;0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a90defe2edc10cce082d9e0b68b406698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::indexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to be located. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the search from. The index must be greater or equal than 0 and less or equal as the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first occurrence of the character in the character sequence represented by this string that is greater than or equal to fromIndex, or -1 if the character does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a37610494aa7ae42d9d595b5c2734fef4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::indexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. </p>
<p>If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the search from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string at the starting index, then the index of the first character of the first such substring is returned. If it does not occur as a substring starting at fromIndex or beyond, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a482c74454709d9b58e42ee570034e8b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, sal_Int32 &gt;::Type rtl::OString::indexOf </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ab237c155f542d87e6856a7f2bc1d0427"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::indexOfL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. </p>
<p>If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the substring. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the search from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string at the starting index, then the index of the first character of the first such substring is returned. If it does not occur as a substring starting at fromIndex or beyond, -1 is returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aba09070a2bfd4052b672d027f07d3009"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a string is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the string is empty; false, otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.4 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ac873a31711760ae82a2044dfd71eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified character, searching backward starting at the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the last occurrence of the character in the character sequence represented by this string, or -1 if the character does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bc60ca9a3aab4c21bcec95469103b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified character, searching backward starting before the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to be located. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index before which to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the last occurrence of the character in the character sequence represented by this string that is less than fromIndex, or -1 if the character does not occur before that point. </dd></dl>

</div>
</div>
<a class="anchor" id="aeceb274b014f492d085ff7386aaa7d3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the end. </p>
<p>The returned index indicates the starting index of the substring in this string. If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string, then the index of the first character of the last such substring is returned. If it does not occur as a substring, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae64a51a44f987072b02cf4a6d4d8f5ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified substring, searching backward starting before the specified index. </p>
<p>The returned index indicates the starting index of the substring in this string. If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index before which to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string before the starting index, then the index of the first character of the last such substring is returned. Otherwise, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6bd46105d7b3db98b1e03c3d3b481d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string. </p>
<p>The result is true if and only if the second string appears as a substring of this string, at the given position. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object (substring) to be compared. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the comparion from. The index must be greater or equal than 0 and less or equal as the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str match with the characters in the string at the given position; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a51810e1b68fe8adf2b3ba34a0606b1e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a0f8c697a4dd1845e3f7d174eabbaf6a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::matchIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string, ignoring the case of ASCII letters. </p>
<p>The result is true if and only if the second string appears as a substring of this string, at the given position. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object (substring) to be compared. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the comparion from. The index must be greater or equal than 0 and less or equal as the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str match with the characters in the string at the given position; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa596697514c67acee8c1875d1ca2a25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::matchIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae6644ed0bae62b4cf0077d018facf514"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::matchL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>strLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared; must not be null and must point to memory of at least strLength bytes</td></tr>
    <tr><td class="paramname">strLength</td><td>the length of the substring; must be non-negative</td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index into this string to start the comparison at; must be non-negative and not greater than this string's length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str is contained as a substring of this string at the given fromIndex</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a35ef353c45b4d4cfee27299ccbb2af11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the integer argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>an integer value </td></tr>
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a7a1ef6b3c16e87efcaeced9246de906b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ac8c181a370f9975121037cb184b99a3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a200e3d5fef2bd7bedbb2e40247153537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a64fec2b0357b35eb9667ff24147d42ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a359f108f34b056d6392958d0bc4d7e06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="af6d5d3f38401c364d08c4ee81bd7a065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the float argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ae60c05ca3e6850c1ea9e3c776664d456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::number </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the double argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a1362b7dd860f5fe07ad45b635a15e96d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00148.html">OString</a>&amp; rtl::OString::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7f76aec26dc61b16bcd36ec009f4988"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00148.html">OString</a>&amp; rtl::OString::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd5dd6deae8e6f8ec764512fc1aa3208"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, <a class="el" href="a00148.html">OString</a>&amp; &gt;::Type rtl::OString::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aabedf0030558d9aa34ce0bd9cddfde83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> rtl::OString::operator[] </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to individual characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>must be non-negative and less than length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character at the given index.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.5 </dd></dl>

</div>
</div>
<a class="anchor" id="aad2ccb7318f9f71287420a4ce83973eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>oldChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>newChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar. </p>
<p>If the character oldChar does not occur in the character sequence represented by this object, then the string is assigned with str.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldChar</td><td>the old character. </td></tr>
    <tr><td class="paramname">newChar</td><td>the new character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string derived from this string by replacing every occurrence of oldChar with newChar. </dd></dl>

</div>
</div>
<a class="anchor" id="ae304ffd50763e6299ca33539f32982cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::replaceAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the substring to be replaced</td></tr>
    <tr><td class="paramname">to</td><td>the replacing substring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ad6c6fcbbc4136e12e0aa6c08dc7eb38d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::replaceAt </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing n = count characters from position index in this string with newStr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the replacing index in str. The index must be greater or equal as 0 and less or equal as the length of the string. </td></tr>
    <tr><td class="paramname">count</td><td>the count of characters that will replaced The count must be greater or equal as 0 and less or equal as the length of the string minus index. </td></tr>
    <tr><td class="paramname">newStr</td><td>the new substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new string. </dd></dl>

</div>
</div>
<a class="anchor" id="a6037f9899f3ca372d433b5d3b6b410d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::replaceFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>the substring to be replaced</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>the replacing substring</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index; if the pointer is non-null: upon entry to the function, its value is the index into the this string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than this string's length; upon exit from the function its value is the index into this string at which the replacement took place or -1 if no replacement took place; if the pointer is null, searching always starts at index 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aba6ef7a47e824c10a9cde0edd83d3caf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::reverseCompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings in reverse order. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a64551f449806c349c250a1ea16f353c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::startsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string starts with a given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest. Available since LibreOffice 4.2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the start of this string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad1fb5e6b0b72ad3db891fb529798aa76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::startsWith </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa48485dac043240fc732166fa641ffe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::startsWithIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string starts with a given string, ignoring the case of ASCII letters. </p>
<p>Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the start of this string, ignoring the case of ASCII letters ("A"&ndash;"Z" and "a"&ndash;"z")</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ad60e102f79bf625589d0e3b5750a8ceb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OString::startsWithIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a4da03994f37e2aa6f46a54656348f1b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::toAsciiLowerCase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from this string all ASCII uppercase characters (65-90) to ASCII lowercase characters (97-122). </p>
<p>This function can't be used for language specific conversion. If the string doesn't contain characters which must be converted, then the new string is assigned with str.</p>
<dl class="section return"><dt>Returns</dt><dd>the string, converted to ASCII lowercase. </dd></dl>

</div>
</div>
<a class="anchor" id="a88cef32e692f6189596bb83bf18b0fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::toAsciiUpperCase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from this string all ASCII lowercase characters (97-122) to ASCII uppercase characters (65-90). </p>
<p>This function can't be used for language specific conversion. If the string doesn't contain characters which must be converted, then the new string is assigned with str.</p>
<dl class="section return"><dt>Returns</dt><dd>the string, converted to ASCII uppercase. </dd></dl>

</div>
</div>
<a class="anchor" id="af8b7745436817f13b72d03835dfbbae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OString::toBoolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Boolean value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>true, if the string is 1 or "True" in any ASCII case. false in any other case. </dd></dl>

</div>
</div>
<a class="anchor" id="a04a627e16ae35ee506331ddd8d00cc69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> rtl::OString::toChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first character from this string. </p>
<dl class="section return"><dt>Returns</dt><dd>the first character from this string or 0, if this string is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a5972e7117b9388fa718f7ea002147184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rtl::OString::toDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the double value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>the double represented from this string. 0.0 if this string represents no number. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a3af99714b9c6146cd8ffb3ebfb22d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float rtl::OString::toFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the float value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>the float represented from this string. 0.0 if this string represents no number. </dd></dl>

</div>
</div>
<a class="anchor" id="a033da0eb6b38c955d94877df5347794b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OString::toInt32 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the int32 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int32 represented from this string. 0 if this string represents no number or one of too large magnitude. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a51db6d09f140de2c91871baca775a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int64 rtl::OString::toInt64 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the int64 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int64 represented from this string. 0 if this string represents no number or one of too large magnitude. </dd></dl>

</div>
</div>
<a class="anchor" id="a10ce74f5a8ea906e6ea5bb28a4b2f1c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_uInt32 rtl::OString::toUInt32 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the uint32 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uint32 represented from this string. 0 if this string represents no number or one of too large magnitude.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.2 </dd></dl>

</div>
</div>
<a class="anchor" id="accc09868ce8399e269544d84b71bae51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_uInt64 rtl::OString::toUInt64 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the uint64 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uint64 represented from this string. 0 if this string represents no number or one of too large magnitude.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a774da45847400007b96971b272c4f385"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00148.html">OString</a> rtl::OString::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from removing white space from both ends of the string. </p>
<p>All characters that have codes less than or equal to 32 (the space character) are considered to be white space. If the string doesn't contain white spaces at both ends, then the new string is assigned with str.</p>
<dl class="section return"><dt>Returns</dt><dd>the string, with white space removed from the front and end. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d98306d52ef7ba741fa934f6c3e92d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::valueOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the sal_Bool argument. </p>
<p>If the sal_Bool is true, the string "true" is returned. If the sal_Bool is false, the string "false" is returned. This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>a sal_Bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000026">Deprecated:</a></b></dt><dd>use <a class="el" href="a00148.html#aa54c42c611eb44213b12e708043c9eda" title="Returns the string representation of the boolean argument. ">boolean()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acabbf098cb9433978088f3a2dd035039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::valueOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the char argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000027">Deprecated:</a></b></dt><dd>use operator, function or constructor taking char or sal_Unicode argument </dd></dl>

</div>
</div>
<a class="anchor" id="a2aaee3f20592c53f5e55b25676b3dd02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::valueOf </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the int argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>a int32. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000028">Deprecated:</a></b></dt><dd>use <a class="el" href="a00148.html#a35ef353c45b4d4cfee27299ccbb2af11" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca1db6a4e8fc99e211f6ed861746ab9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::valueOf </td>
          <td>(</td>
          <td class="paramtype">sal_Int64&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the long argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>a int64. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000029">Deprecated:</a></b></dt><dd>use <a class="el" href="a00148.html#a35ef353c45b4d4cfee27299ccbb2af11" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ae3dff03492d44fa0ca2b1b4307ed66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::valueOf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the float argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000030">Deprecated:</a></b></dt><dd>use <a class="el" href="a00148.html#a35ef353c45b4d4cfee27299ccbb2af11" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af10cb8e21ebacd5e41465ef0414ae63f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00148.html">OString</a> rtl::OString::valueOf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the double argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000031">Deprecated:</a></b></dt><dd>use <a class="el" href="a00148.html#a35ef353c45b4d4cfee27299ccbb2af11" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad1a7f495d22ebac6166b24d101d46634"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9dd011410af089ce813621ff4364cf05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a62dd82c64739902c99c6b86d74d46f81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af88b80a4d5ac123c20d9c1e00aba694a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff234951576ff92f817bfb4473112727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad775e2225f757122548641c674fbd913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a45add47a019d4a53d12266aa18e8371e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a4eec9430a89671ff921a02015a326c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00148.html">OString</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab369dfccf3f28ee88a5ceb9b4a76de2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f51636936328029c4e34ffa741a4aee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b8112707f012a0aa829901fdb152709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6314053bf068c27350f32cb17ab0363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aea948a942e2dd1b22b23f149b77de732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1679ec17be557862b2a9c80bb44aaf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00058.html">libreoffice_internal::CharPtrDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b04259d96ad7c103d0f8a9ffbca5271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00131.html">libreoffice_internal::NonConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a271532c250e680f70a617d0733f15b46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2a018460d39222e88c423f108ed956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae326fe19a8030ff4fba5add8289b6c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa38d7871c50d3d9ee3b5196270e9da55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abcd576caa64faaa3a6222f5cdba223f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">            <a class="code" href="a00386.html#a17666164caf81d5b242edd0152898df6">rtl_string_newFromLiteral</a>(</div>
<div class="line">                &amp;<a class="code" href="a00148.html#a7b20715b6defeb01283d393ce8473665">pData</a>,</div>
<div class="line">                libreoffice_internal::ConstCharArrayDetector&lt;T&gt;::toPointer(</div>
<div class="line">                    literal),</div>
<div class="line">                libreoffice_internal::ConstCharArrayDetector&lt;T&gt;::length, 0)</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b20715b6defeb01283d393ce8473665"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rtl::OString::pData = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>New string from a character buffer array. </p>
<p>New string from a string literal.</p>
<p>Note: The argument type is always either char* or const char*. The template is used only for technical reasons, as is the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a NULL-terminated character array.</td></tr>
  </table>
  </dd>
</dl>
<p>If there are any embedded \0's in the string literal, the result is undefined. Use the overload that explicitly accepts length.</p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literal</td><td>a string literal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b0d7ab904718c7b41cb40c88187d92c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00386.html#a0d52b8e6a0f37d9fb60db1502fbde90b">rtl_string_newFromStr</a> &amp; rtl::OString::pData</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <a class="code" href="a00148.html#a7b20715b6defeb01283d393ce8473665">pData</a> = NULL</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>rtl/<a class="el" href="a00387_source.html">string.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>

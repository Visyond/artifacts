{"version":3,"sources":["sprintf.js"],"names":["window","sprintf","key","arguments","cache","hasOwnProperty","parse","format","get_type","variable","Object","prototype","toString","call","slice","toLowerCase","str_repeat","input","multiplier","preformattedPadding","Array","join","re","not_string","not_bool","not_type","not_primitive","number","numeric_arg","json","not_json","text","modulo","placeholder","key_access","index_access","sign","parse_tree","argv","arg","i","k","match","pad","pad_character","pad_length","is_positive","arglen","argprec","arg_left_align","argtype","cursor","tree_length","length","node_type","output","Math","abs","Error","test","isFinite","String","parseFloat","TypeError","fromCharCode","parseInt","JSON","stringify","toExponential","toFixed","toPrecision","substring","valueOf","toUpperCase","replace","charAt","fmt","_fmt","arg_names","exec","SyntaxError","field_list","replacement_field","field_match","vsprintf","_argv","unshift","apply","0"," ","_","exports","define","amd","this"],"mappings":"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","file":"sprintf.min.js","sourcesContent":["/* globals window, exports, define */\n\n(function ( window ) {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[d-gi]/,                   // [defgi]\n        numeric_arg: /b-giuxX/,             // [bcdefgiuxX]\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+|\\*(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?)?(?:\\.(\\d+|\\*(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?))?([b-gijostTuvxX])/,\n        //                                                                                                                         11111111       111111 99999   111111111111111      \n        //                     11111111       222222      33   4444444   5   666666666 77777777 66666 888888 6666        999999999 00000000 99999 111111 99999   222222222222222\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    };\n\n    function sprintf() {\n        var key = arguments[0], \n            cache = sprintf.cache;\n        if ( ! ( cache[key] && cache.hasOwnProperty( key ) ) ) {\n            cache[key] = sprintf.parse( key );\n        }\n        return sprintf.format( cache[key], arguments );\n    }\n\n    sprintf.format = function ( parse_tree, argv ) {\n        var cursor = 1, \n            tree_length = parse_tree.length, \n            node_type = \"\", \n            arg, \n            output = [], \n            i, k, match, pad, pad_character, pad_length, \n            is_positive, \n            sign,\n            arglen, argprec, arg_left_align, argtype;\n\n        for ( i = 0; i < tree_length; i++ ) {\n            match = parse_tree[i]; // convenience purposes only\n            node_type = get_type( match );\n            if ( node_type === \"string\" ) {\n                output[output.length] = match;\n            }\n            else if ( node_type === \"array\" ) {\n                is_positive = true;\n                sign = \"\";\n                arglen = false;\n                argprec = false; \n                arg_left_align = false;\n\n                if (match[6]) {\n                    arglen = +match[6];\n                    if (match[6][0] === '*') { // length argument\n                        arglen = +argv[cursor++];\n                    }\n                }\n                if (match[9]) {\n                    argprec = +match[9];\n                    if (match[9][0] === '*') { // precision argument\n                        argprec = +argv[cursor++];\n                    }\n                }\n                //output[output.length] = \"{M:\" + match[5] + \":L:\" + arglen + \":P:\" + argprec + \"}\";\n                if ( match[5] || arglen < 0 ) {\n                    arg_left_align = true;\n                    arglen = Math.abs(arglen);\n                }\n                if ( match[2] ) { // keyword argument\n                    arg = argv[cursor];\n                    for ( k = 0; k < match[2].length; k++ ) {\n                        if ( ! arg.hasOwnProperty( match[2][k] ) ) {\n                            throw new Error( sprintf( \"[sprintf] property '%s' does not exist\", match[2][k] ) );\n                        }\n                        arg = arg[match[2][k]];\n                    }\n                }\n                else if ( match[1] ) { // positional argument (explicit)\n                    arg = argv[match[1]];\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++];\n                }\n\n                // compute functions into their argument value\n                if ( re.not_type.test( match[12] ) && re.not_primitive.test( match[12] ) && get_type( arg ) === \"function\" ) {\n                    arg = arg();\n                }\n\n                if ( re.numeric_arg.test( match[12] ) ) {\n                    argtype = get_type( arg );\n                    if ( argtype === \"number\" ) {\n\t\t    \tif ( !isFinite( arg ) ) {\n                            argtype = String( arg );\n\t\t\t}\n                    } else {\n\t\t    \tif ( isFinite( arg ) ) {\n                            argtype = \"number\";\n\t\t\t    arg = parseFloat( arg );\n\t\t\t}\n\t\t    }\n                    if ( argtype !== \"number\" ) {\n                        throw new TypeError( sprintf( \"[sprintf] expecting number but found %s\", argtype ) );\n                    }\n                }\n\n                if ( re.number.test( match[12] ) ) {\n                    is_positive = arg >= 0;\n                }\n\n                switch ( match[12] ) {\n                case \"b\":\n                    arg = arg.toString( 2 );\n                    break;\n                case \"c\":\n                    arg = String.fromCharCode( arg );\n                    break;\n                case \"d\":\n                case \"i\":\n                    arg = parseInt( arg, 10 ).toString();\n                    break;\n                case \"j\":\n                    arg = JSON.stringify(arg, null, arglen ? parseInt(arglen) : 0);\n                    break;\n                case \"e\":\n                    arg = argprec !== false ? arg.toExponential( argprec ) : arg.toExponential();\n                    break;\n                case \"f\":\n                    arg = argprec !== false ? arg.toFixed( argprec ) : arg.toString();\n                    break;\n                case \"g\":\n                    arg = argprec !== false ? arg.toPrecision( argprec ) : arg.toString();\n                    break;\n                case \"o\":\n                    arg = arg.toString( 8 );\n                    break;\n                case \"s\":\n                    arg = String( arg );\n                    arg = (arg && argprec !== false ? arg.substring( 0, argprec ) : arg);\n                    break;\n                case \"t\":\n                    arg = String(!!arg);\n                    arg = (argprec !== false ? arg.substring( 0, argprec ) : arg);\n                    break;\n                case \"T\":\n                    arg = get_type(arg);\n                    arg = (argprec !== false ? arg.substring( 0, argprec ) : arg);\n                    break;\n                case \"u\":\n                    arg = (arg >>> 0).toString();\n                    break;\n                case \"v\":\n                    arg = arg.valueOf();\n                    arg = (argprec !== false ? arg.substring( 0, argprec ) : arg);\n                    break;\n                case \"x\":\n                    arg = arg.toString( 16 );\n                    break;\n                case \"X\":\n                    arg = arg.toString( 16 ).toUpperCase();\n                    break;\n                }\n                if (re.json.test(match[12])) {\n                    output[output.length] = arg;\n                }\n                else {\n                    if ( re.number.test( match[12] ) && (! is_positive || match[3]) ) {\n                        sign = is_positive ? \"+\" : \"-\";\n                        arg = arg.toString().replace( re.sign, \"\" );\n                    }\n                    else {\n                        sign = \"\";\n                    }\n                    pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt( 1 ) : \" \";\n                    pad_length = arglen - (sign + arg).length;\n                    pad = arglen !== false ? (pad_length > 0 ? str_repeat( pad_character, pad_length ) : \"\") : \"\";\n                    output[output.length] = arg_left_align ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg);\n                    //output[output.length] = \":I:\" + arg_left_align + \":S:\" + sign + \":A:\" + arg + \":P:\" + pad + \":C:\" + pad_character + \":\";\n                }\n            }\n        }\n        return output.join( \"\" );\n    };\n\n    sprintf.cache = {};\n\n    sprintf.parse = function ( fmt ) {\n        var _fmt = fmt, \n            match = [], \n            parse_tree = [], \n            arg_names = 0;\n\n        while ( _fmt ) {\n            if ( (match = re.text.exec( _fmt )) !== null ) {\n                parse_tree[parse_tree.length] = match[0];\n            }\n            else if ( (match = re.modulo.exec( _fmt )) !== null ) {\n                parse_tree[parse_tree.length] = \"%\";\n            }\n            else if ( (match = re.placeholder.exec( _fmt )) !== null ) {\n                if ( match[2] ) {\n                    arg_names |= 1;\n                    var field_list = [], \n                        replacement_field = match[2], \n                        field_match = [];\n\n                    if ( (field_match = re.key.exec( replacement_field )) !== null ) {\n                        field_list[field_list.length] = field_match[1];\n                        while ( (replacement_field = replacement_field.substring( field_match[0].length )) !== \"\" ) {\n                            if ( (field_match = re.key_access.exec( replacement_field )) !== null ) {\n                                field_list[field_list.length] = field_match[1];\n                            }\n                            else if ( (field_match = re.index_access.exec( replacement_field )) !== null ) {\n                                field_list[field_list.length] = field_match[1];\n                            }\n                            else {\n                                throw new SyntaxError( \"[sprintf] failed to parse named argument key\" );\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError( \"[sprintf] failed to parse named argument key\" );\n                    }\n                    match[2] = field_list;\n                }\n                else {\n                    arg_names |= 2;\n                }\n                if ( arg_names === 3 ) {\n                    throw new Error( \"[sprintf] mixing positional and named placeholders is not (yet) supported\" );\n                }\n                parse_tree[parse_tree.length] = match;\n            }\n            else {\n                throw new SyntaxError( \"[sprintf] unexpected placeholder\" );\n            }\n            _fmt = _fmt.substring( match[0].length );\n        }\n        return parse_tree;\n    };\n\n    var vsprintf = function ( fmt, argv ) {\n        var _argv = (argv || []).slice( 0 );\n        _argv.unshift( fmt );\n        return sprintf.apply( null, _argv );\n    };\n\n    /**\n     * helpers\n     */\n    function get_type( variable ) {\n        if ( typeof variable === 'number' ) return 'number';\n        if ( typeof variable === 'string' ) return 'string';\n        return Object.prototype.toString.call( variable ).slice( 8, -1 ).toLowerCase();\n    }\n\n    var preformattedPadding = {\n        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],\n        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],\n        '_': ['', '_', '__', '___', '____', '_____', '______', '_______'],\n    };\n    function str_repeat( input, multiplier ) {\n        if ( multiplier >= 0 && multiplier <= 7 && preformattedPadding[input] ) {\n            return preformattedPadding[input][multiplier];\n        }\n        return multiplier > 0 ? new Array( multiplier + 1 ).join( input ) : \"\";\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    window.sprintf = sprintf;\n    window.vsprintf = vsprintf;\n\n    if (typeof exports !== 'undefined') {\n        exports.sprintf = sprintf;\n        exports.vsprintf = vsprintf;\n    }\n    else {\n        if (typeof define === 'function' && define.amd) {\n            define(function() {\n                return {\n                    sprintf: sprintf,\n                    vsprintf: vsprintf\n                };\n            });\n        }\n    }\n})( typeof window === \"undefined\" ? this : window );\n"],"sourceRoot":"/source/"}
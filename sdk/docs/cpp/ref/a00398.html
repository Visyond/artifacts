<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LibreOffice: rtl/ustring.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibreOffice
   </div>
   <div id="projectbrief">LibreOffice 6.3 SDK C/C++ API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_76abd0e99dd7fac17b3d6a551048fb5f.html">rtl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ustring.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="a00402_source.html">sal/config.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00345_source.html">osl/interlck.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00386_source.html">rtl/string.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00392_source.html">rtl/textenc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00408_source.html">sal/saldllapi.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00409_source.html">sal/types.h</a>&quot;</code><br/>
</div>
<p><a href="a00398_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab971bef6363adb307b39134b70f96756"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ab971bef6363adb307b39134b70f96756">RTL_USTR_MAX_VALUEOFBOOLEAN</a>&#160;&#160;&#160;<a class="el" href="a00386.html#a9a1acbd13cd08701747dd642e61c7653">RTL_STR_MAX_VALUEOFBOOLEAN</a></td></tr>
<tr class="separator:ab971bef6363adb307b39134b70f96756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d2913d4e6ebe205c90e507da7829fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a19d2913d4e6ebe205c90e507da7829fa">RTL_USTR_MAX_VALUEOFCHAR</a>&#160;&#160;&#160;<a class="el" href="a00386.html#a5bc43d45541495ab4f2266fd9ccf9c15">RTL_STR_MAX_VALUEOFCHAR</a></td></tr>
<tr class="separator:a19d2913d4e6ebe205c90e507da7829fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463f9ee8978efb0d8d2fb8f3f00d434f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a463f9ee8978efb0d8d2fb8f3f00d434f">RTL_USTR_MIN_RADIX</a>&#160;&#160;&#160;<a class="el" href="a00386.html#ae983b6c9bf97ce91c1018f79a3250d7f">RTL_STR_MIN_RADIX</a></td></tr>
<tr class="separator:a463f9ee8978efb0d8d2fb8f3f00d434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973903d85ce863437b12e40a4f720ae8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a973903d85ce863437b12e40a4f720ae8">RTL_USTR_MAX_RADIX</a>&#160;&#160;&#160;<a class="el" href="a00386.html#a8553f7b745ed840d2e01c78c6e0e1a38">RTL_STR_MAX_RADIX</a></td></tr>
<tr class="separator:a973903d85ce863437b12e40a4f720ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6288cdd9afef96e0d4fab3372864d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#afa6288cdd9afef96e0d4fab3372864d8">RTL_USTR_MAX_VALUEOFINT32</a>&#160;&#160;&#160;<a class="el" href="a00386.html#a34fb24bbd40d09cfca323211a99edf40">RTL_STR_MAX_VALUEOFINT32</a></td></tr>
<tr class="separator:afa6288cdd9afef96e0d4fab3372864d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1db0cbdd782a9ae0bc590af4cb34ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a4e1db0cbdd782a9ae0bc590af4cb34ed">RTL_USTR_MAX_VALUEOFINT64</a>&#160;&#160;&#160;<a class="el" href="a00386.html#abacb5a4eeccc30233b955d0ba43c9154">RTL_STR_MAX_VALUEOFINT64</a></td></tr>
<tr class="separator:a4e1db0cbdd782a9ae0bc590af4cb34ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1db0cbdd782a9ae0bc590af4cb34ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a4e1db0cbdd782a9ae0bc590af4cb34ed">RTL_USTR_MAX_VALUEOFINT64</a>&#160;&#160;&#160;<a class="el" href="a00386.html#abacb5a4eeccc30233b955d0ba43c9154">RTL_STR_MAX_VALUEOFINT64</a></td></tr>
<tr class="separator:a4e1db0cbdd782a9ae0bc590af4cb34ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116dc6ca166b2f7f6ae07d97db1bf8c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a116dc6ca166b2f7f6ae07d97db1bf8c8">RTL_USTR_MAX_VALUEOFFLOAT</a>&#160;&#160;&#160;<a class="el" href="a00386.html#a9b29548a9c2f0372173ff1b0f8896067">RTL_STR_MAX_VALUEOFFLOAT</a></td></tr>
<tr class="separator:a116dc6ca166b2f7f6ae07d97db1bf8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dd11c5cf6798ee4a76874fdbb77d4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a20dd11c5cf6798ee4a76874fdbb77d4f">RTL_USTR_MAX_VALUEOFDOUBLE</a>&#160;&#160;&#160;<a class="el" href="a00386.html#a312bc78cc5becf2055c01c49c6fca940">RTL_STR_MAX_VALUEOFDOUBLE</a></td></tr>
<tr class="separator:a20dd11c5cf6798ee4a76874fdbb77d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e64d39ab88fe964f91477896156409"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a63e64d39ab88fe964f91477896156409">RTL_CONSTASCII_USTRINGPARAM</a>(constAsciiStr)</td></tr>
<tr class="memdesc:a63e64d39ab88fe964f91477896156409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply an ASCII string literal together with its length and text encoding.  <a href="#a63e64d39ab88fe964f91477896156409">More...</a><br/></td></tr>
<tr class="separator:a63e64d39ab88fe964f91477896156409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d72f032eb9370c7403fccb71c4e6906"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a0d72f032eb9370c7403fccb71c4e6906">OSTRING_TO_OUSTRING_CVTFLAGS</a></td></tr>
<tr class="separator:a0d72f032eb9370c7403fccb71c4e6906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86a3766acd1b77c054cf7bc9b1ce7d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a86a3766acd1b77c054cf7bc9b1ce7d80">rtl_ustr_getLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a86a3766acd1b77c054cf7bc9b1ce7d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of a string.  <a href="#a86a3766acd1b77c054cf7bc9b1ce7d80">More...</a><br/></td></tr>
<tr class="separator:a86a3766acd1b77c054cf7bc9b1ce7d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90785105dedfa6580f61468063da784d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a90785105dedfa6580f61468063da784d">rtl_ustr_compare</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a90785105dedfa6580f61468063da784d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings.  <a href="#a90785105dedfa6580f61468063da784d">More...</a><br/></td></tr>
<tr class="separator:a90785105dedfa6580f61468063da784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124db73aefd1cd95bb435a2b607470d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a124db73aefd1cd95bb435a2b607470d8">rtl_ustr_compare_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second, sal_Int32 secondLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a124db73aefd1cd95bb435a2b607470d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings.  <a href="#a124db73aefd1cd95bb435a2b607470d8">More...</a><br/></td></tr>
<tr class="separator:a124db73aefd1cd95bb435a2b607470d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc94338a5dcbc101095c8cec054e822c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#acc94338a5dcbc101095c8cec054e822c">rtl_ustr_shortenedCompare_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second, sal_Int32 secondLen, sal_Int32 shortenedLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:acc94338a5dcbc101095c8cec054e822c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings with a maximum count of characters.  <a href="#acc94338a5dcbc101095c8cec054e822c">More...</a><br/></td></tr>
<tr class="separator:acc94338a5dcbc101095c8cec054e822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7b9f6a383331510cce6948dfa3289a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#acc7b9f6a383331510cce6948dfa3289a">rtl_ustr_reverseCompare_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second, sal_Int32 secondLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:acc7b9f6a383331510cce6948dfa3289a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings from back to front.  <a href="#acc7b9f6a383331510cce6948dfa3289a">More...</a><br/></td></tr>
<tr class="separator:acc7b9f6a383331510cce6948dfa3289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c53b6fc4fa0e924edee4a68cee579f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a7c53b6fc4fa0e924edee4a68cee579f8">rtl_ustr_asciil_reverseEquals_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second, sal_Int32 len) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a7c53b6fc4fa0e924edee4a68cee579f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings from back to front for equality.  <a href="#a7c53b6fc4fa0e924edee4a68cee579f8">More...</a><br/></td></tr>
<tr class="separator:a7c53b6fc4fa0e924edee4a68cee579f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260a0e528f81006e939de1f05750a1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a260a0e528f81006e939de1f05750a1cd">rtl_ustr_compareIgnoreAsciiCase</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a260a0e528f81006e939de1f05750a1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, ignoring the case of ASCII characters.  <a href="#a260a0e528f81006e939de1f05750a1cd">More...</a><br/></td></tr>
<tr class="separator:a260a0e528f81006e939de1f05750a1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d88350984f243593da9347010da478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ac8d88350984f243593da9347010da478">rtl_ustr_compareIgnoreAsciiCase_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second, sal_Int32 secondLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ac8d88350984f243593da9347010da478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, ignoring the case of ASCII characters.  <a href="#ac8d88350984f243593da9347010da478">More...</a><br/></td></tr>
<tr class="separator:ac8d88350984f243593da9347010da478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e561bed052ac227315e901a6a28aac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a9e561bed052ac227315e901a6a28aac6">rtl_ustr_shortenedCompareIgnoreAsciiCase_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *second, sal_Int32 secondLen, sal_Int32 shortenedLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a9e561bed052ac227315e901a6a28aac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings with a maximum count of characters, ignoring the case of ASCII characters.  <a href="#a9e561bed052ac227315e901a6a28aac6">More...</a><br/></td></tr>
<tr class="separator:a9e561bed052ac227315e901a6a28aac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684efea6035a2575347e24c7f1580d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a684efea6035a2575347e24c7f1580d4c">rtl_ustr_ascii_compare</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a684efea6035a2575347e24c7f1580d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings.  <a href="#a684efea6035a2575347e24c7f1580d4c">More...</a><br/></td></tr>
<tr class="separator:a684efea6035a2575347e24c7f1580d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f17670a52936c81a22e02ebe88054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#abc8f17670a52936c81a22e02ebe88054">rtl_ustr_ascii_compare_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:abc8f17670a52936c81a22e02ebe88054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings.  <a href="#abc8f17670a52936c81a22e02ebe88054">More...</a><br/></td></tr>
<tr class="separator:abc8f17670a52936c81a22e02ebe88054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2445b06d4ba5eeeaef79cdb03ceb8ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a2445b06d4ba5eeeaef79cdb03ceb8ddc">rtl_ustr_ascii_shortenedCompare_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second, sal_Int32 shortenedLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a2445b06d4ba5eeeaef79cdb03ceb8ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings with a maximum count of characters.  <a href="#a2445b06d4ba5eeeaef79cdb03ceb8ddc">More...</a><br/></td></tr>
<tr class="separator:a2445b06d4ba5eeeaef79cdb03ceb8ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a81e7cdccb3437319e253a9520054b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a65a81e7cdccb3437319e253a9520054b">rtl_ustr_asciil_reverseCompare_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second, sal_Int32 secondLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a65a81e7cdccb3437319e253a9520054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings from back to front.  <a href="#a65a81e7cdccb3437319e253a9520054b">More...</a><br/></td></tr>
<tr class="separator:a65a81e7cdccb3437319e253a9520054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6454e4627f48c6c053146975d9a908f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a6454e4627f48c6c053146975d9a908f6">rtl_ustr_ascii_compareIgnoreAsciiCase</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a6454e4627f48c6c053146975d9a908f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, ignoring the case of ASCII characters.  <a href="#a6454e4627f48c6c053146975d9a908f6">More...</a><br/></td></tr>
<tr class="separator:a6454e4627f48c6c053146975d9a908f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6a1e43a7155197302e23da86af444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#af2a6a1e43a7155197302e23da86af444">rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:af2a6a1e43a7155197302e23da86af444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, ignoring the case of ASCII characters.  <a href="#af2a6a1e43a7155197302e23da86af444">More...</a><br/></td></tr>
<tr class="separator:af2a6a1e43a7155197302e23da86af444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040b33cbee9716ee6498e7816fca292e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a040b33cbee9716ee6498e7816fca292e">rtl_ustr_ascii_compareIgnoreAsciiCase_WithLengths</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *first, sal_Int32 firstLen, char const *second, sal_Int32 secondLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a040b33cbee9716ee6498e7816fca292e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings, ignoring the case of ASCII characters.  <a href="#a040b33cbee9716ee6498e7816fca292e">More...</a><br/></td></tr>
<tr class="separator:a040b33cbee9716ee6498e7816fca292e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc8fa7696b241bfc41c9507535347a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#adbc8fa7696b241bfc41c9507535347a9">rtl_ustr_ascii_shortenedCompareIgnoreAsciiCase_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *first, sal_Int32 firstLen, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *second, sal_Int32 shortenedLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:adbc8fa7696b241bfc41c9507535347a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two strings with a maximum count of characters, ignoring the case of ASCII characters.  <a href="#adbc8fa7696b241bfc41c9507535347a9">More...</a><br/></td></tr>
<tr class="separator:adbc8fa7696b241bfc41c9507535347a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e05e35bd841a5fe2c4506877018c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a33e05e35bd841a5fe2c4506877018c68">rtl_ustr_hashCode</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a33e05e35bd841a5fe2c4506877018c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hash code for a string.  <a href="#a33e05e35bd841a5fe2c4506877018c68">More...</a><br/></td></tr>
<tr class="separator:a33e05e35bd841a5fe2c4506877018c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40b5c79da08ab51a4bd07b1957c74ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ae40b5c79da08ab51a4bd07b1957c74ed">rtl_ustr_hashCode_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ae40b5c79da08ab51a4bd07b1957c74ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hash code for a string.  <a href="#ae40b5c79da08ab51a4bd07b1957c74ed">More...</a><br/></td></tr>
<tr class="separator:ae40b5c79da08ab51a4bd07b1957c74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc883bb9b161e41a32167350e0b878a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#abcc883bb9b161e41a32167350e0b878a">rtl_ustr_indexOfChar</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:abcc883bb9b161e41a32167350e0b878a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a character within a string.  <a href="#abcc883bb9b161e41a32167350e0b878a">More...</a><br/></td></tr>
<tr class="separator:abcc883bb9b161e41a32167350e0b878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5885afdbf5abb6bcb4a8ff4fca9068d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#af5885afdbf5abb6bcb4a8ff4fca9068d">rtl_ustr_indexOfChar_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:af5885afdbf5abb6bcb4a8ff4fca9068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a character within a string.  <a href="#af5885afdbf5abb6bcb4a8ff4fca9068d">More...</a><br/></td></tr>
<tr class="separator:af5885afdbf5abb6bcb4a8ff4fca9068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fc5c2162dcc3a14644ff804758830a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a56fc5c2162dcc3a14644ff804758830a">rtl_ustr_lastIndexOfChar</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a56fc5c2162dcc3a14644ff804758830a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a character within a string.  <a href="#a56fc5c2162dcc3a14644ff804758830a">More...</a><br/></td></tr>
<tr class="separator:a56fc5c2162dcc3a14644ff804758830a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85f90b63372f3b18f4892373366ffd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aa85f90b63372f3b18f4892373366ffd4">rtl_ustr_lastIndexOfChar_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aa85f90b63372f3b18f4892373366ffd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a character within a string.  <a href="#aa85f90b63372f3b18f4892373366ffd4">More...</a><br/></td></tr>
<tr class="separator:aa85f90b63372f3b18f4892373366ffd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2d6ed6c28942c98bfe74b9eb098e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a5a2d6ed6c28942c98bfe74b9eb098e5d">rtl_ustr_indexOfStr</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *subStr) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a5a2d6ed6c28942c98bfe74b9eb098e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a substring within a string.  <a href="#a5a2d6ed6c28942c98bfe74b9eb098e5d">More...</a><br/></td></tr>
<tr class="separator:a5a2d6ed6c28942c98bfe74b9eb098e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf74654c6506fe615321503e5ba0c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a5cf74654c6506fe615321503e5ba0c17">rtl_ustr_indexOfStr_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *subStr, sal_Int32 subLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a5cf74654c6506fe615321503e5ba0c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a substring within a string.  <a href="#a5cf74654c6506fe615321503e5ba0c17">More...</a><br/></td></tr>
<tr class="separator:a5cf74654c6506fe615321503e5ba0c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9644902b83fdc429c1293aaa69d1b930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a9644902b83fdc429c1293aaa69d1b930">rtl_ustr_indexOfAscii_WithLength</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *str, sal_Int32 len, char const *subStr, sal_Int32 subLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a9644902b83fdc429c1293aaa69d1b930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of an ASCII substring within a string.  <a href="#a9644902b83fdc429c1293aaa69d1b930">More...</a><br/></td></tr>
<tr class="separator:a9644902b83fdc429c1293aaa69d1b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119b0bbcf63d015cfe39aa24930593a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a4119b0bbcf63d015cfe39aa24930593a">rtl_ustr_lastIndexOfStr</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *subStr) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a4119b0bbcf63d015cfe39aa24930593a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a substring within a string.  <a href="#a4119b0bbcf63d015cfe39aa24930593a">More...</a><br/></td></tr>
<tr class="separator:a4119b0bbcf63d015cfe39aa24930593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5178d3cefef20b9590bcf6e8e922104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#af5178d3cefef20b9590bcf6e8e922104">rtl_ustr_lastIndexOfStr_WithLength</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *subStr, sal_Int32 subLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:af5178d3cefef20b9590bcf6e8e922104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a substring within a string.  <a href="#af5178d3cefef20b9590bcf6e8e922104">More...</a><br/></td></tr>
<tr class="separator:af5178d3cefef20b9590bcf6e8e922104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cba82a70b4971faac198187251db69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a94cba82a70b4971faac198187251db69">rtl_ustr_lastIndexOfAscii_WithLength</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *str, sal_Int32 len, char const *subStr, sal_Int32 subLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a94cba82a70b4971faac198187251db69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of an ASCII substring within a string.  <a href="#a94cba82a70b4971faac198187251db69">More...</a><br/></td></tr>
<tr class="separator:a94cba82a70b4971faac198187251db69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4971004e89088cd15015ea87e992226a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a4971004e89088cd15015ea87e992226a">rtl_ustr_replaceChar</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> oldChar, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> newChar) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a4971004e89088cd15015ea87e992226a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a single character within a string.  <a href="#a4971004e89088cd15015ea87e992226a">More...</a><br/></td></tr>
<tr class="separator:a4971004e89088cd15015ea87e992226a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bdabfa4afa8ea71089307ea106cc97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a37bdabfa4afa8ea71089307ea106cc97">rtl_ustr_replaceChar_WithLength</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> oldChar, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> newChar) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a37bdabfa4afa8ea71089307ea106cc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of a single character within a string.  <a href="#a37bdabfa4afa8ea71089307ea106cc97">More...</a><br/></td></tr>
<tr class="separator:a37bdabfa4afa8ea71089307ea106cc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b681c47777ba1563704bd6d99cc0e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a3b681c47777ba1563704bd6d99cc0e0a">rtl_ustr_toAsciiLowerCase</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a3b681c47777ba1563704bd6d99cc0e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all ASCII uppercase letters to lowercase within a string.  <a href="#a3b681c47777ba1563704bd6d99cc0e0a">More...</a><br/></td></tr>
<tr class="separator:a3b681c47777ba1563704bd6d99cc0e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d12eddbacde48561b1e1d6c595fb97a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a6d12eddbacde48561b1e1d6c595fb97a">rtl_ustr_toAsciiLowerCase_WithLength</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a6d12eddbacde48561b1e1d6c595fb97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all ASCII uppercase letters to lowercase within a string.  <a href="#a6d12eddbacde48561b1e1d6c595fb97a">More...</a><br/></td></tr>
<tr class="separator:a6d12eddbacde48561b1e1d6c595fb97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3155e560a8e8eed5307afb92004441b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ad3155e560a8e8eed5307afb92004441b">rtl_ustr_toAsciiUpperCase</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ad3155e560a8e8eed5307afb92004441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all ASCII lowercase letters to uppercase within a string.  <a href="#ad3155e560a8e8eed5307afb92004441b">More...</a><br/></td></tr>
<tr class="separator:ad3155e560a8e8eed5307afb92004441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d862bce95973ab6f081075fc3498c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a7d862bce95973ab6f081075fc3498c0e">rtl_ustr_toAsciiUpperCase_WithLength</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a7d862bce95973ab6f081075fc3498c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all ASCII lowercase letters to uppercase within a string.  <a href="#a7d862bce95973ab6f081075fc3498c0e">More...</a><br/></td></tr>
<tr class="separator:a7d862bce95973ab6f081075fc3498c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d01bb3907c0c18b952586165624d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a65d01bb3907c0c18b952586165624d50">rtl_ustr_trim</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a65d01bb3907c0c18b952586165624d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove white space from both ends of a string.  <a href="#a65d01bb3907c0c18b952586165624d50">More...</a><br/></td></tr>
<tr class="separator:a65d01bb3907c0c18b952586165624d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6b7156db00e672d0e06ed6703c59d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a2f6b7156db00e672d0e06ed6703c59d9">rtl_ustr_trim_WithLength</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 len) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a2f6b7156db00e672d0e06ed6703c59d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove white space from both ends of the string.  <a href="#a2f6b7156db00e672d0e06ed6703c59d9">More...</a><br/></td></tr>
<tr class="separator:a2f6b7156db00e672d0e06ed6703c59d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a42fb008376e0eab9cae47c202044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a316a42fb008376e0eab9cae47c202044">rtl_ustr_valueOfBoolean</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a> b) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a316a42fb008376e0eab9cae47c202044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of a boolean.  <a href="#a316a42fb008376e0eab9cae47c202044">More...</a><br/></td></tr>
<tr class="separator:a316a42fb008376e0eab9cae47c202044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e8f0b451b22978f1833740af5d5170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a59e8f0b451b22978f1833740af5d5170">rtl_ustr_valueOfChar</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a59e8f0b451b22978f1833740af5d5170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of a character.  <a href="#a59e8f0b451b22978f1833740af5d5170">More...</a><br/></td></tr>
<tr class="separator:a59e8f0b451b22978f1833740af5d5170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36b0465a36de322766743477df6b5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ad36b0465a36de322766743477df6b5ec">rtl_ustr_valueOfInt32</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int32 i, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ad36b0465a36de322766743477df6b5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of an integer.  <a href="#ad36b0465a36de322766743477df6b5ec">More...</a><br/></td></tr>
<tr class="separator:ad36b0465a36de322766743477df6b5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94036537d404837b351c89a3ae1ad84b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a94036537d404837b351c89a3ae1ad84b">rtl_ustr_valueOfInt64</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int64 l, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a94036537d404837b351c89a3ae1ad84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of a long integer.  <a href="#a94036537d404837b351c89a3ae1ad84b">More...</a><br/></td></tr>
<tr class="separator:a94036537d404837b351c89a3ae1ad84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7263f0941ed73607f4bf3409343b096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ac7263f0941ed73607f4bf3409343b096">rtl_ustr_valueOfUInt64</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_uInt64 l, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ac7263f0941ed73607f4bf3409343b096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of an unsigned long integer.  <a href="#ac7263f0941ed73607f4bf3409343b096">More...</a><br/></td></tr>
<tr class="separator:ac7263f0941ed73607f4bf3409343b096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38091b25f1087791b1e67c6edc251aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a38091b25f1087791b1e67c6edc251aa9">rtl_ustr_valueOfFloat</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, float f) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a38091b25f1087791b1e67c6edc251aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of a float.  <a href="#a38091b25f1087791b1e67c6edc251aa9">More...</a><br/></td></tr>
<tr class="separator:a38091b25f1087791b1e67c6edc251aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf52a0e37b6da26b34f288ffd7d6a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a3bf52a0e37b6da26b34f288ffd7d6a84">rtl_ustr_valueOfDouble</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, double d) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a3bf52a0e37b6da26b34f288ffd7d6a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the string representation of a double.  <a href="#a3bf52a0e37b6da26b34f288ffd7d6a84">More...</a><br/></td></tr>
<tr class="separator:a3bf52a0e37b6da26b34f288ffd7d6a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99d7dfcbab09c8ce5e06e6c4cd1d875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ad99d7dfcbab09c8ce5e06e6c4cd1d875">rtl_ustr_toBoolean</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ad99d7dfcbab09c8ce5e06e6c4cd1d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a boolean.  <a href="#ad99d7dfcbab09c8ce5e06e6c4cd1d875">More...</a><br/></td></tr>
<tr class="separator:ad99d7dfcbab09c8ce5e06e6c4cd1d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb8340c248ddff0dd70bdcafb2ce970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#abfb8340c248ddff0dd70bdcafb2ce970">rtl_ustr_toInt32</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:abfb8340c248ddff0dd70bdcafb2ce970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as an integer.  <a href="#abfb8340c248ddff0dd70bdcafb2ce970">More...</a><br/></td></tr>
<tr class="separator:abfb8340c248ddff0dd70bdcafb2ce970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad54360bda37e6024b0086170485c32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_uInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aad54360bda37e6024b0086170485c32f">rtl_ustr_toUInt32</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aad54360bda37e6024b0086170485c32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as an unsigned integer.  <a href="#aad54360bda37e6024b0086170485c32f">More...</a><br/></td></tr>
<tr class="separator:aad54360bda37e6024b0086170485c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cae24724274e715f7c711d3f5d285c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a6cae24724274e715f7c711d3f5d285c5">rtl_ustr_toInt64</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a6cae24724274e715f7c711d3f5d285c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a long integer.  <a href="#a6cae24724274e715f7c711d3f5d285c5">More...</a><br/></td></tr>
<tr class="separator:a6cae24724274e715f7c711d3f5d285c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9819c1e369713b292e5db76774c00c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_uInt64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a9819c1e369713b292e5db76774c00c37">rtl_ustr_toUInt64</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str, sal_Int16 radix) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a9819c1e369713b292e5db76774c00c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as an unsigned long integer.  <a href="#a9819c1e369713b292e5db76774c00c37">More...</a><br/></td></tr>
<tr class="separator:a9819c1e369713b292e5db76774c00c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095f62523e29f8a6b9c7d359c658dd8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a095f62523e29f8a6b9c7d359c658dd8e">rtl_ustr_toFloat</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a095f62523e29f8a6b9c7d359c658dd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a float.  <a href="#a095f62523e29f8a6b9c7d359c658dd8e">More...</a><br/></td></tr>
<tr class="separator:a095f62523e29f8a6b9c7d359c658dd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a83247509b977c5544fe89dfeefbe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a31a83247509b977c5544fe89dfeefbe9">rtl_ustr_toDouble</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a31a83247509b977c5544fe89dfeefbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret a string as a double.  <a href="#a31a83247509b977c5544fe89dfeefbe9">More...</a><br/></td></tr>
<tr class="separator:a31a83247509b977c5544fe89dfeefbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6451e5468f66023626e1039c969476ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a6451e5468f66023626e1039c969476ae">rtl_uString_acquire</a> (rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>() SAL_HOT</td></tr>
<tr class="memdesc:a6451e5468f66023626e1039c969476ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count of a string.  <a href="#a6451e5468f66023626e1039c969476ae">More...</a><br/></td></tr>
<tr class="separator:a6451e5468f66023626e1039c969476ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8571974c63423cb183047a33a72f0d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a8571974c63423cb183047a33a72f0d0a">rtl_uString_release</a> (rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>() SAL_HOT</td></tr>
<tr class="memdesc:a8571974c63423cb183047a33a72f0d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count of a string.  <a href="#a8571974c63423cb183047a33a72f0d0a">More...</a><br/></td></tr>
<tr class="separator:a8571974c63423cb183047a33a72f0d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be57a48ad92c87d3baf52f66fe42cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a0be57a48ad92c87d3baf52f66fe42cfc">rtl_uString_new</a> (rtl_uString **newStr) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a0be57a48ad92c87d3baf52f66fe42cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string containing no characters.  <a href="#a0be57a48ad92c87d3baf52f66fe42cfc">More...</a><br/></td></tr>
<tr class="separator:a0be57a48ad92c87d3baf52f66fe42cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5326636513ae8a053da69c95d879d4ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> rtl_uString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a5326636513ae8a053da69c95d879d4ff">rtl_uString_alloc</a> (sal_Int32 nLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a5326636513ae8a053da69c95d879d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string containing space for a given number of characters.  <a href="#a5326636513ae8a053da69c95d879d4ff">More...</a><br/></td></tr>
<tr class="separator:a5326636513ae8a053da69c95d879d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f360c7c95595b6761965247ffbf8e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a9f360c7c95595b6761965247ffbf8e44">rtl_uString_new_WithLength</a> (rtl_uString **newStr, sal_Int32 nLen) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a9f360c7c95595b6761965247ffbf8e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string containing space for a given number of characters.  <a href="#a9f360c7c95595b6761965247ffbf8e44">More...</a><br/></td></tr>
<tr class="separator:a9f360c7c95595b6761965247ffbf8e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185ef0c772f824f9363056211720fb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a185ef0c772f824f9363056211720fb33">rtl_uString_newFromString</a> (rtl_uString **newStr, const rtl_uString *value) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a185ef0c772f824f9363056211720fb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string that contains a copy of another string.  <a href="#a185ef0c772f824f9363056211720fb33">More...</a><br/></td></tr>
<tr class="separator:a185ef0c772f824f9363056211720fb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a0d8de21ece4f030e123bed6aa44df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ab3a0d8de21ece4f030e123bed6aa44df">rtl_uString_newFromStr</a> (rtl_uString **newStr, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *value) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ab3a0d8de21ece4f030e123bed6aa44df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string that contains a copy of a character array.  <a href="#ab3a0d8de21ece4f030e123bed6aa44df">More...</a><br/></td></tr>
<tr class="separator:ab3a0d8de21ece4f030e123bed6aa44df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e35be84e03bf412874c4f43bd98d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a25e35be84e03bf412874c4f43bd98d87">rtl_uString_newFromStr_WithLength</a> (rtl_uString **newStr, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *value, sal_Int32 len) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a25e35be84e03bf412874c4f43bd98d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string that contains a copy of a character array.  <a href="#a25e35be84e03bf412874c4f43bd98d87">More...</a><br/></td></tr>
<tr class="separator:a25e35be84e03bf412874c4f43bd98d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af739b126596d8eb926507f7b52c2f36c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#af739b126596d8eb926507f7b52c2f36c">rtl_uString_newFromSubString</a> (rtl_uString **newStr, const rtl_uString *from, sal_Int32 beginIndex, sal_Int32 count) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:af739b126596d8eb926507f7b52c2f36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string that is a substring of this string.  <a href="#af739b126596d8eb926507f7b52c2f36c">More...</a><br/></td></tr>
<tr class="separator:af739b126596d8eb926507f7b52c2f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698d695d33e8c3b80599a44b09a7ad8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a698d695d33e8c3b80599a44b09a7ad8f">rtl_uString_newFromAscii</a> (rtl_uString **newStr, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a698d695d33e8c3b80599a44b09a7ad8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string that contains a copy of a character array.  <a href="#a698d695d33e8c3b80599a44b09a7ad8f">More...</a><br/></td></tr>
<tr class="separator:a698d695d33e8c3b80599a44b09a7ad8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596bbcc30e556a1c0969e96d9e834c99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a596bbcc30e556a1c0969e96d9e834c99">rtl_uString_newFromLiteral</a> (rtl_uString **newStr, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value, sal_Int32 len, sal_Int32 allocExtra) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="separator:a596bbcc30e556a1c0969e96d9e834c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac753429f7da0416c0a29ecbe63b756d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ac753429f7da0416c0a29ecbe63b756d7">rtl_uString_newFromCodePoints</a> (rtl_uString **newString, sal_uInt32 const *codePoints, sal_Int32 codePointCount) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ac753429f7da0416c0a29ecbe63b756d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string from an array of Unicode code points.  <a href="#ac753429f7da0416c0a29ecbe63b756d7">More...</a><br/></td></tr>
<tr class="separator:ac753429f7da0416c0a29ecbe63b756d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056143bcb3a2c991a8dc16123d2ba25f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a056143bcb3a2c991a8dc16123d2ba25f">rtl_uString_assign</a> (rtl_uString **str, rtl_uString *rightValue) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a056143bcb3a2c991a8dc16123d2ba25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new value to a string.  <a href="#a056143bcb3a2c991a8dc16123d2ba25f">More...</a><br/></td></tr>
<tr class="separator:a056143bcb3a2c991a8dc16123d2ba25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f49d173ed996548a2185a7aace26d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ab7f49d173ed996548a2185a7aace26d9">rtl_uString_getLength</a> (const rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ab7f49d173ed996548a2185a7aace26d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of a string.  <a href="#ab7f49d173ed996548a2185a7aace26d9">More...</a><br/></td></tr>
<tr class="separator:ab7f49d173ed996548a2185a7aace26d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f705706afaad1895e39260beebd325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ac4f705706afaad1895e39260beebd325">rtl_uString_getStr</a> (rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ac4f705706afaad1895e39260beebd325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the underlying character array of a string.  <a href="#ac4f705706afaad1895e39260beebd325">More...</a><br/></td></tr>
<tr class="separator:ac4f705706afaad1895e39260beebd325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1be99fd5c7c91d3053a1e7ce19c875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a4e1be99fd5c7c91d3053a1e7ce19c875">rtl_uString_newConcat</a> (rtl_uString **newStr, rtl_uString *left, rtl_uString *right) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a4e1be99fd5c7c91d3053a1e7ce19c875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string that is the concatenation of two other strings.  <a href="#a4e1be99fd5c7c91d3053a1e7ce19c875">More...</a><br/></td></tr>
<tr class="separator:a4e1be99fd5c7c91d3053a1e7ce19c875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b36914a97f0116f0344576eb1ec3ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#af8b36914a97f0116f0344576eb1ec3ed">rtl_uString_newConcatAsciiL</a> (rtl_uString **newString, rtl_uString *left, char const *right, sal_Int32 rightLength)</td></tr>
<tr class="memdesc:af8b36914a97f0116f0344576eb1ec3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string that is the concatenation of two other strings.  <a href="#af8b36914a97f0116f0344576eb1ec3ed">More...</a><br/></td></tr>
<tr class="separator:af8b36914a97f0116f0344576eb1ec3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1289f625345da33e26854f44078002a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a1289f625345da33e26854f44078002a1">rtl_uString_newConcatUtf16L</a> (rtl_uString **newString, rtl_uString *left, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *right, sal_Int32 rightLength)</td></tr>
<tr class="memdesc:a1289f625345da33e26854f44078002a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string that is the concatenation of two other strings.  <a href="#a1289f625345da33e26854f44078002a1">More...</a><br/></td></tr>
<tr class="separator:a1289f625345da33e26854f44078002a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df7b0b9ce2361af1dca7d160150a1b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a6df7b0b9ce2361af1dca7d160150a1b1">rtl_uString_newReplaceStrAt</a> (rtl_uString **newStr, rtl_uString *str, sal_Int32 idx, sal_Int32 count, rtl_uString *subStr) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a6df7b0b9ce2361af1dca7d160150a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing a substring of another string.  <a href="#a6df7b0b9ce2361af1dca7d160150a1b1">More...</a><br/></td></tr>
<tr class="separator:a6df7b0b9ce2361af1dca7d160150a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc1b67ad568114a7bdbe59f0e299946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#adbc1b67ad568114a7bdbe59f0e299946">rtl_uString_newReplace</a> (rtl_uString **newStr, rtl_uString *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> oldChar, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> newChar) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:adbc1b67ad568114a7bdbe59f0e299946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a single character within another string.  <a href="#adbc1b67ad568114a7bdbe59f0e299946">More...</a><br/></td></tr>
<tr class="separator:adbc1b67ad568114a7bdbe59f0e299946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61c10a779f20722ac0db621a2b882c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ae61c10a779f20722ac0db621a2b882c4">rtl_uString_newReplaceFirst</a> (rtl_uString **newStr, rtl_uString *str, rtl_uString const *from, rtl_uString const *to, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ae61c10a779f20722ac0db621a2b882c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#ae61c10a779f20722ac0db621a2b882c4">More...</a><br/></td></tr>
<tr class="separator:ae61c10a779f20722ac0db621a2b882c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d68242f6bbee9a50c4bc917d9926ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a95d68242f6bbee9a50c4bc917d9926ae">rtl_uString_newReplaceFirstAsciiL</a> (rtl_uString **newStr, rtl_uString *str, char const *from, sal_Int32 fromLength, rtl_uString const *to, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a95d68242f6bbee9a50c4bc917d9926ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#a95d68242f6bbee9a50c4bc917d9926ae">More...</a><br/></td></tr>
<tr class="separator:a95d68242f6bbee9a50c4bc917d9926ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be44996009c3742c4b7dbb92545580e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a3be44996009c3742c4b7dbb92545580e">rtl_uString_newReplaceFirstToAsciiL</a> (rtl_uString **newStr, rtl_uString *str, rtl_uString const *from, char const *to, sal_Int32 toLength, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a3be44996009c3742c4b7dbb92545580e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#a3be44996009c3742c4b7dbb92545580e">More...</a><br/></td></tr>
<tr class="separator:a3be44996009c3742c4b7dbb92545580e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3cc70e2657710ed6eb6715de14a874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aaa3cc70e2657710ed6eb6715de14a874">rtl_uString_newReplaceFirstAsciiLAsciiL</a> (rtl_uString **newStr, rtl_uString *str, char const *from, sal_Int32 fromLength, char const *to, sal_Int32 toLength, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aaa3cc70e2657710ed6eb6715de14a874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#aaa3cc70e2657710ed6eb6715de14a874">More...</a><br/></td></tr>
<tr class="separator:aaa3cc70e2657710ed6eb6715de14a874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea89ae4b2ff78611a7265c99e8c41219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aea89ae4b2ff78611a7265c99e8c41219">rtl_uString_newReplaceFirstAsciiLUtf16L</a> (rtl_uString **newStr, rtl_uString *str, char const *from, sal_Int32 fromLength, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *to, sal_Int32 toLength, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aea89ae4b2ff78611a7265c99e8c41219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#aea89ae4b2ff78611a7265c99e8c41219">More...</a><br/></td></tr>
<tr class="separator:aea89ae4b2ff78611a7265c99e8c41219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fcaccc51e8573115cbcbe2db5d9ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a39fcaccc51e8573115cbcbe2db5d9ee7">rtl_uString_newReplaceFirstUtf16LAsciiL</a> (rtl_uString **newStr, rtl_uString *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *from, sal_Int32 fromLength, char const *to, sal_Int32 toLength, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a39fcaccc51e8573115cbcbe2db5d9ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#a39fcaccc51e8573115cbcbe2db5d9ee7">More...</a><br/></td></tr>
<tr class="separator:a39fcaccc51e8573115cbcbe2db5d9ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aa785ee3a32f3db21471f922fd011b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a05aa785ee3a32f3db21471f922fd011b">rtl_uString_newReplaceFirstUtf16LUtf16L</a> (rtl_uString **newStr, rtl_uString *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *from, sal_Int32 fromLength, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *to, sal_Int32 toLength, sal_Int32 *index) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a05aa785ee3a32f3db21471f922fd011b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing the first occurrence of a given substring with another substring.  <a href="#a05aa785ee3a32f3db21471f922fd011b">More...</a><br/></td></tr>
<tr class="separator:a05aa785ee3a32f3db21471f922fd011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e20157b49fa991047a38a8cbbe446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a3d4e20157b49fa991047a38a8cbbe446">rtl_uString_newReplaceAll</a> (rtl_uString **newStr, rtl_uString *str, rtl_uString const *from, rtl_uString const *to) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a3d4e20157b49fa991047a38a8cbbe446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#a3d4e20157b49fa991047a38a8cbbe446">More...</a><br/></td></tr>
<tr class="separator:a3d4e20157b49fa991047a38a8cbbe446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178c44bdb6fea4f9fb84a53ef27db8f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a178c44bdb6fea4f9fb84a53ef27db8f4">rtl_uString_newReplaceAllFromIndex</a> (rtl_uString **newStr, rtl_uString *str, rtl_uString const *from, rtl_uString const *to, sal_Int32 fromIndex) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a178c44bdb6fea4f9fb84a53ef27db8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#a178c44bdb6fea4f9fb84a53ef27db8f4">More...</a><br/></td></tr>
<tr class="separator:a178c44bdb6fea4f9fb84a53ef27db8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d739cbd054b979a917cebb5de27c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a12d739cbd054b979a917cebb5de27c25">rtl_uString_newReplaceAllAsciiL</a> (rtl_uString **newStr, rtl_uString *str, char const *from, sal_Int32 fromLength, rtl_uString const *to) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a12d739cbd054b979a917cebb5de27c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#a12d739cbd054b979a917cebb5de27c25">More...</a><br/></td></tr>
<tr class="separator:a12d739cbd054b979a917cebb5de27c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7423b694a2b1074fc7dadcca9a8695f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a7423b694a2b1074fc7dadcca9a8695f7">rtl_uString_newReplaceAllToAsciiL</a> (rtl_uString **newStr, rtl_uString *str, rtl_uString const *from, char const *to, sal_Int32 toLength) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a7423b694a2b1074fc7dadcca9a8695f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#a7423b694a2b1074fc7dadcca9a8695f7">More...</a><br/></td></tr>
<tr class="separator:a7423b694a2b1074fc7dadcca9a8695f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2692a87d792af863ccde2c5d11d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ac5b2692a87d792af863ccde2c5d11d1e">rtl_uString_newReplaceAllAsciiLAsciiL</a> (rtl_uString **newStr, rtl_uString *str, char const *from, sal_Int32 fromLength, char const *to, sal_Int32 toLength) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ac5b2692a87d792af863ccde2c5d11d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#ac5b2692a87d792af863ccde2c5d11d1e">More...</a><br/></td></tr>
<tr class="separator:ac5b2692a87d792af863ccde2c5d11d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2debad53dda7bfd54d8b0c858fc2f7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a2debad53dda7bfd54d8b0c858fc2f7c6">rtl_uString_newReplaceAllAsciiLUtf16L</a> (rtl_uString **newStr, rtl_uString *str, char const *from, sal_Int32 fromLength, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *to, sal_Int32 toLength) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a2debad53dda7bfd54d8b0c858fc2f7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#a2debad53dda7bfd54d8b0c858fc2f7c6">More...</a><br/></td></tr>
<tr class="separator:a2debad53dda7bfd54d8b0c858fc2f7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be43fe10f0dcee0f05ad3465d813f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a9be43fe10f0dcee0f05ad3465d813f4c">rtl_uString_newReplaceAllUtf16LAsciiL</a> (rtl_uString **newStr, rtl_uString *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *from, sal_Int32 fromLength, char const *to, sal_Int32 toLength) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a9be43fe10f0dcee0f05ad3465d813f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#a9be43fe10f0dcee0f05ad3465d813f4c">More...</a><br/></td></tr>
<tr class="separator:a9be43fe10f0dcee0f05ad3465d813f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78daa0f7df4977993da9160ea4cb3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aa78daa0f7df4977993da9160ea4cb3e7">rtl_uString_newReplaceAllUtf16LUtf16L</a> (rtl_uString **newStr, rtl_uString *str, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *from, sal_Int32 fromLength, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *to, sal_Int32 toLength) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aa78daa0f7df4977993da9160ea4cb3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by replacing all occurrences of a given substring with another substring.  <a href="#aa78daa0f7df4977993da9160ea4cb3e7">More...</a><br/></td></tr>
<tr class="separator:aa78daa0f7df4977993da9160ea4cb3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79aba45c11b88b87e05c68d197e759cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a79aba45c11b88b87e05c68d197e759cd">rtl_uString_newToAsciiLowerCase</a> (rtl_uString **newStr, rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a79aba45c11b88b87e05c68d197e759cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by converting all ASCII uppercase letters to lowercase within another string.  <a href="#a79aba45c11b88b87e05c68d197e759cd">More...</a><br/></td></tr>
<tr class="separator:a79aba45c11b88b87e05c68d197e759cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8c19aada6fef8cd6bc683ccff5faed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aeb8c19aada6fef8cd6bc683ccff5faed">rtl_uString_newToAsciiUpperCase</a> (rtl_uString **newStr, rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aeb8c19aada6fef8cd6bc683ccff5faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by converting all ASCII lowercase letters to uppercase within another string.  <a href="#aeb8c19aada6fef8cd6bc683ccff5faed">More...</a><br/></td></tr>
<tr class="separator:aeb8c19aada6fef8cd6bc683ccff5faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f72ce7c64f77e68599001bb9c884ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#aa0f72ce7c64f77e68599001bb9c884ad">rtl_uString_newTrim</a> (rtl_uString **newStr, rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:aa0f72ce7c64f77e68599001bb9c884ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by removing white space from both ends of another string.  <a href="#aa0f72ce7c64f77e68599001bb9c884ad">More...</a><br/></td></tr>
<tr class="separator:aa0f72ce7c64f77e68599001bb9c884ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdde6724eb6d612970fe59d7eb6c4fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a1fdde6724eb6d612970fe59d7eb6c4fb">rtl_uString_getToken</a> (rtl_uString **newStr, rtl_uString *str, sal_Int32 token, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> cTok, sal_Int32 idx) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a1fdde6724eb6d612970fe59d7eb6c4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string by extracting a single token from another string.  <a href="#a1fdde6724eb6d612970fe59d7eb6c4fb">More...</a><br/></td></tr>
<tr class="separator:a1fdde6724eb6d612970fe59d7eb6c4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa9c92f9c9acac4d63a32f6a5251be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a51aa9c92f9c9acac4d63a32f6a5251be">rtl_string2UString</a> (rtl_uString **newStr, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *str, sal_Int32 len, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> encoding, sal_uInt32 convertFlags) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a51aa9c92f9c9acac4d63a32f6a5251be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Unicode string by converting a byte string, using a specific text encoding.  <a href="#a51aa9c92f9c9acac4d63a32f6a5251be">More...</a><br/></td></tr>
<tr class="separator:a51aa9c92f9c9acac4d63a32f6a5251be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082def1a9e7931eb3eaf5445d652c77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#ab082def1a9e7931eb3eaf5445d652c77">rtl_uString_intern</a> (rtl_uString **newStr, rtl_uString *str) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:ab082def1a9e7931eb3eaf5445d652c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a canonical representation for a string.  <a href="#ab082def1a9e7931eb3eaf5445d652c77">More...</a><br/></td></tr>
<tr class="separator:ab082def1a9e7931eb3eaf5445d652c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc865058f5df78cdfe124fd7d3019305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#abc865058f5df78cdfe124fd7d3019305">rtl_uString_internConvert</a> (rtl_uString **newStr, const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *str, sal_Int32 len, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> encoding, sal_uInt32 convertFlags, sal_uInt32 *pInfo) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:abc865058f5df78cdfe124fd7d3019305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a canonical representation for a string.  <a href="#abc865058f5df78cdfe124fd7d3019305">More...</a><br/></td></tr>
<tr class="separator:abc865058f5df78cdfe124fd7d3019305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa6da493c3f5c711c6afe0a3c78b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_uInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a75aa6da493c3f5c711c6afe0a3c78b88">rtl_uString_iterateCodePoints</a> (rtl_uString const *string, sal_Int32 *indexUtf16, sal_Int32 incrementCodePoints)</td></tr>
<tr class="memdesc:a75aa6da493c3f5c711c6afe0a3c78b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through a string based on code points instead of UTF-16 code units.  <a href="#a75aa6da493c3f5c711c6afe0a3c78b88">More...</a><br/></td></tr>
<tr class="separator:a75aa6da493c3f5c711c6afe0a3c78b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72087462f3dd7478a95139401de05dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a72087462f3dd7478a95139401de05dbb">rtl_convertStringToUString</a> (rtl_uString **target, char const *source, sal_Int32 length, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> encoding, sal_uInt32 flags) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a72087462f3dd7478a95139401de05dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a byte string to a Unicode string, signalling failure.  <a href="#a72087462f3dd7478a95139401de05dbb">More...</a><br/></td></tr>
<tr class="separator:a72087462f3dd7478a95139401de05dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b099139a918c518b70978a7fc0b2860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html#a7b099139a918c518b70978a7fc0b2860">rtl_uString_ensureCapacity</a> (rtl_uString **str, sal_Int32 size) <a class="el" href="a00439.html#a370b7191605523fef93ef7bb153c5aa6">SAL_THROW_EXTERN_C</a>()</td></tr>
<tr class="memdesc:a7b099139a918c518b70978a7fc0b2860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure a string has enough space for a given number of characters.  <a href="#a7b099139a918c518b70978a7fc0b2860">More...</a><br/></td></tr>
<tr class="separator:a7b099139a918c518b70978a7fc0b2860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a0d72f032eb9370c7403fccb71c4e6906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSTRING_TO_OUSTRING_CVTFLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="a00391.html#a4ccdc13bc79ff2ee39f51f5cc68b5637">RTL_TEXTTOUNICODE_FLAGS_UNDEFINED_MAPTOPRIVATE</a> |<a class="code" href="a00391.html#a92db823948cbbb440676a49236933f0e">\</a></div>
<div class="line"><a class="code" href="a00391.html#a92db823948cbbb440676a49236933f0e">                                         RTL_TEXTTOUNICODE_FLAGS_MBUNDEFINED_DEFAULT</a> |<a class="code" href="a00391.html#ae9d8b4f51a0cd2b1ceeb5acfe9ffef0c">\</a></div>
<div class="line"><a class="code" href="a00391.html#ae9d8b4f51a0cd2b1ceeb5acfe9ffef0c">                                         RTL_TEXTTOUNICODE_FLAGS_INVALID_DEFAULT</a>)</div>
<div class="ttc" id="a00391_html_a4ccdc13bc79ff2ee39f51f5cc68b5637"><div class="ttname"><a href="a00391.html#a4ccdc13bc79ff2ee39f51f5cc68b5637">RTL_TEXTTOUNICODE_FLAGS_UNDEFINED_MAPTOPRIVATE</a></div><div class="ttdeci">#define RTL_TEXTTOUNICODE_FLAGS_UNDEFINED_MAPTOPRIVATE</div><div class="ttdef"><b>Definition:</b> textcvt.h:66</div></div>
<div class="ttc" id="a00391_html_a92db823948cbbb440676a49236933f0e"><div class="ttname"><a href="a00391.html#a92db823948cbbb440676a49236933f0e">RTL_TEXTTOUNICODE_FLAGS_MBUNDEFINED_DEFAULT</a></div><div class="ttdeci">#define RTL_TEXTTOUNICODE_FLAGS_MBUNDEFINED_DEFAULT</div><div class="ttdef"><b>Definition:</b> textcvt.h:70</div></div>
<div class="ttc" id="a00391_html_ae9d8b4f51a0cd2b1ceeb5acfe9ffef0c"><div class="ttname"><a href="a00391.html#ae9d8b4f51a0cd2b1ceeb5acfe9ffef0c">RTL_TEXTTOUNICODE_FLAGS_INVALID_DEFAULT</a></div><div class="ttdeci">#define RTL_TEXTTOUNICODE_FLAGS_INVALID_DEFAULT</div><div class="ttdef"><b>Definition:</b> textcvt.h:73</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a63e64d39ab88fe964f91477896156409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_CONSTASCII_USTRINGPARAM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">constAsciiStr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(&amp;(constAsciiStr)[0]), \</div>
<div class="line">    ((sal_Int32)(<a class="code" href="a00405.html#ad56610d7471bc023d05f6aa1cbdbdacc">SAL_N_ELEMENTS</a>(constAsciiStr)-1)), <a class="code" href="a00392.html#a08472f1efcfed01b883e19de011111b6">RTL_TEXTENCODING_ASCII_US</a></div>
<div class="ttc" id="a00405_html_ad56610d7471bc023d05f6aa1cbdbdacc"><div class="ttname"><a href="a00405.html#ad56610d7471bc023d05f6aa1cbdbdacc">SAL_N_ELEMENTS</a></div><div class="ttdeci">#define SAL_N_ELEMENTS(arr)</div><div class="ttdef"><b>Definition:</b> macros.h:47</div></div>
<div class="ttc" id="a00392_html_a08472f1efcfed01b883e19de011111b6"><div class="ttname"><a href="a00392.html#a08472f1efcfed01b883e19de011111b6">RTL_TEXTENCODING_ASCII_US</a></div><div class="ttdeci">#define RTL_TEXTENCODING_ASCII_US</div><div class="ttdef"><b>Definition:</b> textenc.h:48</div></div>
</div><!-- fragment -->
<p>Supply an ASCII string literal together with its length and text encoding. </p>
<p>This macro can be used to compute (some of) the arguments in function calls like <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">rtl::OUString</a>(RTL_CONSTASCII_USTRINGPARAM("foo")).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constAsciiStr</td><td>must be an expression of type "(possibly cv-qualified reference to) array of
(possibly cv-qualified) char." Each element of the referenced array must represent an ASCII value in the range 0x00&ndash;0x7F. The last element of the referenced array is not considered part of the represented ASCII string, and its value should be 0x00. Depending on where this macro is used, the nature of the supplied expression might be further restricted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a973903d85ce863437b12e40a4f720ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_RADIX&#160;&#160;&#160;<a class="el" href="a00386.html#a8553f7b745ed840d2e01c78c6e0e1a38">RTL_STR_MAX_RADIX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab971bef6363adb307b39134b70f96756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFBOOLEAN&#160;&#160;&#160;<a class="el" href="a00386.html#a9a1acbd13cd08701747dd642e61c7653">RTL_STR_MAX_VALUEOFBOOLEAN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19d2913d4e6ebe205c90e507da7829fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFCHAR&#160;&#160;&#160;<a class="el" href="a00386.html#a5bc43d45541495ab4f2266fd9ccf9c15">RTL_STR_MAX_VALUEOFCHAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20dd11c5cf6798ee4a76874fdbb77d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFDOUBLE&#160;&#160;&#160;<a class="el" href="a00386.html#a312bc78cc5becf2055c01c49c6fca940">RTL_STR_MAX_VALUEOFDOUBLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a116dc6ca166b2f7f6ae07d97db1bf8c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFFLOAT&#160;&#160;&#160;<a class="el" href="a00386.html#a9b29548a9c2f0372173ff1b0f8896067">RTL_STR_MAX_VALUEOFFLOAT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa6288cdd9afef96e0d4fab3372864d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFINT32&#160;&#160;&#160;<a class="el" href="a00386.html#a34fb24bbd40d09cfca323211a99edf40">RTL_STR_MAX_VALUEOFINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e1db0cbdd782a9ae0bc590af4cb34ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFINT64&#160;&#160;&#160;<a class="el" href="a00386.html#abacb5a4eeccc30233b955d0ba43c9154">RTL_STR_MAX_VALUEOFINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e1db0cbdd782a9ae0bc590af4cb34ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MAX_VALUEOFINT64&#160;&#160;&#160;<a class="el" href="a00386.html#abacb5a4eeccc30233b955d0ba43c9154">RTL_STR_MAX_VALUEOFINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a463f9ee8978efb0d8d2fb8f3f00d434f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTL_USTR_MIN_RADIX&#160;&#160;&#160;<a class="el" href="a00386.html#ae983b6c9bf97ce91c1018f79a3250d7f">RTL_STR_MIN_RADIX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a72087462f3dd7478a95139401de05dbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a> rtl_convertStringToUString </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a byte string to a Unicode string, signalling failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>An out parameter receiving the converted string. Must not be null itself, and must contain either null or a pointer to a valid rtl_uString; the contents are unspecified if conversion fails (rtl_convertStringToUString returns false).</td></tr>
    <tr><td class="paramname">source</td><td>The byte string. May only be null if length is zero.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the byte string. Must be non-negative.</td></tr>
    <tr><td class="paramname">encoding</td><td>The text encoding to convert from. Must be an octet encoding (i.e., rtl_isOctetTextEncoding(encoding) must return true).</td></tr>
    <tr><td class="paramname">flags</td><td>A combination of RTL_TEXTTOUNICODE_FLAGS that detail how to do the conversion (see rtl_convertTextToUnicode). RTL_TEXTTOUNICODE_FLAGS_FLUSH need not be included, it is implicitly assumed. Typical uses are either RTL_TEXTTOUNICODE_FLAGS_UNDEFINED_ERROR | RTL_TEXTTOUNICODE_FLAGS_MBUNDEFINED_ERROR | RTL_TEXTTOUNICODE_FLAGS_INVALID_ERROR (fail if a byte or multi-byte sequence cannot be converted from the source encoding) or OSTRING_TO_OUSTRING_CVTFLAGS (make a best efforts conversion).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the conversion succeeded, false otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.9 </dd></dl>

</div>
</div>
<a class="anchor" id="a51aa9c92f9c9acac4d63a32f6a5251be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_string2UString </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>convertFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Unicode string by converting a byte string, using a specific text encoding. </p>
<p>The lengths of the byte string and the Unicode string may differ (e.g., for double-byte encodings, UTF-7, UTF-8).</p>
<p>If the length of the byte string is greater than zero, the reference count of the new string will be 1.</p>
<p>If an out-of-memory condition occurs, newStr will point to a null pointer upon return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">str</td><td>a byte character array. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the byte character array.</td></tr>
    <tr><td class="paramname">encoding</td><td>the text encoding to use for conversion.</td></tr>
    <tr><td class="paramname">convertFlags</td><td>flags which control the conversion. Either use OSTRING_TO_OUSTRING_CVTFLAGS, or see <a href="http://udk.openoffice.org/cpp/man/spec/textconversion.html">http://udk.openoffice.org/cpp/man/spec/textconversion.html</a> for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a684efea6035a2575347e24c7f1580d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting. Both strings must be null-terminated.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first null-terminated string to be compared.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated ASCII string which is compared with the first one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both substrings are equal, a value less than 0 if the first substring is less than the second substring, and a value greater than 0 if the first substring is greater than the second substring. </dd></dl>

</div>
</div>
<a class="anchor" id="abc8f17670a52936c81a22e02ebe88054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_compare_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated ASCII string which is compared with the first one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both substrings are equal, a value less than 0 if the first substring is less than the second substring, and a value greater than 0 if the first substring is greater than the second substring. </dd></dl>

</div>
</div>
<a class="anchor" id="a6454e4627f48c6c053146975d9a908f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_compareIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting. Both strings must be null-terminated.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first null-terminated string to be compared.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated ASCII string which is compared with the first one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="af2a6a1e43a7155197302e23da86af444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated ASCII string which is compared with the first one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="a040b33cbee9716ee6498e7816fca292e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_compareIgnoreAsciiCase_WithLengths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2445b06d4ba5eeeaef79cdb03ceb8ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_shortenedCompare_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>shortenedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings with a maximum count of characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated ASCII string which is compared with the first one.</td></tr>
    <tr><td class="paramname">shortenedLen</td><td>the maximum number of characters to compare. This length can be greater or smaller than the lengths of the two strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both substrings are equal, a value less than 0 if the first substring is less than the second substring, and a value greater than 0 if the first substring is greater than the second substring. </dd></dl>

</div>
</div>
<a class="anchor" id="adbc8fa7696b241bfc41c9507535347a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_ascii_shortenedCompareIgnoreAsciiCase_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>shortenedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings with a maximum count of characters, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated ASCII string which is compared with the first one.</td></tr>
    <tr><td class="paramname">shortenedLen</td><td>the maximum number of characters to compare. This length can be greater or smaller than the lengths of the two strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both substrings are equal, a value less than 0 if the first substring is less than the second substring, and a value greater than 0 if the first substring is greater than the second substring. </dd></dl>

</div>
</div>
<a class="anchor" id="a65a81e7cdccb3437319e253a9520054b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_asciil_reverseCompare_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings from back to front. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second ASCII string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string compares less than the second string, and a value greater than 0 if the first string compares greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c53b6fc4fa0e924edee4a68cee579f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a> rtl_ustr_asciil_reverseEquals_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings from back to front for equality. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns 'true' if, and only if, both strings are equal. This function cannot be used for language-specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of both strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both strings are equal, false if they are not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a90785105dedfa6580f61468063da784d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting. Both strings must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first null-terminated string to be compared.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated string which is compared with the first one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="a124db73aefd1cd95bb435a2b607470d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_compare_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="a260a0e528f81006e939de1f05750a1cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_compareIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting. Both strings must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first null-terminated string to be compared.</td></tr>
    <tr><td class="paramname">second</td><td>the second null-terminated string which is compared with the first one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8d88350984f243593da9347010da478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_compareIgnoreAsciiCase_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string is less than the second string, and a value greater than 0 if the first string is greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="a86a3766acd1b77c054cf7bc9b1ce7d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_getLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of a string. </p>
<p>The length is equal to the number of 16-bit Unicode characters in the string, without the terminating NUL character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the sequence of characters represented by this string, excluding the terminating NUL character. </dd></dl>

</div>
</div>
<a class="anchor" id="a33e05e35bd841a5fe2c4506877018c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_hashCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a hash code for a string. </p>
<p>It is not allowed to store the hash code persistently, because later versions could return other hash codes. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a hash code for the given string. </dd></dl>

</div>
</div>
<a class="anchor" id="ae40b5c79da08ab51a4bd07b1957c74ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_hashCode_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a hash code for a string. </p>
<p>It is not allowed to store the hash code persistently, because later versions could return other hash codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a hash code for the given string. </dd></dl>

</div>
</div>
<a class="anchor" id="a9644902b83fdc429c1293aaa69d1b930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_indexOfAscii_WithLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>subStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>subLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of an ASCII substring within a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string; must be non-negative.</td></tr>
    <tr><td class="paramname">subStr</td><td>the substring to be searched for. Need not be null-terminated, but must be at least as long as the specified subLen. Must only contain characters in the ASCII range 0x00&ndash;7F.</td></tr>
    <tr><td class="paramname">subLen</td><td>the length of the substring; must be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the first occurrence of the substring within the string, or -1 if the substring does not occur. If subLen is zero, -1 is returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="abcc883bb9b161e41a32167350e0b878a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_indexOfChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a character within a string. </p>
<p>The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">ch</td><td>the character to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first occurrence of the character in the string, or -1 if the character does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="af5885afdbf5abb6bcb4a8ff4fca9068d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_indexOfChar_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a character within a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string.</td></tr>
    <tr><td class="paramname">ch</td><td>the character to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first occurrence of the character in the string, or -1 if the character does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a2d6ed6c28942c98bfe74b9eb098e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_indexOfStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>subStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a substring within a string. </p>
<p>If subStr is empty, or both str and subStr are empty, -1 is returned. Both strings must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">subStr</td><td>the null-terminated substring to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the first occurrence of the substring within the string, or -1 if the substring does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf74654c6506fe615321503e5ba0c17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_indexOfStr_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>subStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>subLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a substring within a string. </p>
<p>If subStr is empty, or both str and subStr are empty, -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string.</td></tr>
    <tr><td class="paramname">subStr</td><td>the substring to be searched for. Need not be null-terminated, but must be at least as long as the specified subLen.</td></tr>
    <tr><td class="paramname">subLen</td><td>the length of the substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the first occurrence of the substring within the string, or -1 if the substring does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a94cba82a70b4971faac198187251db69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_lastIndexOfAscii_WithLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>subStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>subLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of an ASCII substring within a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string; must be non-negative.</td></tr>
    <tr><td class="paramname">subStr</td><td>the substring to be searched for. Need not be null-terminated, but must be at least as long as the specified subLen. Must only contain characters in the ASCII range 0x00&ndash;7F.</td></tr>
    <tr><td class="paramname">subLen</td><td>the length of the substring; must be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the last occurrence of the substring within the string, or -1 if the substring does not occur. If subLen is zero, -1 is returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a56fc5c2162dcc3a14644ff804758830a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_lastIndexOfChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a character within a string. </p>
<p>The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">ch</td><td>the character to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the last occurrence of the character in the string, or -1 if the character does not occur. The returned value is always smaller than the string length. </dd></dl>

</div>
</div>
<a class="anchor" id="aa85f90b63372f3b18f4892373366ffd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_lastIndexOfChar_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a character within a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string.</td></tr>
    <tr><td class="paramname">ch</td><td>the character to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the last occurrence of the character in the string, or -1 if the character does not occur. The returned value is always smaller than the string length. </dd></dl>

</div>
</div>
<a class="anchor" id="a4119b0bbcf63d015cfe39aa24930593a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_lastIndexOfStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>subStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a substring within a string. </p>
<p>If subStr is empty, or both str and subStr are empty, -1 is returned. Both strings must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">subStr</td><td>the null-terminated substring to be searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the last occurrence of the substring within the string, or -1 if the substring does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="af5178d3cefef20b9590bcf6e8e922104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_lastIndexOfStr_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>subStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>subLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a substring within a string. </p>
<p>If subStr is empty, or both str and subStr are empty, -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string.</td></tr>
    <tr><td class="paramname">subStr</td><td>the substring to be searched for. Need not be null-terminated, but must be at least as long as the specified subLen.</td></tr>
    <tr><td class="paramname">subLen</td><td>the length of the substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the first occurrence of the substring within the string, or -1 if the substring does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a4971004e89088cd15015ea87e992226a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_ustr_replaceChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>oldChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>newChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a single character within a string. </p>
<p>If oldChar does not occur within str, then the string is not modified. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">oldChar</td><td>the old character.</td></tr>
    <tr><td class="paramname">newChar</td><td>the new character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37bdabfa4afa8ea71089307ea106cc97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_ustr_replaceChar_WithLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>oldChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>newChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of a single character within a string. </p>
<p>If oldChar does not occur within str, then the string is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string.</td></tr>
    <tr><td class="paramname">oldChar</td><td>the old character.</td></tr>
    <tr><td class="paramname">newChar</td><td>the new character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc7b9f6a383331510cce6948dfa3289a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_reverseCompare_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings from back to front. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both strings are equal, a value less than 0 if the first string compares less than the second string, and a value greater than 0 if the first string compares greater than the second string. </dd></dl>

</div>
</div>
<a class="anchor" id="acc94338a5dcbc101095c8cec054e822c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_shortenedCompare_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>shortenedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings with a maximum count of characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. This function cannot be used for language-specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
    <tr><td class="paramname">shortenedLen</td><td>the maximum number of characters to compare. This length can be greater or smaller than the lengths of the two strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both substrings are equal, a value less than 0 if the first substring is less than the second substring, and a value greater than 0 if the first substring is greater than the second substring. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e561bed052ac227315e901a6a28aac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_shortenedCompareIgnoreAsciiCase_WithLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>firstLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>secondLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>shortenedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings with a maximum count of characters, ignoring the case of ASCII characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and returns a value indicating their relationship. Character values between 65 and 90 (ASCII A&ndash;Z) are interpreted as values between 97 and 122 (ASCII a&ndash;z). This function cannot be used for language-specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first string to be compared. Need not be null-terminated, but must be at least as long as the specified firstLen.</td></tr>
    <tr><td class="paramname">firstLen</td><td>the length of the first string.</td></tr>
    <tr><td class="paramname">second</td><td>the second string which is compared with the first one. Need not be null-terminated, but must be at least as long as the specified secondLen.</td></tr>
    <tr><td class="paramname">secondLen</td><td>the length of the second string.</td></tr>
    <tr><td class="paramname">shortenedLen</td><td>the maximum number of characters to compare. This length can be greater or smaller than the lengths of the two strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both substrings are equal, a value less than 0 if the first substring is less than the second substring, and a value greater than 0 if the first substring is greater than the second substring. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b681c47777ba1563704bd6d99cc0e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_ustr_toAsciiLowerCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all ASCII uppercase letters to lowercase within a string. </p>
<p>The characters with values between 65 and 90 (ASCII A&ndash;Z) are replaced with values between 97 and 122 (ASCII a&ndash;z). The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d12eddbacde48561b1e1d6c595fb97a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_ustr_toAsciiLowerCase_WithLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all ASCII uppercase letters to lowercase within a string. </p>
<p>The characters with values between 65 and 90 (ASCII A&ndash;Z) are replaced with values between 97 and 122 (ASCII a&ndash;z).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3155e560a8e8eed5307afb92004441b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_ustr_toAsciiUpperCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all ASCII lowercase letters to uppercase within a string. </p>
<p>The characters with values between 97 and 122 (ASCII a&ndash;z) are replaced with values between 65 and 90 (ASCII A&ndash;Z). The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d862bce95973ab6f081075fc3498c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_ustr_toAsciiUpperCase_WithLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all ASCII lowercase letters to uppercase within a string. </p>
<p>The characters with values between 97 and 122 (ASCII a&ndash;z) are replaced with values between 65 and 90 (ASCII A&ndash;Z).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad99d7dfcbab09c8ce5e06e6c4cd1d875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a> rtl_ustr_toBoolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a boolean. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string is "1" or "true" in any ASCII case, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a31a83247509b977c5544fe89dfeefbe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> double rtl_ustr_toDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a double. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value represented by the string, or 0.0 if the string does not represent a double. </dd></dl>

</div>
</div>
<a class="anchor" id="a095f62523e29f8a6b9c7d359c658dd8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> float rtl_ustr_toFloat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a float. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value represented by the string, or 0.0 if the string does not represent a float. </dd></dl>

</div>
</div>
<a class="anchor" id="abfb8340c248ddff0dd70bdcafb2ce970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_toInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as an integer. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer value represented by the string, or 0 if the string does not represent an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cae24724274e715f7c711d3f5d285c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int64 rtl_ustr_toInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as a long integer. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long integer value represented by the string, or 0 if the string does not represent a long integer. </dd></dl>

</div>
</div>
<a class="anchor" id="aad54360bda37e6024b0086170485c32f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_uInt32 rtl_ustr_toUInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as an unsigned integer. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value represented by the string, or 0 if the string does not represent an unsigned integer.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a9819c1e369713b292e5db76774c00c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_uInt64 rtl_ustr_toUInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret a string as an unsigned long integer. </p>
<p>This function cannot be used for language-specific conversion. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned long integer value represented by the string, or 0 if the string does not represent an unsigned long integer.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a65d01bb3907c0c18b952586165624d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove white space from both ends of a string. </p>
<p>All characters with values less than or equal to 32 (the space character) are considered to be white space. This function cannot be used for language-specific operations. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f6b7156db00e672d0e06ed6703c59d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_trim_WithLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove white space from both ends of the string. </p>
<p>All characters with values less than or equal to 32 (the space character) are considered to be white space. This function cannot be used for language-specific operations. The string must be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the original length of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a316a42fb008376e0eab9cae47c202044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfBoolean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of a boolean. </p>
<p>If b is true, the buffer is filled with the string "true" and 5 is returned. If b is false, the buffer is filled with the string "false" and 6 is returned. This function cannot be used for language-specific operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFBOOLEAN define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">b</td><td>a boolean value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a59e8f0b451b22978f1833740af5d5170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFCHAR define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">ch</td><td>a character value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bf52a0e37b6da26b34f288ffd7d6a84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of a double. </p>
<p>This function cannot be used for language-specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFDOUBLE define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">d</td><td>a double value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a38091b25f1087791b1e67c6edc251aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of a float. </p>
<p>This function cannot be used for language-specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFFLOAT define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">f</td><td>a float value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="ad36b0465a36de322766743477df6b5ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfInt32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of an integer. </p>
<p>This function cannot be used for language-specific operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFINT32 define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">i</td><td>an integer value.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a94036537d404837b351c89a3ae1ad84b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int64&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of a long integer. </p>
<p>This function cannot be used for language-specific operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFINT64 define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">l</td><td>a long integer value.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7263f0941ed73607f4bf3409343b096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_ustr_valueOfUInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt64&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the string representation of an unsigned long integer. </p>
<p>This function cannot be used for language-specific operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a buffer that is big enough to hold the result and the terminating NUL character. You should use the RTL_USTR_MAX_VALUEOFUINT64 define to create a buffer that is big enough.</td></tr>
    <tr><td class="paramname">l</td><td>a long integer value.</td></tr>
    <tr><td class="paramname">radix</td><td>the radix. Must be between RTL_USTR_MIN_RADIX (2) and RTL_USTR_MAX_RADIX (36), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a6451e5468f66023626e1039c969476ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_acquire </td>
          <td>(</td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the reference count of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5326636513ae8a053da69c95d879d4ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> rtl_uString* rtl_uString_alloc </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>nLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string containing space for a given number of characters. </p>
<p>The reference count of the new string will be 1. The length of the string will be nLen. This function does not handle out-of-memory conditions.</p>
<p>For failed allocation this method returns NULL.</p>
<p>The characters of the capacity are not cleared, and the length is set to nLen, unlike the similar method of rtl_uString_new_WithLength which zeros out the buffer, and sets the length to 0. So should be somewhat more efficient for allocating a new string.</p>
<p>call rtl_uString_release to release the string alternatively pass ownership to an OUString with <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">rtl::OUString(newStr, SAL_NO_ACQUIRE)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nLen</td><td>the number of characters. Must be &gt;= 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new string.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a056143bcb3a2c991a8dc16123d2ba25f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_assign </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>rightValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a new value to a string. </p>
<p>First releases any value str might currently hold, then acquires rightValue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>pointer to the string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">rightValue</td><td>a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b099139a918c518b70978a7fc0b2860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_ensureCapacity </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure a string has enough space for a given number of characters. </p>
<p>If the given string is large enough and has refcount of 1, it is not altered in any way. Otherwise it is replaced by a copy that has enough space for the given number of characters, data from the source string is copied to the beginning of it, the content of the remaining capacity undefined, the string has refcount of 1, and refcount of the original string is decreased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>pointer to the string. The pointed-to data must be a valid string.</td></tr>
    <tr><td class="paramname">size</td><td>the number of characters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ab7f49d173ed996548a2185a7aace26d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_uString_getLength </td>
          <td>(</td>
          <td class="paramtype">const rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of a string. </p>
<p>The length is equal to the number of characters in the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a valid string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4f705706afaad1895e39260beebd325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>* rtl_uString_getStr </td>
          <td>(</td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the underlying character array of a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a valid string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the null-terminated character array. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdde6724eb6d612970fe59d7eb6c4fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_Int32 rtl_uString_getToken </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>cTok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by extracting a single token from another string. </p>
<p>Starting at index, the token's next token is searched for. If there is no such token, the result is an empty string. Otherwise, all characters from the start of that token and up to, but not including the next occurrence of cTok make up the resulting token. The return value is the position of the next token, or -1 if no more tokens follow.</p>
<p>Example code could look like rtl_uString * pToken = NULL; sal_Int32 nIndex = 0; do { ... nIndex = rtl_uString_getToken(&amp;pToken, pStr, 0, ';', nIndex); ... } while (nIndex &gt;= 0);</p>
<p>The new string does not necessarily have a reference count of 1, so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string. If either token or index is negative, an empty token is stored in newStr (and -1 is returned).</td></tr>
    <tr><td class="paramname">str</td><td>a valid string.</td></tr>
    <tr><td class="paramname">token</td><td>the number of the token to return, starting at index.</td></tr>
    <tr><td class="paramname">cTok</td><td>the character that separates the tokens.</td></tr>
    <tr><td class="paramname">idx</td><td>the position at which searching for the token starts. Must not be greater than the length of str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the next token, or -1 if no more tokens follow. </dd></dl>

</div>
</div>
<a class="anchor" id="ab082def1a9e7931eb3eaf5445d652c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_intern </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a canonical representation for a string. </p>
<p>A pool of strings, initially empty is maintained privately by the string class. On invocation, if present in the pool the original string will be returned. Otherwise this string, or a copy thereof will be added to the pool and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
  </table>
  </dd>
</dl>
<p>If an out-of-memory condition occurs, newStr will point to a null pointer upon return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>pointer to the string to be interned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="abc865058f5df78cdfe124fd7d3019305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_internConvert </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>convertFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32 *&#160;</td>
          <td class="paramname"><em>pInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a canonical representation for a string. </p>
<p>A pool of strings, initially empty is maintained privately by the string class. On invocation, if present in the pool the original string will be returned. Otherwise this string, or a copy thereof will be added to the pool and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
  </table>
  </dd>
</dl>
<p>If an out-of-memory condition occurs, newStr will point to a null pointer upon return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a byte character array. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the byte character array.</td></tr>
    <tr><td class="paramname">encoding</td><td>the text encoding to use for conversion.</td></tr>
    <tr><td class="paramname">convertFlags</td><td>flags which control the conversion. Either use OSTRING_TO_OUSTRING_CVTFLAGS, or see <a href="http://udk.openoffice.org/cpp/man/spec/textconversion.html">http://udk.openoffice.org/cpp/man/spec/textconversion.html</a> for more details.</td></tr>
    <tr><td class="paramname">pInfo</td><td>pointer to return conversion status in, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a75aa6da493c3f5c711c6afe0a3c78b88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> sal_uInt32 rtl_uString_iterateCodePoints </td>
          <td>(</td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>indexUtf16</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>incrementCodePoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through a string based on code points instead of UTF-16 code units. </p>
<p>See Chapter 3 of The Unicode Standard 5.0 (Addison&ndash;Wesley, 2006) for definitions of the various terms used in this description.</p>
<p>The given string is interpreted as a sequence of zero or more UTF-16 code units. For each index into this sequence (from zero to one less than the length of the sequence, inclusive), a code point represented starting at the given index is computed as follows:</p>
<ul>
<li>If the UTF-16 code unit addressed by the index constitutes a well-formed UTF-16 code unit sequence, the computed code point is the scalar value encoded by that UTF-16 code unit sequence.</li>
<li>Otherwise, if the index is at least two UTF-16 code units away from the end of the sequence, and the sequence of two UTF-16 code units addressed by the index constitutes a well-formed UTF-16 code unit sequence, the computed code point is the scalar value encoded by that UTF-16 code unit sequence.</li>
<li>Otherwise, the computed code point is the UTF-16 code unit addressed by the index. (This last case catches unmatched surrogates as well as indices pointing into the middle of surrogate pairs.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>pointer to a valid string; must not be null.</td></tr>
    <tr><td class="paramname">indexUtf16</td><td>pointer to a UTF-16 based index into the given string; must not be null. On entry, the index must be in the range from zero to the length of the string (in UTF-16 code units), inclusive. Upon successful return, the index will be updated to address the UTF-16 code unit that is the given incrementCodePoints away from the initial index.</td></tr>
    <tr><td class="paramname">incrementCodePoints</td><td>the number of code points to move the given *indexUtf16. If non-negative, moving is done after determining the code point at the index. If negative, moving is done before determining the code point at the (then updated) index. The value must be such that the resulting UTF-16 based index is in the range from zero to the length of the string (in UTF-16 code units), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the code point (an integer in the range from 0 to 0x10FFFF, inclusive) that is represented within the string starting at the index computed as follows: If incrementCodePoints is non-negative, the index is the initial value of indexUtf16; if incrementCodePoints is negative, the index is the updated value of *indexUtf16. In either case, the computed index must be in the range from zero to one less than the length of the string (in UTF-16 code units), inclusive.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a0be57a48ad92c87d3baf52f66fe42cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_new </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string containing no characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f360c7c95595b6761965247ffbf8e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_new_WithLength </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string containing space for a given number of characters. </p>
<p>If len is greater than zero, the reference count of the new string will be</p>
<ol type="1">
<li>The values of all characters are set to 0 and the length of the string is 0. This function does not handle out-of-memory conditions.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">nLen</td><td>the number of characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e1be99fd5c7c91d3053a1e7ce19c875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newConcat </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string that is the concatenation of two other strings. </p>
<p>The new string does not necessarily have a reference count of 1 (in cases where one of the two other strings is empty), so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">left</td><td>a valid string.</td></tr>
    <tr><td class="paramname">right</td><td>a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8b36914a97f0116f0344576eb1ec3ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newConcatAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>rightLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string that is the concatenation of two other strings. </p>
<p>The new string does not necessarily have a reference count of 1 (in cases where the ASCII string is empty), so it must not be modified without checking the reference count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newString</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">left</td><td>a valid string.</td></tr>
    <tr><td class="paramname">right</td><td>must not be null and must point to memory of at least <code>rightLength</code> ASCII bytes</td></tr>
    <tr><td class="paramname">rightLength</td><td>the length of the <code>right</code> string; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a1289f625345da33e26854f44078002a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newConcatUtf16L </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>rightLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string that is the concatenation of two other strings. </p>
<p>The new string does not necessarily have a reference count of 1 (in cases where the UTF-16 string is empty), so it must not be modified without checking the reference count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newString</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">left</td><td>a valid string.</td></tr>
    <tr><td class="paramname">right</td><td>must not be null and must point to memory of at least <code>rightLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramname">rightLength</td><td>the length of the <code>right</code> string; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a698d695d33e8c3b80599a44b09a7ad8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromAscii </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string that contains a copy of a character array. </p>
<p>If the length of value is greater than zero, the reference count of the new string will be 1. This function does not handle out-of-memory conditions.</p>
<p>Since this function is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range of 0 and 127, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">value</td><td>a null-terminated ASCII character array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac753429f7da0416c0a29ecbe63b756d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromCodePoints </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32 const *&#160;</td>
          <td class="paramname"><em>codePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>codePointCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string from an array of Unicode code points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newString</td><td>a non-null pointer to a (possibly null) rtl_uString pointer, which (if non-null) will have been passed to rtl_uString_release before the function returns. Upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32. The newly allocated string (if any) must ultimately be passed to rtl_uString_release.</td></tr>
    <tr><td class="paramname">codePoints</td><td>an array of at least codePointCount code points, which each must be in the range from 0 to 0x10FFFF, inclusive. May be null if codePointCount is zero.</td></tr>
    <tr><td class="paramname">codePointCount</td><td>the non-negative number of code points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a596bbcc30e556a1c0969e96d9e834c99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromLiteral </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>allocExtra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3a0d8de21ece4f030e123bed6aa44df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromStr </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string that contains a copy of a character array. </p>
<p>If the length of value is greater than zero, the reference count of the new string will be 1. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">value</td><td>a null-terminated character array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25e35be84e03bf412874c4f43bd98d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromStr_WithLength </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string that contains a copy of a character array. </p>
<p>If the length of value is greater than zero, the reference count of the new string will be 1. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">value</td><td>a character array. Need not be null-terminated, but must be at least as long as the specified len.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the character array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a185ef0c772f824f9363056211720fb33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromString </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rtl_uString *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string that contains a copy of another string. </p>
<p>If the length of value is greater than zero, the reference count of the new string will be 1. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">value</td><td>a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af739b126596d8eb926507f7b52c2f36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newFromSubString </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rtl_uString *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string that is a substring of this string. </p>
<p>The substring begins at the specified beginIndex and contains count characters. Meaningless combinations such as negative beginIndex, or beginIndex + count greater than the length of the string have undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newStr</td><td>the specified substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>the String to take the substring from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beginIndex</td><td>the beginning index, inclusive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified substring.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adbc1b67ad568114a7bdbe59f0e299946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplace </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>oldChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>newChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a single character within another string. </p>
<p>The new string results from replacing all occurrences of oldChar in str with newChar.</p>
<p>The new string does not necessarily have a reference count of 1 (in cases where oldChar does not occur in str), so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">str</td><td>a valid string.</td></tr>
    <tr><td class="paramname">oldChar</td><td>the old character.</td></tr>
    <tr><td class="paramname">newChar</td><td>the new character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d4e20157b49fa991047a38a8cbbe446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAll </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a12d739cbd054b979a917cebb5de27c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ac5b2692a87d792af863ccde2c5d11d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllAsciiLAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a2debad53dda7bfd54d8b0c858fc2f7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllAsciiLUtf16L </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString; upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a178c44bdb6fea4f9fb84a53ef27db8f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllFromIndex </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromIndex</td><td>the position in the string where we will begin searching</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7423b694a2b1074fc7dadcca9a8695f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllToAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null and must point to memory of at least <code>toLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a9be43fe10f0dcee0f05ad3465d813f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllUtf16LAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString; upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aa78daa0f7df4977993da9160ea4cb3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceAllUtf16LUtf16L </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString; upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae61c10a779f20722ac0db621a2b882c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirst </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a95d68242f6bbee9a50c4bc917d9926ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirstAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3cc70e2657710ed6eb6715de14a874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirstAsciiLAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="aea89ae4b2ff78611a7265c99e8c41219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirstAsciiLUtf16L </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString; upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place (or would have taken place if <code>newStr</code> points to null upon return) or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a3be44996009c3742c4b7dbb92545580e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirstToAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the replacing substring; must not be null and must point to memory of at least <code>toLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a39fcaccc51e8573115cbcbe2db5d9ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirstUtf16LAsciiL </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString; upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> ASCII bytes</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place (or would have taken place if <code>newStr</code> points to null upon return) or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a05aa785ee3a32f3db21471f922fd011b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceFirstUtf16LUtf16L </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> const *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>toLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newStr</td><td>pointer to the new string; must not be null; must point to null or a valid rtl_uString; upon return, points to the newly allocated string or to null if there was either an out-of-memory condition or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>pointer to the original string; must not be null</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>fromLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fromLength</td><td>the length of the <code>from</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>pointer to the substring to be replaced; must not be null and must point to memory of at least <code>toLength</code> UTF-16 code units</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">toLength</td><td>the length of the <code>to</code> substring; must be non-negative</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index, must not be null; upon entry to the function its value is the index into the original string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than the original string's length; upon exit from the function its value is the index into the original string at which the replacement took place (or would have taken place if <code>newStr</code> points to null upon return) or -1 if no replacement took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a6df7b0b9ce2361af1dca7d160150a1b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newReplaceStrAt </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>subStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by replacing a substring of another string. </p>
<p>The new string results from replacing a number of characters (count), starting at the specified position (index) in the original string (str), with some new substring (subStr). If subStr is null, than only a number of characters is deleted.</p>
<p>The new string does not necessarily have a reference count of 1, so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">str</td><td>a valid string.</td></tr>
    <tr><td class="paramname">idx</td><td>the index into str at which to start replacement. Must be between 0 and the length of str, inclusive.</td></tr>
    <tr><td class="paramname">count</td><td>the number of characters to remove. Must not be negative, and the sum of index and count must not exceed the length of str.</td></tr>
    <tr><td class="paramname">subStr</td><td>either null or a valid string to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79aba45c11b88b87e05c68d197e759cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newToAsciiLowerCase </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by converting all ASCII uppercase letters to lowercase within another string. </p>
<p>The new string results from replacing all characters with values between 65 and 90 (ASCII A&ndash;Z) by values between 97 and 122 (ASCII a&ndash;z).</p>
<p>This function cannot be used for language-specific conversion. The new string does not necessarily have a reference count of 1 (in cases where no characters need to be converted), so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">str</td><td>a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb8c19aada6fef8cd6bc683ccff5faed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newToAsciiUpperCase </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by converting all ASCII lowercase letters to uppercase within another string. </p>
<p>The new string results from replacing all characters with values between 97 and 122 (ASCII a&ndash;z) by values between 65 and 90 (ASCII A&ndash;Z).</p>
<p>This function cannot be used for language-specific conversion. The new string does not necessarily have a reference count of 1 (in cases where no characters need to be converted), so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">str</td><td>a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0f72ce7c64f77e68599001bb9c884ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_newTrim </td>
          <td>(</td>
          <td class="paramtype">rtl_uString **&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new string by removing white space from both ends of another string. </p>
<p>The new string results from removing all characters with values less than or equal to 32 (the space character), and also Unicode General Punctuation area Space and some Control characters, form both ends of str (see rtl_ImplIsWhitespace).</p>
<p>This function cannot be used for language-specific conversion. The new string does not necessarily have a reference count of 1 (in cases where no characters need to be removed), so it must not be modified without checking the reference count. This function does not handle out-of-memory conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newStr</td><td>pointer to the new string. The pointed-to data must be null or a valid string.</td></tr>
    <tr><td class="paramname">str</td><td>a valid string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8571974c63423cb183047a33a72f0d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00408.html#aca1813580da4b82e3a00f8f85570b480">SAL_DLLPUBLIC</a> void rtl_uString_release </td>
          <td>(</td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the reference count of a string. </p>
<p>If the count goes to zero than the string data is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>

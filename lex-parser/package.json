{
  "author": {
    "name": "Zach Carter",
    "email": "zach@carter.name",
    "url": "http://zaa.ch"
  },
  "name": "lex-parser",
  "version": "0.1.4",
  "description": "A parser for lexical grammars used by jison",
  "main": "lex-parser.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "repository": "https://github.com/zaach/lex-parser.git"
  },
  "keywords": [
    "lexical",
    "grammar",
    "parser",
    "jison"
  ],
  "license": "MIT",
  "devDependencies": {
    "jison": "git://github.com/GerHobbelt/jison.git#master",
    "test": ">=0.6.0"
  },
  "readme": "# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require(\"lex-parser\");\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME                                    [a-zA-Z_][a-zA-Z0-9_-]*\n    BR                                      \\r\\n|\\n|\\r\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>\"/*\"(.|\\n|\\r)*?\"*/\"             return 'ACTION_BODY';\n    <action>\"//\".*                          return 'ACTION_BODY';\n    <action>\"/\"[^ /]*?['\"{}'][^ ]*?\"/\"      return 'ACTION_BODY'; // regexp with braces or quotes (and no spaces)\n    <action>\\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         return 'ACTION_BODY';\n    <action>\"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       return 'ACTION_BODY';\n    <action>[/\"'][^{}/\"']+                  return 'ACTION_BODY';\n    <action>[^{}/\"']+                       return 'ACTION_BODY';\n    <action>\"{\"                             yy.depth++; return '{';\n    <action>\"}\"                             if (yy.depth == 0) { this.begin('trail'); } else { yy.depth--; } return '}';\n\n    <conditions>{NAME}                      return 'NAME';\n    <conditions>\">\"                         this.popState(); return '>';\n    <conditions>\",\"                         return ',';\n    <conditions>\"*\"                         return '*';\n\n    <rules>{BR}+                            /* empty */\n    <rules>\\s+{BR}+                         /* empty */\n    <rules>\\s+                              this.begin('indented');\n    <rules>\"%%\"                             this.begin('code'); return '%%';\n    <rules>[a-zA-Z0-9_]+                    return 'CHARACTER_LIT';\n\n    <options>{NAME}                         yy.options[yytext] = true;\n    <options>{BR}+                          this.begin('INITIAL');\n    <options>\\s+{BR}+                       this.begin('INITIAL');\n    <options>\\s+                            /* empty */\n\n    <start_condition>{NAME}                 return 'START_COND';\n    <start_condition>{BR}+                  this.begin('INITIAL');\n    <start_condition>\\s+{BR}+               this.begin('INITIAL');\n    <start_condition>\\s+                    /* empty */\n\n    <trail>\\s*{BR}+                         this.begin('rules');\n\n    <indented>\"{\"                           yy.depth = 0; this.begin('action'); return '{';\n    <indented>\"%{\"(.|{BR})*?\"%}\"            this.begin('trail'); yytext = yytext.substr(2, yytext.length - 4); return 'ACTION';\n    \"%{\"(.|{BR})*?\"%}\"                      yytext = yytext.substr(2, yytext.length - 4); return 'ACTION';\n    <indented>.+                            this.begin('rules'); return 'ACTION';\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"                     /* empty */\n    \"//\".*                                  /* empty */\n\n    {BR}+                                   /* ignore */\n    \\s+                                     /* ignore */\n    {NAME}                                  return 'NAME';\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"                 yytext = yytext.replace(/\\\\\"/g,'\"'); return 'STRING_LIT';\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"               yytext = yytext.replace(/\\\\'/g,\"'\"); return 'STRING_LIT';\n    \"|\"                                     return '|';\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"              return 'ANY_GROUP_REGEX';\n    \"(?:\"                                   return 'SPECIAL_GROUP';\n    \"(?=\"                                   return 'SPECIAL_GROUP';\n    \"(?!\"                                   return 'SPECIAL_GROUP';\n    \"(\"                                     return '(';\n    \")\"                                     return ')';\n    \"+\"                                     return '+';\n    \"*\"                                     return '*';\n    \"?\"                                     return '?';\n    \"^\"                                     return '^';\n    \",\"                                     return ',';\n    \"<<EOF>>\"                               return '$';\n    \"<\"                                     this.begin('conditions'); return '<';\n    \"/!\"                                    return '/!';\n    \"/\"                                     return '/';\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4})\n                                            return 'ESCAPE_CHAR';\n    \"\\\\\".                                   yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR';\n    \"$\"                                     return '$';\n    \".\"                                     return '.';\n    \"%options\"                              yy.options = {}; this.begin('options');\n    \"%s\"                                    this.begin('start_condition'); return 'START_INC';\n    \"%x\"                                    this.begin('start_condition'); return 'START_EXC';\n    \"%%\"                                    this.begin('rules'); return '%%';\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"               return 'RANGE_REGEX';\n    \"{\"{NAME}\"}\"                            return 'NAME_BRACE';\n    \"{\"                                     return '{';\n    \"}\"                                     return '}';\n    .                                       throw new Error(\"unsupported input character: \" + yytext); /* b0rk on bad characters */\n    <*><<EOF>>                              return 'EOF';\n\n    <code>(.|{BR})+                         return 'CODE';\n\n    %%\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "lex-parser@0.1.4",
  "_shasum": "af8d3f060958bd55fcb79d7727cc965cd4de5265",
  "_resolved": "git://github.com/GerHobbelt/lex-parser.git#6156e8974f3acb9160805e7ec6e7dd671c34cd61",
  "_from": "lex-parser@"
}

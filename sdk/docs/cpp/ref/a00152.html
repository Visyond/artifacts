<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>LibreOffice: rtl::OUString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibreOffice
   </div>
   <div id="projectbrief">LibreOffice 6.3 SDK C/C++ API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00454.html">rtl</a></li><li class="navelem"><a class="el" href="a00152.html">OUString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00692.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rtl::OUString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This String class provides base functionality for C++ like Unicode character array handling.  
 <a href="a00152.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00399_source.html">ustring.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad41465279b4288eafc7fc8dabd57de0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aad41465279b4288eafc7fc8dabd57de0">OUString</a> ()</td></tr>
<tr class="memdesc:aad41465279b4288eafc7fc8dabd57de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string containing no characters.  <a href="#aad41465279b4288eafc7fc8dabd57de0">More...</a><br/></td></tr>
<tr class="separator:aad41465279b4288eafc7fc8dabd57de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efa62551cf5aa0006edb4e72f106b23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a1efa62551cf5aa0006edb4e72f106b23">OUString</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str)</td></tr>
<tr class="memdesc:a1efa62551cf5aa0006edb4e72f106b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>.  <a href="#a1efa62551cf5aa0006edb4e72f106b23">More...</a><br/></td></tr>
<tr class="separator:a1efa62551cf5aa0006edb4e72f106b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679d95859f010dbfd55f67cf4fa7c6eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a679d95859f010dbfd55f67cf4fa7c6eb">OUString</a> (rtl_uString *str)</td></tr>
<tr class="memdesc:a679d95859f010dbfd55f67cf4fa7c6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> data.  <a href="#a679d95859f010dbfd55f67cf4fa7c6eb">More...</a><br/></td></tr>
<tr class="separator:a679d95859f010dbfd55f67cf4fa7c6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64d1f21c5034f621c09e9ac17edab4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ad64d1f21c5034f621c09e9ac17edab4e">OUString</a> (rtl_uString *str, <a class="el" href="a00409.html#a30b3dd1d6058d15544996570e4f14244">__sal_NoAcquire</a>)</td></tr>
<tr class="memdesc:ad64d1f21c5034f621c09e9ac17edab4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">New <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> from <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> data without acquiring it.  <a href="#ad64d1f21c5034f621c09e9ac17edab4e">More...</a><br/></td></tr>
<tr class="separator:ad64d1f21c5034f621c09e9ac17edab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8883463669217f97450c21594965ef5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a8883463669217f97450c21594965ef5c">OUString</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> value)</td></tr>
<tr class="memdesc:a8883463669217f97450c21594965ef5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a single Unicode character.  <a href="#a8883463669217f97450c21594965ef5c">More...</a><br/></td></tr>
<tr class="separator:a8883463669217f97450c21594965ef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9d0605b97b12f86744604b1ed6c38a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aae9d0605b97b12f86744604b1ed6c38a">OUString</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *value)</td></tr>
<tr class="memdesc:aae9d0605b97b12f86744604b1ed6c38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a Unicode character buffer array.  <a href="#aae9d0605b97b12f86744604b1ed6c38a">More...</a><br/></td></tr>
<tr class="separator:aae9d0605b97b12f86744604b1ed6c38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69baba4d68131d28e548d2cfdc7781ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a69baba4d68131d28e548d2cfdc7781ed">OUString</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *value, sal_Int32 length)</td></tr>
<tr class="memdesc:a69baba4d68131d28e548d2cfdc7781ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from a Unicode character buffer array.  <a href="#a69baba4d68131d28e548d2cfdc7781ed">More...</a><br/></td></tr>
<tr class="separator:a69baba4d68131d28e548d2cfdc7781ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c87c2e0fdc256d57248d7ef4d6ec05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8c87c2e0fdc256d57248d7ef4d6ec05"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#ad8c87c2e0fdc256d57248d7ef4d6ec05">assert</a> (<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T &gt;::isValid(literal))</td></tr>
<tr class="memdesc:ad8c87c2e0fdc256d57248d7ef4d6ec05"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from an 8-Bit string literal that is expected to contain only characters in the ASCII set (i.e.  <a href="#ad8c87c2e0fdc256d57248d7ef4d6ec05">More...</a><br/></td></tr>
<tr class="separator:ad8c87c2e0fdc256d57248d7ef4d6ec05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6c0b2e5c8910252c9ac37d6dec1b67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4e6c0b2e5c8910252c9ac37d6dec1b67">if</a> (<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T &gt;::length==0)</td></tr>
<tr class="separator:a4e6c0b2e5c8910252c9ac37d6dec1b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b17d4b5f7a99ec88956daa1e429cc39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a7b17d4b5f7a99ec88956daa1e429cc39">OUString</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value, sal_Int32 length, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> encoding, sal_uInt32 convertFlags=<a class="el" href="a00398.html#a0d72f032eb9370c7403fccb71c4e6906">OSTRING_TO_OUSTRING_CVTFLAGS</a>)</td></tr>
<tr class="memdesc:a7b17d4b5f7a99ec88956daa1e429cc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">New string from an 8-Bit character buffer array.  <a href="#a7b17d4b5f7a99ec88956daa1e429cc39">More...</a><br/></td></tr>
<tr class="separator:a7b17d4b5f7a99ec88956daa1e429cc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec113d5a8b3946066bf468181f016b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#abbec113d5a8b3946066bf468181f016b">OUString</a> (sal_uInt32 const *codePoints, sal_Int32 codePointCount)</td></tr>
<tr class="memdesc:abbec113d5a8b3946066bf468181f016b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string from an array of Unicode code points.  <a href="#abbec113d5a8b3946066bf468181f016b">More...</a><br/></td></tr>
<tr class="separator:abbec113d5a8b3946066bf468181f016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7f0154687eba2c4aa129d806d56153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a2c7f0154687eba2c4aa129d806d56153">~OUString</a> ()</td></tr>
<tr class="memdesc:a2c7f0154687eba2c4aa129d806d56153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the string data.  <a href="#a2c7f0154687eba2c4aa129d806d56153">More...</a><br/></td></tr>
<tr class="separator:a2c7f0154687eba2c4aa129d806d56153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646f44367e4dcaec4c61a97ccbb05496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00152.html">OUString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a646f44367e4dcaec4c61a97ccbb05496">operator=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str)</td></tr>
<tr class="memdesc:a646f44367e4dcaec4c61a97ccbb05496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new string.  <a href="#a646f44367e4dcaec4c61a97ccbb05496">More...</a><br/></td></tr>
<tr class="separator:a646f44367e4dcaec4c61a97ccbb05496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6a3d60e5b579b4331333c139124f11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c6a3d60e5b579b4331333c139124f11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00152.html">OUString</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a3c6a3d60e5b579b4331333c139124f11">operator=</a> (T &amp;literal)</td></tr>
<tr class="memdesc:a3c6a3d60e5b579b4331333c139124f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new string from an 8-Bit string literal that is expected to contain only characters in the ASCII set (i.e.  <a href="#a3c6a3d60e5b579b4331333c139124f11">More...</a><br/></td></tr>
<tr class="separator:a3c6a3d60e5b579b4331333c139124f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a64ff242678d23a37be69ab8b440d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00152.html">OUString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a59a64ff242678d23a37be69ab8b440d4">operator+=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str)</td></tr>
<tr class="memdesc:a59a64ff242678d23a37be69ab8b440d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string to this string.  <a href="#a59a64ff242678d23a37be69ab8b440d4">More...</a><br/></td></tr>
<tr class="separator:a59a64ff242678d23a37be69ab8b440d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55194132016e1d5af3e0ff7a3e5780b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac55194132016e1d5af3e0ff7a3e5780b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00152.html">OUString</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#ac55194132016e1d5af3e0ff7a3e5780b">operator+=</a> (T &amp;literal)</td></tr>
<tr class="memdesc:ac55194132016e1d5af3e0ff7a3e5780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an ASCII string literal to this string.  <a href="#ac55194132016e1d5af3e0ff7a3e5780b">More...</a><br/></td></tr>
<tr class="separator:ac55194132016e1d5af3e0ff7a3e5780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21de4053f388ca64d8a4593dfe55e6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a21de4053f388ca64d8a4593dfe55e6c6">clear</a> ()</td></tr>
<tr class="memdesc:a21de4053f388ca64d8a4593dfe55e6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the string, i.e, makes a zero-character string.  <a href="#a21de4053f388ca64d8a4593dfe55e6c6">More...</a><br/></td></tr>
<tr class="separator:a21de4053f388ca64d8a4593dfe55e6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc7bef14bae146d14f7cce8fa255f4b"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4fc7bef14bae146d14f7cce8fa255f4b">getLength</a> () const </td></tr>
<tr class="memdesc:a4fc7bef14bae146d14f7cce8fa255f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of this string.  <a href="#a4fc7bef14bae146d14f7cce8fa255f4b">More...</a><br/></td></tr>
<tr class="separator:a4fc7bef14bae146d14f7cce8fa255f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddb81f83357238c9851da6899162ae8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#adddb81f83357238c9851da6899162ae8">isEmpty</a> () const </td></tr>
<tr class="memdesc:adddb81f83357238c9851da6899162ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a string is empty.  <a href="#adddb81f83357238c9851da6899162ae8">More...</a><br/></td></tr>
<tr class="separator:adddb81f83357238c9851da6899162ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53de57545f204606a0051d041c0320ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a53de57545f204606a0051d041c0320ab">getStr</a> () const SAL_RETURNS_NONNULL</td></tr>
<tr class="memdesc:a53de57545f204606a0051d041c0320ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Unicode character buffer for this string.  <a href="#a53de57545f204606a0051d041c0320ab">More...</a><br/></td></tr>
<tr class="separator:a53de57545f204606a0051d041c0320ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ec0ee3e0a23edb55d09484e3a1776e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ad7ec0ee3e0a23edb55d09484e3a1776e">operator[]</a> (sal_Int32 index) const </td></tr>
<tr class="memdesc:ad7ec0ee3e0a23edb55d09484e3a1776e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to individual characters.  <a href="#ad7ec0ee3e0a23edb55d09484e3a1776e">More...</a><br/></td></tr>
<tr class="separator:ad7ec0ee3e0a23edb55d09484e3a1776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc28ab1a9cac061dfa363d234c15da2e"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#abc28ab1a9cac061dfa363d234c15da2e">compareTo</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:abc28ab1a9cac061dfa363d234c15da2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings.  <a href="#abc28ab1a9cac061dfa363d234c15da2e">More...</a><br/></td></tr>
<tr class="separator:abc28ab1a9cac061dfa363d234c15da2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b3136b7be9a294ba3855b533b587f8"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a27b3136b7be9a294ba3855b533b587f8">compareTo</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str, sal_Int32 maxLength) const </td></tr>
<tr class="memdesc:a27b3136b7be9a294ba3855b533b587f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings with a maximum count of characters.  <a href="#a27b3136b7be9a294ba3855b533b587f8">More...</a><br/></td></tr>
<tr class="separator:a27b3136b7be9a294ba3855b533b587f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c91bb6aed6ebf4e190d82465aa4902"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a75c91bb6aed6ebf4e190d82465aa4902">reverseCompareTo</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:a75c91bb6aed6ebf4e190d82465aa4902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings in reverse order.  <a href="#a75c91bb6aed6ebf4e190d82465aa4902">More...</a><br/></td></tr>
<tr class="separator:a75c91bb6aed6ebf4e190d82465aa4902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5814c0210e60d3a2d3f1bf4705febd38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5814c0210e60d3a2d3f1bf4705febd38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, sal_Int32 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a5814c0210e60d3a2d3f1bf4705febd38">reverseCompareTo</a> (T &amp;literal) const </td></tr>
<tr class="memdesc:a5814c0210e60d3a2d3f1bf4705febd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a5814c0210e60d3a2d3f1bf4705febd38">More...</a><br/></td></tr>
<tr class="separator:a5814c0210e60d3a2d3f1bf4705febd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27eea6349e6ef35c4256526508594bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ab27eea6349e6ef35c4256526508594bb">equals</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:ab27eea6349e6ef35c4256526508594bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a comparison of two strings.  <a href="#ab27eea6349e6ef35c4256526508594bb">More...</a><br/></td></tr>
<tr class="separator:ab27eea6349e6ef35c4256526508594bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3c60117ab0f8184a2adcacee3d9d30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a1f3c60117ab0f8184a2adcacee3d9d30">equalsIgnoreAsciiCase</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:a1f3c60117ab0f8184a2adcacee3d9d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ASCII lowercase comparison of two strings.  <a href="#a1f3c60117ab0f8184a2adcacee3d9d30">More...</a><br/></td></tr>
<tr class="separator:a1f3c60117ab0f8184a2adcacee3d9d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa2e3cd47fdb3ec12242d0a163fba1b"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a6aa2e3cd47fdb3ec12242d0a163fba1b">compareToIgnoreAsciiCase</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:a6aa2e3cd47fdb3ec12242d0a163fba1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ASCII lowercase comparison of two strings.  <a href="#a6aa2e3cd47fdb3ec12242d0a163fba1b">More...</a><br/></td></tr>
<tr class="separator:a6aa2e3cd47fdb3ec12242d0a163fba1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1a43697ee00de08462b1f824bd7604"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a1a43697ee00de08462b1f824bd7604"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a4a1a43697ee00de08462b1f824bd7604">equalsIgnoreAsciiCase</a> (T &amp;literal) const </td></tr>
<tr class="memdesc:a4a1a43697ee00de08462b1f824bd7604"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a4a1a43697ee00de08462b1f824bd7604">More...</a><br/></td></tr>
<tr class="separator:a4a1a43697ee00de08462b1f824bd7604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eeb6113c5eee94b85dc05aeb302902"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ab6eeb6113c5eee94b85dc05aeb302902">match</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ab6eeb6113c5eee94b85dc05aeb302902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string.  <a href="#ab6eeb6113c5eee94b85dc05aeb302902">More...</a><br/></td></tr>
<tr class="separator:ab6eeb6113c5eee94b85dc05aeb302902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ecbf29b4bd62768c687a349ae8ef64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7ecbf29b4bd62768c687a349ae8ef64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#ae7ecbf29b4bd62768c687a349ae8ef64">match</a> (T &amp;literal, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ae7ecbf29b4bd62768c687a349ae8ef64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#ae7ecbf29b4bd62768c687a349ae8ef64">More...</a><br/></td></tr>
<tr class="separator:ae7ecbf29b4bd62768c687a349ae8ef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2fd3cae44cc8882107965dc8aeccd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a0e2fd3cae44cc8882107965dc8aeccd9">matchIgnoreAsciiCase</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a0e2fd3cae44cc8882107965dc8aeccd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string, ignoring the case of ASCII letters.  <a href="#a0e2fd3cae44cc8882107965dc8aeccd9">More...</a><br/></td></tr>
<tr class="separator:a0e2fd3cae44cc8882107965dc8aeccd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c970c1b2425b787f4cc89eacc3530f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04c970c1b2425b787f4cc89eacc3530f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a04c970c1b2425b787f4cc89eacc3530f">matchIgnoreAsciiCase</a> (T &amp;literal, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a04c970c1b2425b787f4cc89eacc3530f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a04c970c1b2425b787f4cc89eacc3530f">More...</a><br/></td></tr>
<tr class="separator:a04c970c1b2425b787f4cc89eacc3530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163ade83cc1019cfee6254257285660e"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a163ade83cc1019cfee6254257285660e">compareToAscii</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr) const </td></tr>
<tr class="memdesc:a163ade83cc1019cfee6254257285660e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings.  <a href="#a163ade83cc1019cfee6254257285660e">More...</a><br/></td></tr>
<tr class="separator:a163ade83cc1019cfee6254257285660e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfcb304b92de1e40b5e16c60d10a9ea"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a5cfcb304b92de1e40b5e16c60d10a9ea">compareToAscii</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 maxLength) const </td></tr>
<tr class="memdesc:a5cfcb304b92de1e40b5e16c60d10a9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings with a maximum count of characters.  <a href="#a5cfcb304b92de1e40b5e16c60d10a9ea">More...</a><br/></td></tr>
<tr class="separator:a5cfcb304b92de1e40b5e16c60d10a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64385b39b87e6404c345e253dfbdad8b"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a64385b39b87e6404c345e253dfbdad8b">reverseCompareToAsciiL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 asciiStrLength) const </td></tr>
<tr class="memdesc:a64385b39b87e6404c345e253dfbdad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings in reverse order.  <a href="#a64385b39b87e6404c345e253dfbdad8b">More...</a><br/></td></tr>
<tr class="separator:a64385b39b87e6404c345e253dfbdad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623b6908f7de9f883e2bb83167af403"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ad623b6908f7de9f883e2bb83167af403">equalsAscii</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr) const </td></tr>
<tr class="memdesc:ad623b6908f7de9f883e2bb83167af403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a comparison of two strings.  <a href="#ad623b6908f7de9f883e2bb83167af403">More...</a><br/></td></tr>
<tr class="separator:ad623b6908f7de9f883e2bb83167af403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5cbe884bf53830cd52a6c79784deac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a0b5cbe884bf53830cd52a6c79784deac">equalsAsciiL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 asciiStrLength) const </td></tr>
<tr class="memdesc:a0b5cbe884bf53830cd52a6c79784deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a comparison of two strings.  <a href="#a0b5cbe884bf53830cd52a6c79784deac">More...</a><br/></td></tr>
<tr class="separator:a0b5cbe884bf53830cd52a6c79784deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7e3dacb52676ffaaced8c747fde6b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ace7e3dacb52676ffaaced8c747fde6b0">equalsIgnoreAsciiCaseAscii</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr) const </td></tr>
<tr class="memdesc:ace7e3dacb52676ffaaced8c747fde6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a ASCII lowercase comparison of two strings.  <a href="#ace7e3dacb52676ffaaced8c747fde6b0">More...</a><br/></td></tr>
<tr class="separator:ace7e3dacb52676ffaaced8c747fde6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e653c7014be68a00cef5d64004d8a7"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a65e653c7014be68a00cef5d64004d8a7">compareToIgnoreAsciiCaseAscii</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr) const </td></tr>
<tr class="memdesc:a65e653c7014be68a00cef5d64004d8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ASCII strings ignoring case.  <a href="#a65e653c7014be68a00cef5d64004d8a7">More...</a><br/></td></tr>
<tr class="separator:a65e653c7014be68a00cef5d64004d8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe30143b47aa0960921a72eb2ff862c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#abe30143b47aa0960921a72eb2ff862c9">equalsIgnoreAsciiCaseAsciiL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 asciiStrLength) const </td></tr>
<tr class="memdesc:abe30143b47aa0960921a72eb2ff862c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an ASCII lowercase comparison of two strings.  <a href="#abe30143b47aa0960921a72eb2ff862c9">More...</a><br/></td></tr>
<tr class="separator:abe30143b47aa0960921a72eb2ff862c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979d86657541fa568f65e4ac18230171"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a979d86657541fa568f65e4ac18230171">matchAsciiL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 asciiStrLength, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a979d86657541fa568f65e4ac18230171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string.  <a href="#a979d86657541fa568f65e4ac18230171">More...</a><br/></td></tr>
<tr class="separator:a979d86657541fa568f65e4ac18230171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d944b80903e31fc042e026c9ddd0ba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a6d944b80903e31fc042e026c9ddd0ba9">matchIgnoreAsciiCaseAsciiL</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *asciiStr, sal_Int32 asciiStrLength, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a6d944b80903e31fc042e026c9ddd0ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match against a substring appearing in this string, ignoring the case of ASCII letters.  <a href="#a6d944b80903e31fc042e026c9ddd0ba9">More...</a><br/></td></tr>
<tr class="separator:a6d944b80903e31fc042e026c9ddd0ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fcae3e2c911e180906b248b325894e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a86fcae3e2c911e180906b248b325894e">startsWith</a> (<a class="el" href="a00152.html">OUString</a> const &amp;str, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a86fcae3e2c911e180906b248b325894e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string starts with a given substring.  <a href="#a86fcae3e2c911e180906b248b325894e">More...</a><br/></td></tr>
<tr class="separator:a86fcae3e2c911e180906b248b325894e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9091aa2c4311d8b71cbe1f286c67593a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9091aa2c4311d8b71cbe1f286c67593a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a9091aa2c4311d8b71cbe1f286c67593a">startsWith</a> (T &amp;literal, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a9091aa2c4311d8b71cbe1f286c67593a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a9091aa2c4311d8b71cbe1f286c67593a">More...</a><br/></td></tr>
<tr class="separator:a9091aa2c4311d8b71cbe1f286c67593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef11e4a288bacd470d9e729936f66256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aef11e4a288bacd470d9e729936f66256">startsWithIgnoreAsciiCase</a> (<a class="el" href="a00152.html">OUString</a> const &amp;str, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:aef11e4a288bacd470d9e729936f66256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string starts with a given string, ignoring the case of ASCII letters.  <a href="#aef11e4a288bacd470d9e729936f66256">More...</a><br/></td></tr>
<tr class="separator:aef11e4a288bacd470d9e729936f66256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af732b2eb7012558ad411fe5754048ad7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af732b2eb7012558ad411fe5754048ad7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#af732b2eb7012558ad411fe5754048ad7">startsWithIgnoreAsciiCase</a> (T &amp;literal, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:af732b2eb7012558ad411fe5754048ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#af732b2eb7012558ad411fe5754048ad7">More...</a><br/></td></tr>
<tr class="separator:af732b2eb7012558ad411fe5754048ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb53f713b1997e0b81eb6684406fa5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a5bb53f713b1997e0b81eb6684406fa5a">endsWith</a> (<a class="el" href="a00152.html">OUString</a> const &amp;str, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a5bb53f713b1997e0b81eb6684406fa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string ends with a given substring.  <a href="#a5bb53f713b1997e0b81eb6684406fa5a">More...</a><br/></td></tr>
<tr class="separator:a5bb53f713b1997e0b81eb6684406fa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c22a7c03154f9aa048ccf5fd632adc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65c22a7c03154f9aa048ccf5fd632adc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a65c22a7c03154f9aa048ccf5fd632adc">endsWith</a> (T &amp;literal, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a65c22a7c03154f9aa048ccf5fd632adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a65c22a7c03154f9aa048ccf5fd632adc">More...</a><br/></td></tr>
<tr class="separator:a65c22a7c03154f9aa048ccf5fd632adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af610ee45069ceec1bd76e4ff0defa8b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#af610ee45069ceec1bd76e4ff0defa8b4">endsWithAsciiL</a> (char const *asciiStr, sal_Int32 asciiStrLength) const </td></tr>
<tr class="memdesc:af610ee45069ceec1bd76e4ff0defa8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string ends with a given ASCII string.  <a href="#af610ee45069ceec1bd76e4ff0defa8b4">More...</a><br/></td></tr>
<tr class="separator:af610ee45069ceec1bd76e4ff0defa8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017dd59e54e0f528e17ddecc09d4a0f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a017dd59e54e0f528e17ddecc09d4a0f8">endsWithIgnoreAsciiCase</a> (<a class="el" href="a00152.html">OUString</a> const &amp;str, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a017dd59e54e0f528e17ddecc09d4a0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string ends with a given string, ignoring the case of ASCII letters.  <a href="#a017dd59e54e0f528e17ddecc09d4a0f8">More...</a><br/></td></tr>
<tr class="separator:a017dd59e54e0f528e17ddecc09d4a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3399446a72c1df7a1c491c06ff1eb653"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3399446a72c1df7a1c491c06ff1eb653"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a3399446a72c1df7a1c491c06ff1eb653">endsWithIgnoreAsciiCase</a> (T &amp;literal, <a class="el" href="a00152.html">OUString</a> *rest=NULL) const </td></tr>
<tr class="memdesc:a3399446a72c1df7a1c491c06ff1eb653"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a3399446a72c1df7a1c491c06ff1eb653">More...</a><br/></td></tr>
<tr class="separator:a3399446a72c1df7a1c491c06ff1eb653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223e616876b07581ac2e287baa8eb9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ae223e616876b07581ac2e287baa8eb9e">endsWithIgnoreAsciiCaseAsciiL</a> (char const *asciiStr, sal_Int32 asciiStrLength) const </td></tr>
<tr class="memdesc:ae223e616876b07581ac2e287baa8eb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this string ends with a given ASCII string, ignoring the case of ASCII letters.  <a href="#ae223e616876b07581ac2e287baa8eb9e">More...</a><br/></td></tr>
<tr class="separator:ae223e616876b07581ac2e287baa8eb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689cedcbac350ee95ed428b54438a409"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a689cedcbac350ee95ed428b54438a409">hashCode</a> () const </td></tr>
<tr class="memdesc:a689cedcbac350ee95ed428b54438a409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hashcode for this string.  <a href="#a689cedcbac350ee95ed428b54438a409">More...</a><br/></td></tr>
<tr class="separator:a689cedcbac350ee95ed428b54438a409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8122412b6ec3cc2bb24f88ef29e8278"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ae8122412b6ec3cc2bb24f88ef29e8278">indexOf</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ae8122412b6ec3cc2bb24f88ef29e8278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.  <a href="#ae8122412b6ec3cc2bb24f88ef29e8278">More...</a><br/></td></tr>
<tr class="separator:ae8122412b6ec3cc2bb24f88ef29e8278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7183d4dcaa88adba27f4787ddc5050"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a3a7183d4dcaa88adba27f4787ddc5050">lastIndexOf</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch) const </td></tr>
<tr class="memdesc:a3a7183d4dcaa88adba27f4787ddc5050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified character, searching backward starting at the end.  <a href="#a3a7183d4dcaa88adba27f4787ddc5050">More...</a><br/></td></tr>
<tr class="separator:a3a7183d4dcaa88adba27f4787ddc5050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4415f8e6c4d0c72b70fb29e7e5e9c8"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a5d4415f8e6c4d0c72b70fb29e7e5e9c8">lastIndexOf</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> ch, sal_Int32 fromIndex) const </td></tr>
<tr class="memdesc:a5d4415f8e6c4d0c72b70fb29e7e5e9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified character, searching backward starting before the specified index.  <a href="#a5d4415f8e6c4d0c72b70fb29e7e5e9c8">More...</a><br/></td></tr>
<tr class="separator:a5d4415f8e6c4d0c72b70fb29e7e5e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add084235abab4069399f1d8ea0629d2e"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#add084235abab4069399f1d8ea0629d2e">indexOf</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:add084235abab4069399f1d8ea0629d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.  <a href="#add084235abab4069399f1d8ea0629d2e">More...</a><br/></td></tr>
<tr class="separator:add084235abab4069399f1d8ea0629d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e1bdb7ac2880711e6cddcb54891caa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9e1bdb7ac2880711e6cddcb54891caa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, sal_Int32 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#ab9e1bdb7ac2880711e6cddcb54891caa">indexOf</a> (T &amp;literal, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ab9e1bdb7ac2880711e6cddcb54891caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#ab9e1bdb7ac2880711e6cddcb54891caa">More...</a><br/></td></tr>
<tr class="separator:ab9e1bdb7ac2880711e6cddcb54891caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46ce79ed67437b4e65f59373b2410a5"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ac46ce79ed67437b4e65f59373b2410a5">indexOfAsciiL</a> (char const *str, sal_Int32 len, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:ac46ce79ed67437b4e65f59373b2410a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the first occurrence of the specified ASCII substring, starting at the specified index.  <a href="#ac46ce79ed67437b4e65f59373b2410a5">More...</a><br/></td></tr>
<tr class="separator:ac46ce79ed67437b4e65f59373b2410a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e113153776d2d17c3f740a0eb7996d8"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4e113153776d2d17c3f740a0eb7996d8">lastIndexOf</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:a4e113153776d2d17c3f740a0eb7996d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the end.  <a href="#a4e113153776d2d17c3f740a0eb7996d8">More...</a><br/></td></tr>
<tr class="separator:a4e113153776d2d17c3f740a0eb7996d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8a57bd4af7d5eac24b523db54d52e0"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a3e8a57bd4af7d5eac24b523db54d52e0">lastIndexOf</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str, sal_Int32 fromIndex) const </td></tr>
<tr class="memdesc:a3e8a57bd4af7d5eac24b523db54d52e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified substring, searching backward starting before the specified index.  <a href="#a3e8a57bd4af7d5eac24b523db54d52e0">More...</a><br/></td></tr>
<tr class="separator:a3e8a57bd4af7d5eac24b523db54d52e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e6965f4d2d57e6bafe21f384b9cf10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73e6965f4d2d57e6bafe21f384b9cf10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, sal_Int32 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a73e6965f4d2d57e6bafe21f384b9cf10">lastIndexOf</a> (T &amp;literal) const </td></tr>
<tr class="memdesc:a73e6965f4d2d57e6bafe21f384b9cf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument.  <a href="#a73e6965f4d2d57e6bafe21f384b9cf10">More...</a><br/></td></tr>
<tr class="separator:a73e6965f4d2d57e6bafe21f384b9cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1af1a0c6264542cd8342535e6c325af"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ae1af1a0c6264542cd8342535e6c325af">lastIndexOfAsciiL</a> (char const *str, sal_Int32 len) const </td></tr>
<tr class="memdesc:ae1af1a0c6264542cd8342535e6c325af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within this string of the last occurrence of the specified ASCII substring.  <a href="#ae1af1a0c6264542cd8342535e6c325af">More...</a><br/></td></tr>
<tr class="separator:ae1af1a0c6264542cd8342535e6c325af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d7ec71ec600374f21c3acc3ebca951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a33d7ec71ec600374f21c3acc3ebca951">copy</a> (sal_Int32 beginIndex) const </td></tr>
<tr class="memdesc:a33d7ec71ec600374f21c3acc3ebca951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string that is a substring of this string.  <a href="#a33d7ec71ec600374f21c3acc3ebca951">More...</a><br/></td></tr>
<tr class="separator:a33d7ec71ec600374f21c3acc3ebca951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873a517f1c80294a747de15b45763d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a873a517f1c80294a747de15b45763d9c">copy</a> (sal_Int32 beginIndex, sal_Int32 count) const </td></tr>
<tr class="memdesc:a873a517f1c80294a747de15b45763d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string that is a substring of this string.  <a href="#a873a517f1c80294a747de15b45763d9c">More...</a><br/></td></tr>
<tr class="separator:a873a517f1c80294a747de15b45763d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5b837993df8de8cb54a5c62b6518cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a2a5b837993df8de8cb54a5c62b6518cb">concat</a> (const <a class="el" href="a00152.html">OUString</a> &amp;str) const </td></tr>
<tr class="memdesc:a2a5b837993df8de8cb54a5c62b6518cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the specified string to the end of this string.  <a href="#a2a5b837993df8de8cb54a5c62b6518cb">More...</a><br/></td></tr>
<tr class="separator:a2a5b837993df8de8cb54a5c62b6518cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af773e476b52e8f511b3d5aab141cb2f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#af773e476b52e8f511b3d5aab141cb2f9">replaceAt</a> (sal_Int32 index, sal_Int32 count, const <a class="el" href="a00152.html">OUString</a> &amp;newStr) const </td></tr>
<tr class="memdesc:af773e476b52e8f511b3d5aab141cb2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing n = count characters from position index in this string with newStr.  <a href="#af773e476b52e8f511b3d5aab141cb2f9">More...</a><br/></td></tr>
<tr class="separator:af773e476b52e8f511b3d5aab141cb2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba49555be3571bf5349ff302bcd0d0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aba49555be3571bf5349ff302bcd0d0d3">replace</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> oldChar, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> newChar) const </td></tr>
<tr class="memdesc:aba49555be3571bf5349ff302bcd0d0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.  <a href="#aba49555be3571bf5349ff302bcd0d0d3">More...</a><br/></td></tr>
<tr class="separator:aba49555be3571bf5349ff302bcd0d0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88686c65ee3c3e9bb366dab9f30cf96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ae88686c65ee3c3e9bb366dab9f30cf96">replaceFirst</a> (<a class="el" href="a00152.html">OUString</a> const &amp;from, <a class="el" href="a00152.html">OUString</a> const &amp;to, sal_Int32 *index=NULL) const </td></tr>
<tr class="memdesc:ae88686c65ee3c3e9bb366dab9f30cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing the first occurrence of a given substring with another substring.  <a href="#ae88686c65ee3c3e9bb366dab9f30cf96">More...</a><br/></td></tr>
<tr class="separator:ae88686c65ee3c3e9bb366dab9f30cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b6dcadaef281238a8e7ff79ac8bff2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5b6dcadaef281238a8e7ff79ac8bff2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#af5b6dcadaef281238a8e7ff79ac8bff2">replaceFirst</a> (T &amp;from, <a class="el" href="a00152.html">OUString</a> const &amp;to, sal_Int32 *index=NULL) const </td></tr>
<tr class="memdesc:af5b6dcadaef281238a8e7ff79ac8bff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing the first occurrence of a given substring with another substring.  <a href="#af5b6dcadaef281238a8e7ff79ac8bff2">More...</a><br/></td></tr>
<tr class="separator:af5b6dcadaef281238a8e7ff79ac8bff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b550448bdfd9a59b263bba2cfabc7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2b550448bdfd9a59b263bba2cfabc7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#ae2b550448bdfd9a59b263bba2cfabc7c">replaceFirst</a> (<a class="el" href="a00152.html">OUString</a> const &amp;from, T &amp;to, sal_Int32 *index=NULL) const </td></tr>
<tr class="memdesc:ae2b550448bdfd9a59b263bba2cfabc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing the first occurrence of a given substring with another substring.  <a href="#ae2b550448bdfd9a59b263bba2cfabc7c">More...</a><br/></td></tr>
<tr class="separator:ae2b550448bdfd9a59b263bba2cfabc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c8f675283136798989e53e32baa5b4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a69c8f675283136798989e53e32baa5b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T1, typename <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T2, <a class="el" href="a00152.html">OUString</a> &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a69c8f675283136798989e53e32baa5b4">replaceFirst</a> (T1 &amp;from, T2 &amp;to, sal_Int32 *index=NULL) const </td></tr>
<tr class="memdesc:a69c8f675283136798989e53e32baa5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing the first occurrence of a given substring with another substring.  <a href="#a69c8f675283136798989e53e32baa5b4">More...</a><br/></td></tr>
<tr class="separator:a69c8f675283136798989e53e32baa5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d0a52dba52e692494ef822efa90e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a989d0a52dba52e692494ef822efa90e6">replaceAll</a> (<a class="el" href="a00152.html">OUString</a> const &amp;from, <a class="el" href="a00152.html">OUString</a> const &amp;to, sal_Int32 fromIndex=0) const </td></tr>
<tr class="memdesc:a989d0a52dba52e692494ef822efa90e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of a given substring with another substring.  <a href="#a989d0a52dba52e692494ef822efa90e6">More...</a><br/></td></tr>
<tr class="separator:a989d0a52dba52e692494ef822efa90e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb908e717e1ca0f942f95d473e4e0779"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb908e717e1ca0f942f95d473e4e0779"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#adb908e717e1ca0f942f95d473e4e0779">replaceAll</a> (T &amp;from, <a class="el" href="a00152.html">OUString</a> const &amp;to) const </td></tr>
<tr class="memdesc:adb908e717e1ca0f942f95d473e4e0779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of a given substring with another substring.  <a href="#adb908e717e1ca0f942f95d473e4e0779">More...</a><br/></td></tr>
<tr class="separator:adb908e717e1ca0f942f95d473e4e0779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5689081eb22cffa91855535df7d1fcab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5689081eb22cffa91855535df7d1fcab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a5689081eb22cffa91855535df7d1fcab">replaceAll</a> (<a class="el" href="a00152.html">OUString</a> const &amp;from, T &amp;to) const </td></tr>
<tr class="memdesc:a5689081eb22cffa91855535df7d1fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of a given substring with another substring.  <a href="#a5689081eb22cffa91855535df7d1fcab">More...</a><br/></td></tr>
<tr class="separator:a5689081eb22cffa91855535df7d1fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57686e4f21a791026faba87b07c5c3a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad57686e4f21a791026faba87b07c5c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T1, typename <br class="typebreak"/>
<a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T2, <a class="el" href="a00152.html">OUString</a> &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#ad57686e4f21a791026faba87b07c5c3a">replaceAll</a> (T1 &amp;from, T2 &amp;to) const </td></tr>
<tr class="memdesc:ad57686e4f21a791026faba87b07c5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from replacing all occurrences of a given substring with another substring.  <a href="#ad57686e4f21a791026faba87b07c5c3a">More...</a><br/></td></tr>
<tr class="separator:ad57686e4f21a791026faba87b07c5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed83f78d4affee3fc347a6fceab7f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a8ed83f78d4affee3fc347a6fceab7f03">toAsciiLowerCase</a> () const </td></tr>
<tr class="memdesc:a8ed83f78d4affee3fc347a6fceab7f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from this string all ASCII uppercase characters (65-90) to ASCII lowercase characters (97-122).  <a href="#a8ed83f78d4affee3fc347a6fceab7f03">More...</a><br/></td></tr>
<tr class="separator:a8ed83f78d4affee3fc347a6fceab7f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7e9a2117388362e604ca8d3aeab614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#adf7e9a2117388362e604ca8d3aeab614">toAsciiUpperCase</a> () const </td></tr>
<tr class="memdesc:adf7e9a2117388362e604ca8d3aeab614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from this string all ASCII lowercase characters (97-122) to ASCII uppercase characters (65-90).  <a href="#adf7e9a2117388362e604ca8d3aeab614">More...</a><br/></td></tr>
<tr class="separator:adf7e9a2117388362e604ca8d3aeab614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb0b67cc91b01250240f8d5a82c327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#adffb0b67cc91b01250240f8d5a82c327">trim</a> () const </td></tr>
<tr class="memdesc:adffb0b67cc91b01250240f8d5a82c327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new string resulting from removing white space from both ends of the string.  <a href="#adffb0b67cc91b01250240f8d5a82c327">More...</a><br/></td></tr>
<tr class="separator:adffb0b67cc91b01250240f8d5a82c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a49115d2964b545ccaf0e831eaf9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#af1a49115d2964b545ccaf0e831eaf9d3">getToken</a> (sal_Int32 token, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> cTok, sal_Int32 &amp;index) const </td></tr>
<tr class="memdesc:af1a49115d2964b545ccaf0e831eaf9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a token in the string.  <a href="#af1a49115d2964b545ccaf0e831eaf9d3">More...</a><br/></td></tr>
<tr class="separator:af1a49115d2964b545ccaf0e831eaf9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed31acdc601d8e74e9c45b5143f958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aaaed31acdc601d8e74e9c45b5143f958">getToken</a> (sal_Int32 count, <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> separator) const </td></tr>
<tr class="memdesc:aaaed31acdc601d8e74e9c45b5143f958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a token from the string.  <a href="#aaaed31acdc601d8e74e9c45b5143f958">More...</a><br/></td></tr>
<tr class="separator:aaaed31acdc601d8e74e9c45b5143f958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31add7c6d0cf43b0917f2be8c5dd9556"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a31add7c6d0cf43b0917f2be8c5dd9556">toBoolean</a> () const </td></tr>
<tr class="memdesc:a31add7c6d0cf43b0917f2be8c5dd9556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Boolean value from this string.  <a href="#a31add7c6d0cf43b0917f2be8c5dd9556">More...</a><br/></td></tr>
<tr class="separator:a31add7c6d0cf43b0917f2be8c5dd9556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbac6800b571ef6e4307e8d0be803f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4dbac6800b571ef6e4307e8d0be803f3">toChar</a> () const </td></tr>
<tr class="memdesc:a4dbac6800b571ef6e4307e8d0be803f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first character from this string.  <a href="#a4dbac6800b571ef6e4307e8d0be803f3">More...</a><br/></td></tr>
<tr class="separator:a4dbac6800b571ef6e4307e8d0be803f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cdf4e23a5c1cf9028fbd9794c4f32e"><td class="memItemLeft" align="right" valign="top">sal_Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a40cdf4e23a5c1cf9028fbd9794c4f32e">toInt32</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a40cdf4e23a5c1cf9028fbd9794c4f32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int32 value from this string.  <a href="#a40cdf4e23a5c1cf9028fbd9794c4f32e">More...</a><br/></td></tr>
<tr class="separator:a40cdf4e23a5c1cf9028fbd9794c4f32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2be479f24280101eda8f7169063cb5"><td class="memItemLeft" align="right" valign="top">sal_uInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4c2be479f24280101eda8f7169063cb5">toUInt32</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a4c2be479f24280101eda8f7169063cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uint32 value from this string.  <a href="#a4c2be479f24280101eda8f7169063cb5">More...</a><br/></td></tr>
<tr class="separator:a4c2be479f24280101eda8f7169063cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92834cbad1c62cbdc7f82803d17ae521"><td class="memItemLeft" align="right" valign="top">sal_Int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a92834cbad1c62cbdc7f82803d17ae521">toInt64</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a92834cbad1c62cbdc7f82803d17ae521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int64 value from this string.  <a href="#a92834cbad1c62cbdc7f82803d17ae521">More...</a><br/></td></tr>
<tr class="separator:a92834cbad1c62cbdc7f82803d17ae521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc3e8bea606ad9105ed8b64aa15f80c"><td class="memItemLeft" align="right" valign="top">sal_uInt64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4dc3e8bea606ad9105ed8b64aa15f80c">toUInt64</a> (sal_Int16 radix=10) const </td></tr>
<tr class="memdesc:a4dc3e8bea606ad9105ed8b64aa15f80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uint64 value from this string.  <a href="#a4dc3e8bea606ad9105ed8b64aa15f80c">More...</a><br/></td></tr>
<tr class="separator:a4dc3e8bea606ad9105ed8b64aa15f80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd066e4c1036c780468521ebae0fea8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a2fd066e4c1036c780468521ebae0fea8">toFloat</a> () const </td></tr>
<tr class="memdesc:a2fd066e4c1036c780468521ebae0fea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the float value from this string.  <a href="#a2fd066e4c1036c780468521ebae0fea8">More...</a><br/></td></tr>
<tr class="separator:a2fd066e4c1036c780468521ebae0fea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d346a3f277717e1e5442423d3ada78a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a5d346a3f277717e1e5442423d3ada78a">toDouble</a> () const </td></tr>
<tr class="memdesc:a5d346a3f277717e1e5442423d3ada78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double value from this string.  <a href="#a5d346a3f277717e1e5442423d3ada78a">More...</a><br/></td></tr>
<tr class="separator:a5d346a3f277717e1e5442423d3ada78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5be8271183843f90c59ed1d9924208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a9c5be8271183843f90c59ed1d9924208">intern</a> () const </td></tr>
<tr class="memdesc:a9c5be8271183843f90c59ed1d9924208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a canonical representation for a string.  <a href="#a9c5be8271183843f90c59ed1d9924208">More...</a><br/></td></tr>
<tr class="separator:a9c5be8271183843f90c59ed1d9924208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466c23d80451d20814cf0f8929f30ecd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a466c23d80451d20814cf0f8929f30ecd">convertToString</a> (<a class="el" href="a00148.html">OString</a> *pTarget, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> nEncoding, sal_uInt32 nFlags) const </td></tr>
<tr class="memdesc:a466c23d80451d20814cf0f8929f30ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts to an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>, signalling failure.  <a href="#a466c23d80451d20814cf0f8929f30ecd">More...</a><br/></td></tr>
<tr class="separator:a466c23d80451d20814cf0f8929f30ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cb05ee5cc459caff5e7ff5fd856db8"><td class="memItemLeft" align="right" valign="top">sal_uInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ad7cb05ee5cc459caff5e7ff5fd856db8">iterateCodePoints</a> (sal_Int32 *indexUtf16, sal_Int32 incrementCodePoints=1) const </td></tr>
<tr class="memdesc:ad7cb05ee5cc459caff5e7ff5fd856db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through this string based on code points instead of UTF-16 code units.  <a href="#ad7cb05ee5cc459caff5e7ff5fd856db8">More...</a><br/></td></tr>
<tr class="separator:ad7cb05ee5cc459caff5e7ff5fd856db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8224d8a113385962375e200d00234f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00148.html">OString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#abf8224d8a113385962375e200d00234f">toUtf8</a> () const </td></tr>
<tr class="memdesc:abf8224d8a113385962375e200d00234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this string to an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>, assuming that the string can be UTF-8-encoded successfully.  <a href="#abf8224d8a113385962375e200d00234f">More...</a><br/></td></tr>
<tr class="separator:abf8224d8a113385962375e200d00234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aad7625d81f0ead61742d70247374cc38"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aad7625d81f0ead61742d70247374cc38">unacquired</a> (rtl_uString *const *ppHandle)</td></tr>
<tr class="memdesc:aad7625d81f0ead61742d70247374cc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> const &amp; passing a storage pointer of an rtl_uString * handle.  <a href="#aad7625d81f0ead61742d70247374cc38">More...</a><br/></td></tr>
<tr class="separator:aad7625d81f0ead61742d70247374cc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c84bd9b62a08c96242d6f1cd29cbce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ae8c84bd9b62a08c96242d6f1cd29cbce">intern</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value, sal_Int32 length, <a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a> encoding, sal_uInt32 convertFlags=<a class="el" href="a00398.html#a0d72f032eb9370c7403fccb71c4e6906">OSTRING_TO_OUSTRING_CVTFLAGS</a>, sal_uInt32 *pInfo=NULL)</td></tr>
<tr class="memdesc:ae8c84bd9b62a08c96242d6f1cd29cbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a canonical representation for a converted string.  <a href="#ae8c84bd9b62a08c96242d6f1cd29cbce">More...</a><br/></td></tr>
<tr class="separator:ae8c84bd9b62a08c96242d6f1cd29cbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20215889e232b382981afeaf5cb6dc77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a20215889e232b382981afeaf5cb6dc77">fromUtf8</a> (const <a class="el" href="a00148.html">OString</a> &amp;rSource)</td></tr>
<tr class="memdesc:a20215889e232b382981afeaf5cb6dc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> to an <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>, assuming that the <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> is UTF-8-encoded.  <a href="#a20215889e232b382981afeaf5cb6dc77">More...</a><br/></td></tr>
<tr class="separator:a20215889e232b382981afeaf5cb6dc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018f2390085cbc237659be8cba355082"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a018f2390085cbc237659be8cba355082">number</a> (int i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a018f2390085cbc237659be8cba355082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the integer argument.  <a href="#a018f2390085cbc237659be8cba355082">More...</a><br/></td></tr>
<tr class="separator:a018f2390085cbc237659be8cba355082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6050412c8b165f1c398f362c5db62cb2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a6050412c8b165f1c398f362c5db62cb2">number</a> (unsigned int i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a6050412c8b165f1c398f362c5db62cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a6050412c8b165f1c398f362c5db62cb2">More...</a><br/></td></tr>
<tr class="separator:a6050412c8b165f1c398f362c5db62cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0cffe95387ee54f69a2f27852e2b42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a4b0cffe95387ee54f69a2f27852e2b42">number</a> (long i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a4b0cffe95387ee54f69a2f27852e2b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a4b0cffe95387ee54f69a2f27852e2b42">More...</a><br/></td></tr>
<tr class="separator:a4b0cffe95387ee54f69a2f27852e2b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdc67ad0349a1a1f0821cb4f5809f15"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a3cdc67ad0349a1a1f0821cb4f5809f15">number</a> (unsigned long i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a3cdc67ad0349a1a1f0821cb4f5809f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a3cdc67ad0349a1a1f0821cb4f5809f15">More...</a><br/></td></tr>
<tr class="separator:a3cdc67ad0349a1a1f0821cb4f5809f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f04e3908080c87608ef3a47dc8897f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a31f04e3908080c87608ef3a47dc8897f">number</a> (long long ll, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a31f04e3908080c87608ef3a47dc8897f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a31f04e3908080c87608ef3a47dc8897f">More...</a><br/></td></tr>
<tr class="separator:a31f04e3908080c87608ef3a47dc8897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f7fbab47e37399a5c1769281941b5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a23f7fbab47e37399a5c1769281941b5e">number</a> (unsigned long long ll, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a23f7fbab47e37399a5c1769281941b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a23f7fbab47e37399a5c1769281941b5e">More...</a><br/></td></tr>
<tr class="separator:a23f7fbab47e37399a5c1769281941b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c5799e56a4fc6caafd338161c6520"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ab46c5799e56a4fc6caafd338161c6520">number</a> (float f)</td></tr>
<tr class="memdesc:ab46c5799e56a4fc6caafd338161c6520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the float argument.  <a href="#ab46c5799e56a4fc6caafd338161c6520">More...</a><br/></td></tr>
<tr class="separator:ab46c5799e56a4fc6caafd338161c6520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5299f440c8d39f86aa33a4ad89ef560"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#af5299f440c8d39f86aa33a4ad89ef560">number</a> (double d)</td></tr>
<tr class="memdesc:af5299f440c8d39f86aa33a4ad89ef560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the double argument.  <a href="#af5299f440c8d39f86aa33a4ad89ef560">More...</a><br/></td></tr>
<tr class="separator:af5299f440c8d39f86aa33a4ad89ef560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a819114e3009805b6082da604c5c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ab74a819114e3009805b6082da604c5c5">valueOf</a> (<a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a> b)</td></tr>
<tr class="memdesc:ab74a819114e3009805b6082da604c5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the sal_Bool argument.  <a href="#ab74a819114e3009805b6082da604c5c5">More...</a><br/></td></tr>
<tr class="separator:ab74a819114e3009805b6082da604c5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4355afd5260ff7cf87a071fad6e1f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ace4355afd5260ff7cf87a071fad6e1f2">boolean</a> (bool b)</td></tr>
<tr class="memdesc:ace4355afd5260ff7cf87a071fad6e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the boolean argument.  <a href="#ace4355afd5260ff7cf87a071fad6e1f2">More...</a><br/></td></tr>
<tr class="separator:ace4355afd5260ff7cf87a071fad6e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e7bbd1201e9826c33d55892cad19f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#afa5e7bbd1201e9826c33d55892cad19f">valueOf</a> (<a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> c)</td></tr>
<tr class="memdesc:afa5e7bbd1201e9826c33d55892cad19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the char argument.  <a href="#afa5e7bbd1201e9826c33d55892cad19f">More...</a><br/></td></tr>
<tr class="separator:afa5e7bbd1201e9826c33d55892cad19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ec5d63f8a114eee9b33007ae8f05fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a43ec5d63f8a114eee9b33007ae8f05fb">valueOf</a> (sal_Int32 i, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a43ec5d63f8a114eee9b33007ae8f05fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the int argument.  <a href="#a43ec5d63f8a114eee9b33007ae8f05fb">More...</a><br/></td></tr>
<tr class="separator:a43ec5d63f8a114eee9b33007ae8f05fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f35153679f12afa94c2239ca8ca9c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a08f35153679f12afa94c2239ca8ca9c7">valueOf</a> (sal_Int64 ll, sal_Int16 radix=10)</td></tr>
<tr class="memdesc:a08f35153679f12afa94c2239ca8ca9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the long argument.  <a href="#a08f35153679f12afa94c2239ca8ca9c7">More...</a><br/></td></tr>
<tr class="separator:a08f35153679f12afa94c2239ca8ca9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32994a6849bc22733a989a647e2972fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a32994a6849bc22733a989a647e2972fe">valueOf</a> (float f)</td></tr>
<tr class="memdesc:a32994a6849bc22733a989a647e2972fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the float argument.  <a href="#a32994a6849bc22733a989a647e2972fe">More...</a><br/></td></tr>
<tr class="separator:a32994a6849bc22733a989a647e2972fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e291c0f25f2d56322642e1af974a91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a26e291c0f25f2d56322642e1af974a91">valueOf</a> (double d)</td></tr>
<tr class="memdesc:a26e291c0f25f2d56322642e1af974a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the double argument.  <a href="#a26e291c0f25f2d56322642e1af974a91">More...</a><br/></td></tr>
<tr class="separator:a26e291c0f25f2d56322642e1af974a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334144a0d4ba819304674ecba41f26a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a334144a0d4ba819304674ecba41f26a1">createFromAscii</a> (const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *value)</td></tr>
<tr class="memdesc:a334144a0d4ba819304674ecba41f26a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> copied without conversion from an ASCII character string.  <a href="#a334144a0d4ba819304674ecba41f26a1">More...</a><br/></td></tr>
<tr class="separator:a334144a0d4ba819304674ecba41f26a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6b7f1ab35cac871c421c9f5d8bec0459"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a6b7f1ab35cac871c421c9f5d8bec0459">pData</a> = NULL</td></tr>
<tr class="separator:a6b7f1ab35cac871c421c9f5d8bec0459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e1897fff87c173c892eaab9b2f994b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ae2e1897fff87c173c892eaab9b2f994b">else</a></td></tr>
<tr class="separator:ae2e1897fff87c173c892eaab9b2f994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9868d12cbfd5262d104bf99b8723740f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a9868d12cbfd5262d104bf99b8723740f">operator==</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:a9868d12cbfd5262d104bf99b8723740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0a26c2cb2ab453415878cb4322c581"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a5a0a26c2cb2ab453415878cb4322c581">operator==</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *pStr2)</td></tr>
<tr class="separator:a5a0a26c2cb2ab453415878cb4322c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4e36032cbe5c6c3e1d6bc2939f16b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#aef4e36032cbe5c6c3e1d6bc2939f16b1">operator==</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *pStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:aef4e36032cbe5c6c3e1d6bc2939f16b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068738a569adb0f5c2ce004fad06b404"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a068738a569adb0f5c2ce004fad06b404">operator!=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:a068738a569adb0f5c2ce004fad06b404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b5151db83a83cd30039bc4595f74af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a42b5151db83a83cd30039bc4595f74af">operator!=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *pStr2)</td></tr>
<tr class="separator:a42b5151db83a83cd30039bc4595f74af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e827d65c7d72e62d2f7a6c1c5ebb09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a5e827d65c7d72e62d2f7a6c1c5ebb09a">operator!=</a> (const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *pStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:a5e827d65c7d72e62d2f7a6c1c5ebb09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0baa9347651f7a1d00790824e858c87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ad0baa9347651f7a1d00790824e858c87">operator&lt;</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:ad0baa9347651f7a1d00790824e858c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31edd7af22ef9ab57d80a6dc464aedd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ab31edd7af22ef9ab57d80a6dc464aedd">operator&gt;</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:ab31edd7af22ef9ab57d80a6dc464aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100bc58201e330150a84ab77a9ad7da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#ad100bc58201e330150a84ab77a9ad7da">operator&lt;=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:ad100bc58201e330150a84ab77a9ad7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ce94198bd3dd95055bf11fa5891b3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#a40ce94198bd3dd95055bf11fa5891b3b">operator&gt;=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:a40ce94198bd3dd95055bf11fa5891b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a33b58fc853887ce5b636e65b22a8be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a33b58fc853887ce5b636e65b22a8be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a4a33b58fc853887ce5b636e65b22a8be">operator==</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rString, T &amp;literal)</td></tr>
<tr class="memdesc:a4a33b58fc853887ce5b636e65b22a8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string to an ASCII string literal.  <a href="#a4a33b58fc853887ce5b636e65b22a8be">More...</a><br/></td></tr>
<tr class="separator:a4a33b58fc853887ce5b636e65b22a8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c1b404c77a79f85da7c019fa15c170"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48c1b404c77a79f85da7c019fa15c170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a48c1b404c77a79f85da7c019fa15c170">operator==</a> (T &amp;literal, const <a class="el" href="a00152.html">OUString</a> &amp;rString)</td></tr>
<tr class="memdesc:a48c1b404c77a79f85da7c019fa15c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string to an ASCII string literal.  <a href="#a48c1b404c77a79f85da7c019fa15c170">More...</a><br/></td></tr>
<tr class="separator:a48c1b404c77a79f85da7c019fa15c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7542c64dbc496508ef306e8cd0681fcc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7542c64dbc496508ef306e8cd0681fcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#a7542c64dbc496508ef306e8cd0681fcc">operator!=</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rString, T &amp;literal)</td></tr>
<tr class="memdesc:a7542c64dbc496508ef306e8cd0681fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string to an ASCII string literal.  <a href="#a7542c64dbc496508ef306e8cd0681fcc">More...</a><br/></td></tr>
<tr class="separator:a7542c64dbc496508ef306e8cd0681fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ff46d90dd009f1930888fe3a106ba4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6ff46d90dd009f1930888fe3a106ba4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a><br class="typebreak"/>
&lt; T, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00152.html#af6ff46d90dd009f1930888fe3a106ba4">operator!=</a> (T &amp;literal, const <a class="el" href="a00152.html">OUString</a> &amp;rString)</td></tr>
<tr class="memdesc:af6ff46d90dd009f1930888fe3a106ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string to an ASCII string literal.  <a href="#af6ff46d90dd009f1930888fe3a106ba4">More...</a><br/></td></tr>
<tr class="separator:af6ff46d90dd009f1930888fe3a106ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a4f6bd98c85b9beefc4107ce5c1464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00152.html">OUString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html#af5a4f6bd98c85b9beefc4107ce5c1464">operator+</a> (const <a class="el" href="a00152.html">OUString</a> &amp;rStr1, const <a class="el" href="a00152.html">OUString</a> &amp;rStr2)</td></tr>
<tr class="separator:af5a4f6bd98c85b9beefc4107ce5c1464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This String class provides base functionality for C++ like Unicode character array handling. </p>
<p>The advantage of this class is that it handles all the memory management for you - and it does it more efficiently. If you assign a string to another string, the data of both strings are shared (without any copy operation or memory allocation) as long as you do not change the string. This class also stores the length of the string, so that many operations are faster than the C-str-functions.</p>
<p>This class provides only readonly string handling. So you could create a string and you could only query the content from this string. It provides also functionality to change the string, but this results in every case in a new string instance (in the most cases with a memory allocation). You don't have functionality to change the content of the string. If you want to change the string content, then you should use the <a class="el" href="a00149.html" title="A string buffer implements a mutable sequence of characters. ">OStringBuffer</a> class, which provides these functionalities and avoids too much memory allocation.</p>
<p>The design of this class is similar to the string classes in Java so less people should have understanding problems when they use this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aad41465279b4288eafc7fc8dabd57de0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string containing no characters. </p>

</div>
</div>
<a class="anchor" id="a1efa62551cf5aa0006edb4e72f106b23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a679d95859f010dbfd55f67cf4fa7c6eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad64d1f21c5034f621c09e9ac17edab4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">rtl_uString *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#a30b3dd1d6058d15544996570e4f14244">__sal_NoAcquire</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> from <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> data without acquiring it. </p>
<p>Takeover of ownership.</p>
<p>The SAL_NO_ACQUIRE dummy parameter is only there to distinguish this from other constructors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8883463669217f97450c21594965ef5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from a single Unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a Unicode character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae9d0605b97b12f86744604b1ed6c38a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from a Unicode character buffer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a NULL-terminated Unicode character array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69baba4d68131d28e548d2cfdc7781ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from a Unicode character buffer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a Unicode character array. </td></tr>
    <tr><td class="paramname">length</td><td>the number of character which should be copied. The character array length must be greater than or equal to this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b17d4b5f7a99ec88956daa1e429cc39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>convertFlags</em> = <code><a class="el" href="a00398.html#a0d72f032eb9370c7403fccb71c4e6906">OSTRING_TO_OUSTRING_CVTFLAGS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>New string from an 8-Bit character buffer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An 8-Bit character array. </td></tr>
    <tr><td class="paramname">length</td><td>The number of character which should be converted. The 8-Bit character array length must be greater than or equal to this value. </td></tr>
    <tr><td class="paramname">encoding</td><td>The text encoding from which the 8-Bit character sequence should be converted. </td></tr>
    <tr><td class="paramname">convertFlags</td><td>Flags which control the conversion. see RTL_TEXTTOUNICODE_FLAGS_...</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>is thrown if an out-of-memory condition occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbec113d5a8b3946066bf468181f016b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::OUString </td>
          <td>(</td>
          <td class="paramtype">sal_uInt32 const *&#160;</td>
          <td class="paramname"><em>codePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>codePointCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new string from an array of Unicode code points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codePoints</td><td>an array of at least codePointCount code points, which each must be in the range from 0 to 0x10FFFF, inclusive. May be null if codePointCount is zero.</td></tr>
    <tr><td class="paramname">codePointCount</td><td>the non-negative number of code points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>is thrown if either an out-of-memory condition occurs or the resulting number of UTF-16 code units would have been larger than SAL_MAX_INT32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a2c7f0154687eba2c4aa129d806d56153"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::~OUString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the string data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad8c87c2e0fdc256d57248d7ef4d6ec05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T &gt;::&#160;</td>
          <td class="paramname"><em>isValid</em>literal</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>New string from an 8-Bit string literal that is expected to contain only characters in the ASCII set (i.e. </p>
<p>first 128 characters). This constructor allows an efficient and convenient way to create <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> instances from ASCII literals. When creating strings from data that is not pure ASCII, it needs to be converted to <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> by explicitly providing the encoding to use for the conversion.</p>
<p>If there are any embedded \0's in the string literal, the result is undefined. Use the overload that explicitly accepts length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literal</td><td>the 8-bit ASCII string literal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ace4355afd5260ff7cf87a071fad6e1f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::boolean </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the boolean argument. </p>
<p>If the argument is true, the string "true" is returned. If the argument is false, the string "false" is returned. This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>a bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a21de4053f388ca64d8a4593dfe55e6c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rtl::OUString::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the string, i.e, makes a zero-character string. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.4 </dd></dl>

</div>
</div>
<a class="anchor" id="abc28ab1a9cac061dfa363d234c15da2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::compareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a27b3136b7be9a294ba3855b533b587f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::compareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>maxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings with a maximum count of characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
    <tr><td class="paramname">maxLength</td><td>the maximum count of characters to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a163ade83cc1019cfee6254257285660e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::compareToAscii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a5cfcb304b92de1e40b5e16c60d10a9ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::compareToAscii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>maxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings with a maximum count of characters. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated. This function can't be used for language specific sorting.</p>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000039">Deprecated:</a></b></dt><dd>This is a confusing overload with unexpectedly different semantics from the one-parameter form, so it is marked as deprecated. Practically all uses compare the return value against zero and can thus be replaced with uses of startsWith.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
    <tr><td class="paramname">maxLength</td><td>the maximum count of characters to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a6aa2e3cd47fdb3ec12242d0a163fba1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::compareToIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ASCII lowercase comparison of two strings. </p>
<p>Compare the two strings with uppercase ASCII character values between 65 and 90 (ASCII A-Z) interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a65e653c7014be68a00cef5d64004d8a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::compareToIgnoreAsciiCaseAscii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ASCII strings ignoring case. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.5 </dd></dl>

</div>
</div>
<a class="anchor" id="a2a5b837993df8de8cb54a5c62b6518cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates the specified string to the end of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string that is concatenated to the end of this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string that represents the concatenation of this string followed by the string argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a466c23d80451d20814cf0f8929f30ecd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::convertToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00148.html">OString</a> *&#160;</td>
          <td class="paramname"><em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>nEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts to an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>, signalling failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTarget</td><td>An out parameter receiving the converted <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>. Must not be null; the contents are not modified if conversion fails (convertToOString returns false).</td></tr>
    <tr><td class="paramname">nEncoding</td><td>The text encoding to convert into. Must be an octet encoding (i.e., rtl_isOctetTextEncoding(nEncoding) must return true).</td></tr>
    <tr><td class="paramname">nFlags</td><td>A combination of RTL_UNICODETOTEXT_FLAGS that detail how to do the conversion (see rtl_convertUnicodeToText). RTL_UNICODETOTEXT_FLAGS_FLUSH need not be included, it is implicitly assumed. Typical uses are either RTL_UNICODETOTEXT_FLAGS_UNDEFINED_ERROR | RTL_UNICODETOTEXT_FLAGS_INVALID_ERROR (fail if a Unicode character cannot be converted to the target nEncoding) or OUSTRING_TO_OSTRING_CVTFLAGS (make a best efforts conversion).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the conversion succeeded, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a33d7ec71ec600374f21c3acc3ebca951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::copy </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>beginIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string that is a substring of this string. </p>
<p>The substring begins at the specified beginIndex. If beginIndex is negative or be greater than the length of this string, behaviour is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIndex</td><td>the beginning index, inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified substring. </dd></dl>

</div>
</div>
<a class="anchor" id="a873a517f1c80294a747de15b45763d9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::copy </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string that is a substring of this string. </p>
<p>The substring begins at the specified beginIndex and contains count characters. If either beginIndex or count are negative, or beginIndex + count are greater than the length of this string then behaviour is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIndex</td><td>the beginning index, inclusive. </td></tr>
    <tr><td class="paramname">count</td><td>the number of characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified substring. </dd></dl>

</div>
</div>
<a class="anchor" id="a334144a0d4ba819304674ecba41f26a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::createFromAscii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> copied without conversion from an ASCII character string. </p>
<p>Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated.</p>
<p>Note that for string literals it is simpler and more efficient to directly use the <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-Bit ASCII character string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb53f713b1997e0b81eb6684406fa5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::endsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string ends with a given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest. Available since LibreOffice 4.2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the end of this string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a65c22a7c03154f9aa048ccf5fd632adc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::endsWith </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af610ee45069ceec1bd76e4ff0defa8b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::endsWithAsciiL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string ends with a given ASCII string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>a sequence of at least asciiStrLength ASCII characters (bytes in the range 0x00&ndash;0x7F) </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of asciiStr; must be non-negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this string ends with asciiStr; otherwise, false is returned</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a017dd59e54e0f528e17ddecc09d4a0f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::endsWithIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string ends with a given string, ignoring the case of ASCII letters. </p>
<p>Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest. Available since LibreOffice 4.2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the end of this string, ignoring the case of ASCII letters ("A"&ndash;"Z" and "a"&ndash;"z")</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a3399446a72c1df7a1c491c06ff1eb653"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::endsWithIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae223e616876b07581ac2e287baa8eb9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::endsWithIgnoreAsciiCaseAsciiL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string ends with a given ASCII string, ignoring the case of ASCII letters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>a sequence of at least asciiStrLength ASCII characters (bytes in the range 0x00&ndash;0x7F) </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of asciiStr; must be non-negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this string ends with asciiStr, ignoring the case of ASCII letters ("A"&ndash;"Z" and "a"&ndash;"z"); otherwise, false is returned </dd></dl>

</div>
</div>
<a class="anchor" id="ab27eea6349e6ef35c4256526508594bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad623b6908f7de9f883e2bb83167af403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::equalsAscii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b5cbe884bf53830cd52a6c79784deac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::equalsAsciiL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated and must be greater than or equal to asciiStrLength. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of the ascii string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f3c60117ab0f8184a2adcacee3d9d30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::equalsIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ASCII lowercase comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string, ignoring the case. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a1a43697ee00de08462b1f824bd7604"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::equalsIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ace7e3dacb52676ffaaced8c747fde6b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::equalsIgnoreAsciiCaseAscii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a ASCII lowercase comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string, ignoring the case. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe30143b47aa0960921a72eb2ff862c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::equalsIgnoreAsciiCaseAsciiL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an ASCII lowercase comparison of two strings. </p>
<p>The result is true if and only if second string represents the same sequence of characters as the first string, ignoring the case. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated and must be greater than or equal to asciiStrLength. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of the ascii string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the strings are equal; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a20215889e232b382981afeaf5cb6dc77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::fromUtf8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00148.html">OString</a> &amp;&#160;</td>
          <td class="paramname"><em>rSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> to an <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>, assuming that the <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> is UTF-8-encoded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rSource</td><td>an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a> to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a4fc7bef14bae146d14f7cce8fa255f4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::getLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of this string. </p>
<p>The length is equal to the number of Unicode characters in this string.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the sequence of characters represented by this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a53de57545f204606a0051d041c0320ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>* rtl::OUString::getStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the Unicode character buffer for this string. </p>
<p>It isn't necessarily NULL terminated.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the Unicode characters buffer for this object. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a49115d2964b545ccaf0e831eaf9d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00152.html">OUString</a> rtl::OUString::getToken </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>cTok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a token in the string. </p>
<p>Example: sal_Int32 nIndex = 0; do { ... <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> aToken = aStr.getToken( 0, ';', nIndex ); ... } while ( nIndex &gt;= 0 );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the number of the token to return </td></tr>
    <tr><td class="paramname">cTok</td><td>the character which separate the tokens. </td></tr>
    <tr><td class="paramname">index</td><td>the position at which the token is searched in the string. The index must not be greater than the length of the string. This param is set to the position of the next token or to -1, if it is the last token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the token; if either token or index is negative, an empty token is returned (and index is set to -1) </dd></dl>

</div>
</div>
<a class="anchor" id="aaaed31acdc601d8e74e9c45b5143f958"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00152.html">OUString</a> rtl::OUString::getToken </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a token from the string. </p>
<p>The same as getToken(sal_Int32, sal_Unicode, sal_Int32 &amp;), but always passing in 0 as the start index in the third argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of the token to return, starting with 0 </td></tr>
    <tr><td class="paramname">separator</td><td>the character which separates the tokens</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given token, or an empty string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a689cedcbac350ee95ed428b54438a409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::hashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a hashcode for this string. </p>
<dl class="section return"><dt>Returns</dt><dd>a hash code value for this object.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00154.html" title="A helper to use OUStrings with hash maps. ">rtl::OUStringHash</a> for convenient use of std::unordered_map </dd></dl>

</div>
</div>
<a class="anchor" id="a4e6c0b2e5c8910252c9ac37d6dec1b67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T &gt;::length&#160;</td>
          <td class="paramname"> = <code>=&#160;0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8122412b6ec3cc2bb24f88ef29e8278"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::indexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to be located. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the search from. The index must be greater than or equal to 0 and less than or equal to the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first occurrence of the character in the character sequence represented by this string that is greater than or equal to fromIndex, or -1 if the character does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="add084235abab4069399f1d8ea0629d2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::indexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. </p>
<p>If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the search from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string at the starting index, then the index of the first character of the first such substring is returned. If it does not occur as a substring starting at fromIndex or beyond, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9e1bdb7ac2880711e6cddcb54891caa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, sal_Int32 &gt;::Type rtl::OUString::indexOf </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ac46ce79ed67437b4e65f59373b2410a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::indexOfAsciiL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the first occurrence of the specified ASCII substring, starting at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be searched for. Need not be null-terminated, but must be at least as long as the specified len. Must only contain characters in the ASCII range 0x00&ndash;7F.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the substring; must be non-negative.</td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the search from. Must be in the range from zero to the length of this string, inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the first occurrence of the substring within this string starting at the given fromIndex, or -1 if the substring does not occur. If len is zero, -1 is returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a9c5be8271183843f90c59ed1d9924208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00152.html">OUString</a> rtl::OUString::intern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a canonical representation for a string. </p>
<p>A pool of strings, initially empty is maintained privately by the string class. On invocation, if present in the pool the original string will be returned. Otherwise this string, or a copy thereof will be added to the pool and returned.</p>
<dl class="section return"><dt>Returns</dt><dd>a version of the string from the pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>is thrown if an out-of-memory condition occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="ae8c84bd9b62a08c96242d6f1cd29cbce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::intern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00392.html#a971dc838b99d01967cb589fb0f29ff55">rtl_TextEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32&#160;</td>
          <td class="paramname"><em>convertFlags</em> = <code><a class="el" href="a00398.html#a0d72f032eb9370c7403fccb71c4e6906">OSTRING_TO_OUSTRING_CVTFLAGS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_uInt32 *&#160;</td>
          <td class="paramname"><em>pInfo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a canonical representation for a converted string. </p>
<p>A pool of strings, initially empty is maintained privately by the string class. On invocation, if present in the pool the original string will be returned. Otherwise this string, or a copy thereof will be added to the pool and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a 8-Bit character array. </td></tr>
    <tr><td class="paramname">length</td><td>the number of character which should be converted. The 8-Bit character array length must be greater than or equal to this value. </td></tr>
    <tr><td class="paramname">encoding</td><td>the text encoding from which the 8-Bit character sequence should be converted. </td></tr>
    <tr><td class="paramname">convertFlags</td><td>flags which controls the conversion. see RTL_TEXTTOUNICODE_FLAGS_... </td></tr>
    <tr><td class="paramname">pInfo</td><td>pointer to return conversion status or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a version of the converted string from the pool.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>is thrown if an out-of-memory condition occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="adddb81f83357238c9851da6899162ae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a string is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the string is empty; false, otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.4 </dd></dl>

</div>
</div>
<a class="anchor" id="ad7cb05ee5cc459caff5e7ff5fd856db8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_uInt32 rtl::OUString::iterateCodePoints </td>
          <td>(</td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>indexUtf16</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>incrementCodePoints</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate through this string based on code points instead of UTF-16 code units. </p>
<p>See Chapter 3 of The Unicode Standard 5.0 (Addison&ndash;Wesley, 2006) for definitions of the various terms used in this description.</p>
<p>This string is interpreted as a sequence of zero or more UTF-16 code units. For each index into this sequence (from zero to one less than the length of the sequence, inclusive), a code point represented starting at the given index is computed as follows:</p>
<ul>
<li>If the UTF-16 code unit addressed by the index constitutes a well-formed UTF-16 code unit sequence, the computed code point is the scalar value encoded by that UTF-16 code unit sequence.</li>
<li>Otherwise, if the index is at least two UTF-16 code units away from the end of the sequence, and the sequence of two UTF-16 code units addressed by the index constitutes a well-formed UTF-16 code unit sequence, the computed code point is the scalar value encoded by that UTF-16 code unit sequence.</li>
<li>Otherwise, the computed code point is the UTF-16 code unit addressed by the index. (This last case catches unmatched surrogates as well as indices pointing into the middle of surrogate pairs.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexUtf16</td><td>pointer to a UTF-16 based index into this string; must not be null. On entry, the index must be in the range from zero to the length of this string (in UTF-16 code units), inclusive. Upon successful return, the index will be updated to address the UTF-16 code unit that is the given incrementCodePoints away from the initial index.</td></tr>
    <tr><td class="paramname">incrementCodePoints</td><td>the number of code points to move the given *indexUtf16. If non-negative, moving is done after determining the code point at the index. If negative, moving is done before determining the code point at the (then updated) index. The value must be such that the resulting UTF-16 based index is in the range from zero to the length of this string (in UTF-16 code units), inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the code point (an integer in the range from 0 to 0x10FFFF, inclusive) that is represented within this string starting at the index computed as follows: If incrementCodePoints is non-negative, the index is the initial value of *indexUtf16; if incrementCodePoints is negative, the index is the updated value of *indexUtf16. In either case, the computed index must be in the range from zero to one less than the length of this string (in UTF-16 code units), inclusive.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="a3a7183d4dcaa88adba27f4787ddc5050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified character, searching backward starting at the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the last occurrence of the character in the character sequence represented by this string, or -1 if the character does not occur. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d4415f8e6c4d0c72b70fb29e7e5e9c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified character, searching backward starting before the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>character to be located. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index before which to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the last occurrence of the character in the character sequence represented by this string that is less than fromIndex, or -1 if the character does not occur before that point. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e113153776d2d17c3f740a0eb7996d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the end. </p>
<p>The returned index indicates the starting index of the substring in this string. If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string, then the index of the first character of the last such substring is returned. If it does not occur as a substring, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e8a57bd4af7d5eac24b523db54d52e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified substring, searching backward starting before the specified index. </p>
<p>The returned index indicates the starting index of the substring in this string. If str doesn't include any character, always -1 is returned. This is also the case, if both strings are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to search for. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index before which to start the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the string argument occurs one or more times as a substring within this string before the starting index, then the index of the first character of the last such substring is returned. Otherwise, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a73e6965f4d2d57e6bafe21f384b9cf10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, sal_Int32 &gt;::Type rtl::OUString::lastIndexOf </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae1af1a0c6264542cd8342535e6c325af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::lastIndexOfAsciiL </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index within this string of the last occurrence of the specified ASCII substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be searched for. Need not be null-terminated, but must be at least as long as the specified len. Must only contain characters in the ASCII range 0x00&ndash;7F.</td></tr>
    <tr><td class="paramname">len</td><td>the length of the substring; must be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index (starting at 0) of the first character of the last occurrence of the substring within this string, or -1 if the substring does not occur. If len is zero, -1 is returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>UDK 3.2.7 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6eeb6113c5eee94b85dc05aeb302902"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string. </p>
<p>The result is true if and only if the second string appears as a substring of this string, at the given position. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object (substring) to be compared. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the comparion from. The index must be greater than or equal to 0 and less or equal as the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str match with the characters in the string at the given position; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7ecbf29b4bd62768c687a349ae8ef64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a979d86657541fa568f65e4ac18230171"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::matchAsciiL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string. </p>
<p>The result is true if and only if the second string appears as a substring of this string, at the given position. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated and must be greater than or equal to asciiStrLength. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the object (substring) to be compared. </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of asciiStr. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the comparion from. The index must be greater than or equal to 0 and less than or equal to the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str match with the characters in the string at the given position; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e2fd3cae44cc8882107965dc8aeccd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::matchIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string, ignoring the case of ASCII letters. </p>
<p>The result is true if and only if the second string appears as a substring of this string, at the given position. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object (substring) to be compared. </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the comparion from. The index must be greater than or equal to 0 and less than or equal to the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str match with the characters in the string at the given position; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a04c970c1b2425b787f4cc89eacc3530f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::matchIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a6d944b80903e31fc042e026c9ddd0ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::matchIgnoreAsciiCaseAsciiL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match against a substring appearing in this string, ignoring the case of ASCII letters. </p>
<p>The result is true if and only if the second string appears as a substring of this string, at the given position. Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated and must be greater than or equal to asciiStrLength. This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of the ascii string </td></tr>
    <tr><td class="paramname">fromIndex</td><td>the index to start the comparion from. The index must be greater than or equal to 0 and less than or equal to the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str match with the characters in the string at the given position; false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a018f2390085cbc237659be8cba355082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the integer argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>an integer value </td></tr>
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a6050412c8b165f1c398f362c5db62cb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a4b0cffe95387ee54f69a2f27852e2b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a3cdc67ad0349a1a1f0821cb4f5809f15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a31f04e3908080c87608ef3a47dc8897f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a23f7fbab47e37399a5c1769281941b5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ab46c5799e56a4fc6caafd338161c6520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the float argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="af5299f440c8d39f86aa33a4ad89ef560"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::number </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the double argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a59a64ff242678d23a37be69ab8b440d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00152.html">OUString</a>&amp; rtl::OUString::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>is thrown if an out-of-memory condition occurs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac55194132016e1d5af3e0ff7a3e5780b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt;T, <a class="el" href="a00152.html">OUString</a> &amp;&gt;::Type rtl::OUString::operator+= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an ASCII string literal to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literal</td><td>an 8-bit ASCII-only string literal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a646f44367e4dcaec4c61a97ccbb05496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00152.html">OUString</a>&amp; rtl::OUString::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c6a3d60e5b579b4331333c139124f11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, <a class="el" href="a00152.html">OUString</a>&amp; &gt;::Type rtl::OUString::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new string from an 8-Bit string literal that is expected to contain only characters in the ASCII set (i.e. </p>
<p>first 128 characters). This operator allows an efficient and convenient way to assign <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> instances from ASCII literals. When assigning strings from data that is not pure ASCII, it needs to be converted to <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> by explicitly providing the encoding to use for the conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literal</td><td>the 8-bit ASCII string literal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ad7ec0ee3e0a23edb55d09484e3a1776e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> rtl::OUString::operator[] </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to individual characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>must be non-negative and less than length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character at the given index.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.5 </dd></dl>

</div>
</div>
<a class="anchor" id="aba49555be3571bf5349ff302bcd0d0d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>oldChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>newChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar. </p>
<p>If the character oldChar does not occur in the character sequence represented by this object, then the string is assigned with str.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldChar</td><td>the old character. </td></tr>
    <tr><td class="paramname">newChar</td><td>the new character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string derived from this string by replacing every occurrence of oldChar with newChar. </dd></dl>

</div>
</div>
<a class="anchor" id="a989d0a52dba52e692494ef822efa90e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::replaceAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>fromIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the substring to be replaced</td></tr>
    <tr><td class="paramname">to</td><td>the replacing substring</td></tr>
    <tr><td class="paramname">fromIndex</td><td>the position in the string where we will begin searching</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adb908e717e1ca0f942f95d473e4e0779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type rtl::OUString::replaceAll </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>ASCII string literal, the substring to be replaced</td></tr>
    <tr><td class="paramname">to</td><td>the replacing substring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a5689081eb22cffa91855535df7d1fcab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type rtl::OUString::replaceAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the substring to be replaced</td></tr>
    <tr><td class="paramname">to</td><td>ASCII string literal, the replacing substring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ad57686e4f21a791026faba87b07c5c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T1, typename <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T2, <a class="el" href="a00152.html">OUString</a> &gt;::Type &gt;::Type rtl::OUString::replaceAll </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing all occurrences of a given substring with another substring. </p>
<p>Replacing subsequent occurrences picks up only after a given replacement. That is, replacing from "xa" to "xx" in "xaa" results in "xxa", not "xxx".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>ASCII string literal, the substring to be replaced</td></tr>
    <tr><td class="paramname">to</td><td>ASCII string literal, the substring to be replaced</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af773e476b52e8f511b3d5aab141cb2f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::replaceAt </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing n = count characters from position index in this string with newStr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the replacing index in str. The index must be greater than or equal to 0 and less than or equal to the length of the string. </td></tr>
    <tr><td class="paramname">count</td><td>the count of characters that will be replaced The count must be greater than or equal to 0 and less than or equal to the length of the string minus index. </td></tr>
    <tr><td class="paramname">newStr</td><td>the new substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new string. </dd></dl>

</div>
</div>
<a class="anchor" id="ae88686c65ee3c3e9bb366dab9f30cf96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::replaceFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>the substring to be replaced</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>the replacing substring</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index; if the pointer is non-null: upon entry to the function, its value is the index into this string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than this string's length; upon exiting the function its value is the index into this string at which the replacement took place or -1 if no replacement took place; if the pointer is null, searching always starts at index 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af5b6dcadaef281238a8e7ff79ac8bff2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type rtl::OUString::replaceFirst </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>ASCII string literal, the substring to be replaced</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>the replacing substring</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index; if the pointer is non-null: upon entry to the function, its value is the index into the this string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than this string's length; upon exiting the function its value is the index into this string at which the replacement took place or -1 if no replacement took place; if the pointer is null, searching always starts at index 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ae2b550448bdfd9a59b263bba2cfabc7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, <a class="el" href="a00152.html">OUString</a> &gt;::Type rtl::OUString::replaceFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>the substring to be replaced</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>ASCII string literal, the replacing substring</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index; if the pointer is non-null: upon entry to the function, its value is the index into the this string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than this string's length; upon exiting the function its value is the index into this string at which the replacement took place or -1 if no replacement took place; if the pointer is null, searching always starts at index 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 5.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a69c8f675283136798989e53e32baa5b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T1, typename <a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T2, <a class="el" href="a00152.html">OUString</a> &gt;::Type &gt;::Type rtl::OUString::replaceFirst </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32 *&#160;</td>
          <td class="paramname"><em>index</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from replacing the first occurrence of a given substring with another substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>ASCII string literal, the substring to be replaced</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">to</td><td>ASCII string literal, the substring to be replaced</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>pointer to a start index; if the pointer is non-null: upon entry to the function, its value is the index into the this string at which to start searching for the <code>from</code> substring, the value must be non-negative and not greater than this string's length; upon exiting the function its value is the index into this string at which the replacement took place or -1 if no replacement took place; if the pointer is null, searching always starts at index 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a75c91bb6aed6ebf4e190d82465aa4902"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::reverseCompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings in reverse order. </p>
<p>The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the object to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a5814c0210e60d3a2d3f1bf4705febd38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, sal_Int32 &gt;::Type rtl::OUString::reverseCompareTo </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a64385b39b87e6404c345e253dfbdad8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::reverseCompareToAsciiL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#a50344fc80f122074b8a7e563c5627779">sal_Char</a> *&#160;</td>
          <td class="paramname"><em>asciiStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>asciiStrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings in reverse order. </p>
<p>This could be useful, if normally both strings start with the same content. The comparison is based on the numeric value of each character in the strings and return a value indicating their relationship. Since this method is optimized for performance, the ASCII character values are not converted in any way. The caller has to make sure that all ASCII characters are in the allowed range between 0 and 127. The ASCII string must be NULL-terminated and must be greater than or equal to asciiStrLength. This function can't be used for language specific sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asciiStr</td><td>the 8-Bit ASCII character string to be compared. </td></tr>
    <tr><td class="paramname">asciiStrLength</td><td>the length of the ascii string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - if both strings are equal &lt; 0 - if this string is less than the string argument &gt; 0 - if this string is greater than the string argument </dd></dl>

</div>
</div>
<a class="anchor" id="a86fcae3e2c911e180906b248b325894e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::startsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string starts with a given substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest. Available since LibreOffice 4.2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the start of this string</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9091aa2c4311d8b71cbe1f286c67593a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::startsWith </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aef11e4a288bacd470d9e729936f66256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::startsWithIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this string starts with a given string, ignoring the case of ASCII letters. </p>
<p>Character values between 65 and 90 (ASCII A-Z) are interpreted as values between 97 and 122 (ASCII a-z). This function can't be used for language specific comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the substring to be compared</td></tr>
    <tr><td class="paramname">rest</td><td>if non-null, and this function returns true, then assign a copy of the remainder of this string to *rest. Available since LibreOffice 4.2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the given str appears as a substring at the start of this string, ignoring the case of ASCII letters ("A"&ndash;"Z" and "a"&ndash;"z")</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af732b2eb7012558ad411fe5754048ad7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type rtl::OUString::startsWithIgnoreAsciiCase </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00152.html">OUString</a> *&#160;</td>
          <td class="paramname"><em>rest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function accepts an ASCII string literal as its argument. </p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8ed83f78d4affee3fc347a6fceab7f03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::toAsciiLowerCase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from this string all ASCII uppercase characters (65-90) to ASCII lowercase characters (97-122). </p>
<p>This function can't be used for language specific conversion. If the string doesn't contain characters which must be converted, then the new string is assigned with str.</p>
<dl class="section return"><dt>Returns</dt><dd>the string, converted to ASCII lowercase. </dd></dl>

</div>
</div>
<a class="anchor" id="adf7e9a2117388362e604ca8d3aeab614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::toAsciiUpperCase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from this string all ASCII lowercase characters (97-122) to ASCII uppercase characters (65-90). </p>
<p>This function can't be used for language specific conversion. If the string doesn't contain characters which must be converted, then the new string is assigned with str.</p>
<dl class="section return"><dt>Returns</dt><dd>the string, converted to ASCII uppercase. </dd></dl>

</div>
</div>
<a class="anchor" id="a31add7c6d0cf43b0917f2be8c5dd9556"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rtl::OUString::toBoolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Boolean value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>true, if the string is 1 or "True" in any ASCII case. false in any other case. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dbac6800b571ef6e4307e8d0be803f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> rtl::OUString::toChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first character from this string. </p>
<dl class="section return"><dt>Returns</dt><dd>the first character from this string or 0, if this string is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d346a3f277717e1e5442423d3ada78a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double rtl::OUString::toDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the double value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>the double represented from this string. 0.0 if this string represents no number. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fd066e4c1036c780468521ebae0fea8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float rtl::OUString::toFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the float value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>the float represented from this string. 0.0 if this string represents no number. </dd></dl>

</div>
</div>
<a class="anchor" id="a40cdf4e23a5c1cf9028fbd9794c4f32e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int32 rtl::OUString::toInt32 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the int32 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int32 represented from this string. 0 if this string represents no number or one of too large magnitude. </dd></dl>

</div>
</div>
<a class="anchor" id="a92834cbad1c62cbdc7f82803d17ae521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_Int64 rtl::OUString::toInt64 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the int64 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int64 represented from this string. 0 if this string represents no number or one of too large magnitude. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c2be479f24280101eda8f7169063cb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_uInt32 rtl::OUString::toUInt32 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the uint32 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uint32 represented from this string. 0 if this string represents no number or one of too large magnitude.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc3e8bea606ad9105ed8b64aa15f80c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal_uInt64 rtl::OUString::toUInt64 </td>
          <td>(</td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the uint64 value from this string. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uint64 represented from this string. 0 if this string represents no number or one of too large magnitude.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.1 </dd></dl>

</div>
</div>
<a class="anchor" id="abf8224d8a113385962375e200d00234f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00148.html">OString</a> rtl::OUString::toUtf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this string to an <a class="el" href="a00148.html" title="This String class provide base functionality for C++ like 8-Bit character array handling. ">OString</a>, assuming that the string can be UTF-8-encoded successfully. </p>
<p>In other words, you must not use this method on a random sequence of UTF-16 code units, but only at places where it is assumed that the content is a proper string.</p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 4.4 </dd></dl>

</div>
</div>
<a class="anchor" id="adffb0b67cc91b01250240f8d5a82c327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00409.html#ae7592498ff29e77d61c157d5a7c5197b">SAL_WARN_UNUSED_RESULT</a> <a class="el" href="a00152.html">OUString</a> rtl::OUString::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new string resulting from removing white space from both ends of the string. </p>
<p>All characters that have codes less than or equal to 32 (the space character), and Unicode General Punctuation area Space and some Control characters are considered to be white space (see rtl_ImplIsWhitespace). If the string doesn't contain white spaces at both ends, then the new string is assigned with str.</p>
<dl class="section return"><dt>Returns</dt><dd>the string, with white space removed from the front and end. </dd></dl>

</div>
</div>
<a class="anchor" id="aad7625d81f0ead61742d70247374cc38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> const&amp; rtl::OUString::unacquired </td>
          <td>(</td>
          <td class="paramtype">rtl_uString *const *&#160;</td>
          <td class="paramname"><em>ppHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> const &amp; passing a storage pointer of an rtl_uString * handle. </p>
<p>It is more convenient to use C++ <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> member functions when dealing with rtl_uString * handles. Using this function avoids unnecessary acquire()/release() calls for a temporary <a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppHandle</td><td>pointer to storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00152.html" title="This String class provides base functionality for C++ like Unicode character array handling...">OUString</a> const &amp; based on given storage </dd></dl>

</div>
</div>
<a class="anchor" id="ab74a819114e3009805b6082da604c5c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::valueOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#a66585e12aa9edc6e11fc7994e1c12286">sal_Bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the sal_Bool argument. </p>
<p>If the sal_Bool is true, the string "true" is returned. If the sal_Bool is false, the string "false" is returned. This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>a sal_Bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000040">Deprecated:</a></b></dt><dd>use <a class="el" href="a00152.html#ace4355afd5260ff7cf87a071fad6e1f2" title="Returns the string representation of the boolean argument. ">boolean()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa5e7bbd1201e9826c33d55892cad19f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::valueOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the char argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000041">Deprecated:</a></b></dt><dd>use operator, function or constructor taking char or sal_Unicode argument </dd></dl>

</div>
</div>
<a class="anchor" id="a43ec5d63f8a114eee9b33007ae8f05fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::valueOf </td>
          <td>(</td>
          <td class="paramtype">sal_Int32&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the int argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>a int32. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000042">Deprecated:</a></b></dt><dd>use <a class="el" href="a00152.html#a018f2390085cbc237659be8cba355082" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a08f35153679f12afa94c2239ca8ca9c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::valueOf </td>
          <td>(</td>
          <td class="paramtype">sal_Int64&#160;</td>
          <td class="paramname"><em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sal_Int16&#160;</td>
          <td class="paramname"><em>radix</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the long argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>a int64. </td></tr>
    <tr><td class="paramname">radix</td><td>the radix (between 2 and 36) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000043">Deprecated:</a></b></dt><dd>use <a class="el" href="a00152.html#a018f2390085cbc237659be8cba355082" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a32994a6849bc22733a989a647e2972fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::valueOf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the float argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a float. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000044">Deprecated:</a></b></dt><dd>use <a class="el" href="a00152.html#a018f2390085cbc237659be8cba355082" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26e291c0f25f2d56322642e1af974a91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00152.html">OUString</a> rtl::OUString::valueOf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the double argument. </p>
<p>This function can't be used for language specific conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the string representation of the argument. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00467.html#_deprecated000045">Deprecated:</a></b></dt><dd>use <a class="el" href="a00152.html#a018f2390085cbc237659be8cba355082" title="Returns the string representation of the integer argument. ">number()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a068738a569adb0f5c2ce004fad06b404"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42b5151db83a83cd30039bc4595f74af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>pStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5e827d65c7d72e62d2f7a6c1c5ebb09a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7542c64dbc496508ef306e8cd0681fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare string to an ASCII string literal. </p>
<p>This operator is equal to calling !equalsAsciiL().</p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af6ff46d90dd009f1930888fe3a106ba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator!= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare string to an ASCII string literal. </p>
<p>This operator is equal to calling !equalsAsciiL().</p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="af5a4f6bd98c85b9beefc4107ce5c1464"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00152.html">OUString</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0baa9347651f7a1d00790824e858c87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad100bc58201e330150a84ab77a9ad7da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9868d12cbfd5262d104bf99b8723740f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a0a26c2cb2ab453415878cb4322c581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>pStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef4e36032cbe5c6c3e1d6bc2939f16b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00409.html#aa610619c9a4164b4cd9b6a86351da3cd">sal_Unicode</a> *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4a33b58fc853887ce5b636e65b22a8be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare string to an ASCII string literal. </p>
<p>This operator is equal to calling <a class="el" href="a00152.html#a0b5cbe884bf53830cd52a6c79784deac" title="Perform a comparison of two strings. ">equalsAsciiL()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a48c1b404c77a79f85da7c019fa15c170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00067.html">libreoffice_internal::ConstCharArrayDetector</a>&lt; T, bool &gt;::Type operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare string to an ASCII string literal. </p>
<p>This operator is equal to calling <a class="el" href="a00152.html#a0b5cbe884bf53830cd52a6c79784deac" title="Perform a comparison of two strings. ">equalsAsciiL()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>LibreOffice 3.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ab31edd7af22ef9ab57d80a6dc464aedd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40ce94198bd3dd95055bf11fa5891b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00152.html">OUString</a> &amp;&#160;</td>
          <td class="paramname"><em>rStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae2e1897fff87c173c892eaab9b2f994b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">            <a class="code" href="a00398.html#a596bbcc30e556a1c0969e96d9e834c99">rtl_uString_newFromLiteral</a>(</div>
<div class="line">                &amp;<a class="code" href="a00152.html#a6b7f1ab35cac871c421c9f5d8bec0459">pData</a>,</div>
<div class="line">                libreoffice_internal::ConstCharArrayDetector&lt;T&gt;::toPointer(</div>
<div class="line">                    literal),</div>
<div class="line">                libreoffice_internal::ConstCharArrayDetector&lt;T&gt;::length, 0)</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6b7f1ab35cac871c421c9f5d8bec0459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtl::OUString::pData = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>rtl/<a class="el" href="a00399_source.html">ustring.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>

{
  "author": {
    "name": "Zach Carter",
    "email": "zach@carter.name",
    "url": "http://zaa.ch"
  },
  "name": "lex-parser",
  "version": "0.1.4-122",
  "description": "A parser for lexical grammars used by jison",
  "main": "lex-parser.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "repository": "https://github.com/zaach/lex-parser.git"
  },
  "keywords": [
    "lexical",
    "grammar",
    "parser",
    "jison"
  ],
  "license": "MIT",
  "dependencies": {
    "xregexp": "github:gerhobbelt/xregexp#master"
  },
  "devDependencies": {
    "jison": "github:gerhobbelt/jison#master",
    "test": ">=0.6.0"
  },
  "gitHead": "673175a3bce86f9b754dcb13c85b2e448716b654",
  "readme": "# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require(\"lex-parser\");\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n```\nNAME                                    [a-zA-Z_](?:[a-zA-Z0-9_-]*[a-zA-Z0-9_])?\nID                                      [a-zA-Z_][a-zA-Z0-9_]*\nBR                                      \\r\\n|\\n|\\r\n\n%s indented trail rules\n%x code start_condition options conditions action path set\n\n%options easy_keyword_rules\n%options ranges\n\n%%\n\n<action>\"/*\"(.|\\n|\\r)*?\"*/\"             return 'ACTION_BODY';\n<action>\"//\".*                          return 'ACTION_BODY';\n<action>\"/\"[^ /]*?['\"{}'][^ ]*?\"/\"      return 'ACTION_BODY'; // regexp with braces or quotes (and no spaces)\n<action>\\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         return 'ACTION_BODY';\n<action>\"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       return 'ACTION_BODY';\n<action>[/\"'][^{}/\"']+                  return 'ACTION_BODY';\n<action>[^{}/\"']+                       return 'ACTION_BODY';\n<action>\"{\"                             yy.depth++; return '{';\n<action>\"}\"                             if (yy.depth == 0) { this.begin('trail'); } else { yy.depth--; } return '}';\n\n<conditions>{NAME}                      return 'NAME';\n<conditions>\">\"                         this.popState(); return '>';\n<conditions>\",\"                         return ',';\n<conditions>\"*\"                         return '*';\n\n<rules>{BR}+                            /* empty */\n<rules>\\s+{BR}+                         /* empty */\n<rules>\\s+                              this.begin('indented');\n<rules>\"%%\"                             this.begin('code'); return '%%';\n<rules>[^\\s\\r\\n<>\\[\\](){}.*+?:!=|%\\/\\\\^$,'\"\"]+\n                                        %{                      \n                                            // accept any non-regex, non-lex, non-string-delim, \n                                            // non-escape-starter, non-space character as-is\n                                            return 'CHARACTER_LIT';\n                                        %}\n<options>{NAME}                         return 'NAME';\n<options>\"=\"                            return '=';\n<options>\\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"        yytext = yytext.substr(1, yytext.length - 2); return 'OPTION_VALUE';\n<options>\"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"      yytext = yytext.substr(1, yytext.length - 2); return 'OPTION_VALUE';\n<options>[^\\s\\r\\n]+                     return 'OPTION_VALUE';\n<options>{BR}+                          this.popState(); return 'OPTIONS_END';\n<options>\\s+{BR}+                       this.popState(); return 'OPTIONS_END';\n<options>\\s+                            /* empty */\n\n<start_condition>{ID}                   return 'START_COND';\n<start_condition>{BR}+                  this.popState();\n<start_condition>\\s+{BR}+               this.popState();\n<start_condition>\\s+                    /* empty */\n\n<trail>\\s*{BR}+                         this.begin('rules');\n\n<indented>\"{\"                           yy.depth = 0; this.begin('action'); return '{';\n<indented>\"%{\"(.|{BR})*?\"%}\"            this.begin('trail'); yytext = yytext.substr(2, yytext.length - 4); return 'ACTION';\n\"%{\"(.|{BR})*?\"%}\"                      yytext = yytext.substr(2, yytext.length - 4); return 'ACTION';\n<indented>\"%include\"                    %{\n                                            // This is an include instruction in place of an action: \n                                            // thanks to the `<indented>.+` rule immediately below we need to semi-duplicate \n                                            // the `%include` token recognition here vs. the almost-identical rule for the same \n                                            // further below.\n                                            // There's no real harm as we need to do something special in this case anyway:\n                                            // push 2 (two!) conditions.\n                                            //\n                                            // (Anecdotal: to find that we needed to place this almost-copy here to make the test grammar\n                                            // parse correctly took several hours as the debug facilities were - and are - too meager to\n                                            // quickly diagnose the problem while we hadn't. So the code got littered with debug prints\n                                            // and finally it hit me what the *F* went wrong, after which I saw I needed to add *this* rule!)\n\n                                            // first push the 'trail' condition which will be the follow-up after we're done parsing the path parameter...\n                                            this.pushState('trail'); \n                                            // then push the immediate need: the 'path' condition.\n                                            this.pushState('path'); \n                                            return 'INCLUDE';\n                                        %} \n<indented>.+                            this.begin('rules'); return 'ACTION';\n\n\"/*\"(.|\\n|\\r)*?\"*/\"                     /* ignore */\n\"//\".*                                  /* ignore */\n\n{BR}+                                   /* empty */\n\\s+                                     /* empty */\n{ID}                                    return 'NAME';\n\\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"                 yytext = yytext.replace(/\\\\\"/g,'\"'); return 'STRING_LIT';\n\"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"               yytext = yytext.replace(/\\\\'/g,\"'\"); return 'STRING_LIT';\n\"[\"                                     this.pushState('set'); return 'REGEX_SET_START';\n\"|\"                                     return '|';\n// \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"            return 'ANY_GROUP_REGEX';\n\"(?:\"                                   return 'SPECIAL_GROUP';\n\"(?=\"                                   return 'SPECIAL_GROUP';\n\"(?!\"                                   return 'SPECIAL_GROUP';\n\"(\"                                     return '(';\n\")\"                                     return ')';\n\"+\"                                     return '+';\n\"*\"                                     return '*';\n\"?\"                                     return '?';\n\"^\"                                     return '^';\n\",\"                                     return ',';\n\"<<EOF>>\"                               return '$';\n\"<\"                                     this.begin('conditions'); return '<';\n\"/!\"                                    return '/!';                    // treated as `(?!atom)`\n\"/\"                                     return '/';                     // treated as `(?=atom)` \n\"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4})\n                                        return 'ESCAPE_CHAR';\n\"\\\\\".                                   yytext = yytext.replace(/^\\\\/g, ''); return 'ESCAPE_CHAR';\n\"$\"                                     return '$';\n\".\"                                     return '.';\n\"%options\"                              this.begin('options'); return 'OPTIONS';\n\"%s\"                                    this.begin('start_condition'); return 'START_INC';\n\"%x\"                                    this.begin('start_condition'); return 'START_EXC';\n<INITIAL,trail,code>\"%include\"          this.pushState('path'); return 'INCLUDE';\n<INITIAL,rules,trail,code>\"%\"{NAME}[^\\r\\n]+                       \n                                        %{ \n                                            /* ignore unrecognized decl */\n                                            console.warn('ignoring unsupported lexer option: ', yytext + ' while lexing in ' + this.topState() + ' state:', this._input, ' /////// ', this.matched);\n                                            return 'UNKNOWN_DECL';\n                                        %}\n\"%%\"                                    this.begin('rules'); return '%%';\n\"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"               return 'RANGE_REGEX';\n\"{\"{ID}\"}\"                              return 'NAME_BRACE';\n<set,options>\"{\"{ID}\"}\"                 return 'NAME_BRACE';\n\"{\"                                     return '{';\n\"}\"                                     return '}';\n.                                       throw new Error(\"unsupported input character: \" + yytext + \" @ \" + JSON.stringify(yylloc)); /* b0rk on bad characters */\n<*><<EOF>>                              return 'EOF';\n\n\n<set>(\"\\\\\\\\\"|\"\\]\"|[^\\]])+               return 'REGEX_SET';\n<set>\"]\"                                this.popState('set'); return 'REGEX_SET_END';\n\n\n// in the trailing CODE block, only accept these `%include` macros when they appear at the start of a line\n// and make sure the rest of lexer regexes account for this one so it'll match that way only:\n<code>[^\\r\\n]*(\\r|\\n)+                  return 'CODE';\n<code>[^\\r\\n]+                          return 'CODE';      // the bit of CODE just before EOF...\n\n\n<path>[\\r\\n]                            this.popState(); this.unput(yytext);\n<path>\"'\"[^\\r\\n]+\"'\"                    yytext = yytext.substr(1, yyleng - 2); this.popState(); return 'PATH';\n<path>'\"'[^\\r\\n]+'\"'                    yytext = yytext.substr(1, yyleng - 2); this.popState(); return 'PATH';\n<path>\\s+                               // skip whitespace in the line\n<path>[^\\s\\r\\n]+                        this.popState(); return 'PATH';\n\n<*>.                                    %{ \n                                            /* ignore unrecognized decl */\n                                            console.warn('ignoring unsupported lexer input: ', yytext, ' @ ' + JSON.stringify(yylloc) + 'while lexing in ' + this.topState() + ' state:', this._input, ' /////// ', this.matched);\n                                        %}\n\n%%\n```\n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "lex-parser@0.1.4-122",
  "_shasum": "843c03f91cc54f2767e0bf30d250ee41b736c478",
  "_from": "gerhobbelt/lex-parser#master",
  "_resolved": "git://github.com/gerhobbelt/lex-parser.git#673175a3bce86f9b754dcb13c85b2e448716b654"
}
